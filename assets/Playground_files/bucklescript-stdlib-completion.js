[].push.apply(window.complationData,[{"path": "Node_process", "name": "t", "type": "type t = Js.t(\n  &lt; abort : (unit -&gt; unit [@bs.meth]); arch : string; argv : string array;\n  chdir : (string -&gt; unit [@bs.meth]); cwd : (unit -&gt; string [@bs.meth]);\n  disconnect : (unit -&gt; unit [@bs.meth]); env : string Js_dict.t;\n  platform : string &gt;\n)", "docs": null, "kind": "type"}, {"path": "Node_process", "name": "process", "type": "let process: t", "docs": null, "kind": "value"}, {"path": "Node_process", "name": "argv", "type": "let argv: array(string)", "docs": null, "kind": "value"}, {"path": "Node_process", "name": "exit", "type": "let exit: int => unit", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Node_process", "name": "cwd", "type": "let cwd: unit => string", "docs": "<p>The process.uptime() method returns the number of seconds the current Node.js process has been running.)</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Node_process", "name": "uptime", "type": "let uptime: (t, unit) => float", "docs": "<p>The process.uptime() method returns the number of seconds the current Node.js process has been running.)</p>\n", "kind": "value", "args": [["", "t"], ["", "unit"]]}, {"path": "Node_process", "name": "putEnvVar", "type": "let putEnvVar: (string, string) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node_process", "name": "deleteEnvVar", "type": "let deleteEnvVar: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "Node_process", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>argv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cwd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>deleteEnvVar\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>process\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>putEnvVar\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uptime\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Node_path", "name": "basename", "type": "let basename: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_path", "name": "basename_ext", "type": "let basename_ext: (string, string) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node_path", "name": "delimiter", "type": "let delimiter: string", "docs": null, "kind": "value"}, {"path": "Node_path", "name": "dirname", "type": "let dirname: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_path", "name": "dirname_ext", "type": "let dirname_ext: (string, string) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node_path", "name": "pathObject", "type": "type pathObject = Js.t(\n  &lt; base : string; dir : string; ext : string; name : string; root : string &gt;\n)", "docs": null, "kind": "type"}, {"path": "Node_path", "name": "format", "type": "let format: pathObject => string", "docs": null, "kind": "value", "args": [["", "pathObject"]]}, {"path": "Node_path", "name": "isAbsolute", "type": "let isAbsolute: string => bool", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_path", "name": "join2", "type": "let join2: (string, string) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node_path", "name": "join", "type": "let join: array(string) => string", "docs": null, "kind": "value", "args": [["", "array(string)"]]}, {"path": "Node_path", "name": "normalize", "type": "let normalize: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_path", "name": "parse", "type": "let parse: string => pathObject", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_path", "name": "relative", "type": "let relative: (~from: string, ~to_: string, unit) => string", "docs": null, "kind": "value", "args": [["from", "string"], ["to_", "string"], ["", "unit"]]}, {"path": "Node_path", "name": "resolve", "type": "let resolve: (string, string) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node_path", "name": "sep", "type": "let sep: string", "docs": null, "kind": "value"}, {"path": "", "name": "Node_path", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>basename\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>basename_ext\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>delimiter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dirname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dirname_ext\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isAbsolute\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>join\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>join2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>normalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>relative\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>resolve\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sep\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>pathObject", "docs": null, "kind": "module"}, {"path": "Node_module", "name": "module_", "type": "let module_: Js.t(&lt; __cache : Node.node_module Js_dict.t &gt;)", "docs": null, "kind": "value"}, {"path": "", "name": "Node_module", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>module_", "docs": null, "kind": "module"}, {"path": "Node_fs", "name": "readdirSync", "type": "let readdirSync: string => array(string)", "docs": "<p>Most fs functions let you omit the callback argument. If you do, a default callback is used that rethrows errors. To get a trace to the original call site, set the `NODE_DEBUG` environment variable:</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Node_fs", "name": "renameSync", "type": "let renameSync: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_fs", "name": "fd", "type": "type fd = int", "docs": null, "kind": "type"}, {"path": "Node_fs", "name": "path", "type": "type path = string", "docs": "<p>The relative path to a filename can be used. Remember, however, that this path will be relative to <code>process.cwd()</code>.</p>\n", "kind": "type"}, {"path": "Node_fs.Watch", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Node_fs.Watch", "name": "config", "type": "type config", "docs": null, "kind": "type"}, {"path": "Node_fs.Watch", "name": "config", "type": "let config: (\n  ~?persistent: option(Js.boolean),\n  ~?recursive: option(Js.boolean),\n  ~?encoding: option(Js_string.t),\n  unit\n) => config", "docs": null, "kind": "value", "args": [["persistent", "Js.boolean (optional)"], ["recursive", "Js.boolean (optional)"], ["encoding", "Js_string.t (optional)"], ["", "unit"]]}, {"path": "Node_fs.Watch", "name": "watch", "type": "let watch: (string, ~?config: option(config), unit) => t", "docs": "<p>there is no need to accept listener, since we return a <code>watcher</code> back it can register event listener there . Currently we introduce a type <code>string_buffer</code>, for the <code>filename</code>, it will be <code>Buffer</code> when the encoding is `utf8. This is dependent type which can be tracked by GADT in some way, but to make things simple, let&#39;s just introduce an or type</p>\n", "kind": "value", "args": [["", "string"], ["config", "config (optional)"], ["", "unit"]]}, {"path": "Node_fs.Watch", "name": "on", "type": "let on: (\n  [ `change of (string -&gt; Node.string_buffer -&gt; unit [@bs])\n| `error of (unit -&gt; unit [@bs]) ],\n  t\n) => t", "docs": "<p>there is no need to accept listener, since we return a <code>watcher</code> back it can register event listener there . Currently we introduce a type <code>string_buffer</code>, for the <code>filename</code>, it will be <code>Buffer</code> when the encoding is `utf8. This is dependent type which can be tracked by GADT in some way, but to make things simple, let&#39;s just introduce an or type</p>\n", "kind": "value", "args": [["", "[ `change of (string -&gt; Node.string_buffer -&gt; unit [@bs])\n| `error of (unit -&gt; unit [@bs]) ]"], ["", "t"]]}, {"path": "Node_fs.Watch", "name": "close", "type": "let close: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Node_fs", "name": "Watch", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>config\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>on\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>watch\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>config\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Node_fs", "name": "ftruncateSync", "type": "let ftruncateSync: (fd, int) => unit", "docs": null, "kind": "value", "args": [["", "fd"], ["", "int"]]}, {"path": "Node_fs", "name": "truncateSync", "type": "let truncateSync: (string, int) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "Node_fs", "name": "chownSync", "type": "let chownSync: (string, ~uid: int, ~gid: int) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["uid", "int"], ["gid", "int"]]}, {"path": "Node_fs", "name": "fchownSync", "type": "let fchownSync: (fd, ~uid: int, ~gid: int) => unit", "docs": null, "kind": "value", "args": [["", "fd"], ["uid", "int"], ["gid", "int"]]}, {"path": "Node_fs", "name": "readlinkSync", "type": "let readlinkSync: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_fs", "name": "unlinkSync", "type": "let unlinkSync: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_fs", "name": "rmdirSync", "type": "let rmdirSync: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_fs", "name": "openSync", "type": "let openSync: (\n  path,\n  [ `Append\n| `Append_fail_if_exists\n| `Append_read\n| `Append_read_fail_if_exists\n| `Read\n| `Read_write\n| `Read_write_sync\n| `Write\n| `Write_fail_if_exists\n| `Write_read\n| `Write_read_fail_if_exists ]\n) => unit", "docs": null, "kind": "value", "args": [["", "path"], ["", "[ `Append\n| `Append_fail_if_exists\n| `Append_read\n| `Append_read_fail_if_exists\n| `Read\n| `Read_write\n| `Read_write_sync\n| `Write\n| `Write_fail_if_exists\n| `Write_read\n| `Write_read_fail_if_exists ]"]]}, {"path": "Node_fs", "name": "readFileSync", "type": "let readFileSync: (\n  string,\n  [ `ascii | `base64 | `binary | `hex | `latin1 | `ucs2 | `utf16le | `utf8 ]\n) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "[ `ascii | `base64 | `binary | `hex | `latin1 | `ucs2 | `utf16le | `utf8 ]"]]}, {"path": "Node_fs", "name": "readFileAsUtf8Sync", "type": "let readFileAsUtf8Sync: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_fs", "name": "existsSync", "type": "let existsSync: string => bool", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_fs", "name": "writeFileSync", "type": "let writeFileSync: (\n  string,\n  string,\n  [ `ascii | `base64 | `binary | `hex | `latin1 | `ucs2 | `utf16le | `utf8 ]\n) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"], ["", "[ `ascii | `base64 | `binary | `hex | `latin1 | `ucs2 | `utf16le | `utf8 ]"]]}, {"path": "Node_fs", "name": "writeFileAsUtf8Sync", "type": "let writeFileAsUtf8Sync: (string, string) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "", "name": "Node_fs", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chownSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>existsSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fchownSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ftruncateSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>openSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readFileAsUtf8Sync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readFileSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readdirSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readlinkSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>renameSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rmdirSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncateSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unlinkSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>writeFileAsUtf8Sync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>writeFileSync\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>fd\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>path\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Watch", "docs": null, "kind": "module"}, {"path": "Node_child_process", "name": "option", "type": "type option", "docs": null, "kind": "type"}, {"path": "Node_child_process", "name": "option", "type": "let option: (~?cwd: option(string), ~?encoding: option(string), unit) => option", "docs": null, "kind": "value", "args": [["cwd", "string (optional)"], ["encoding", "string (optional)"], ["", "unit"]]}, {"path": "Node_child_process", "name": "execSync", "type": "let execSync: (string, option) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "option"]]}, {"path": "Node_child_process", "name": "spawnResult", "type": "type spawnResult", "docs": null, "kind": "type"}, {"path": "Node_child_process", "name": "spawnSync", "type": "let spawnSync: string => spawnResult", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node_child_process", "name": "readAs", "type": "let readAs: spawnResult => Js.t(\n  &lt; pid : int; signal : string Js.null; status : int Js.null;\n  stderr : Node.string_buffer Js.null; stdout : Node.string_buffer Js.null &gt;\n)", "docs": null, "kind": "value", "args": [["", "spawnResult"]]}, {"path": "", "name": "Node_child_process", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>option\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readAs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>spawnSync\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>spawnResult", "docs": null, "kind": "module"}, {"path": "Node_buffer", "name": "t", "type": "type t = Node.buffer", "docs": null, "kind": "type"}, {"path": "Node_buffer", "name": "isBuffer", "type": "let isBuffer: 'a => bool", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Node_buffer", "name": "fromString", "type": "let fromString: string => t", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "Node_buffer", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isBuffer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Node.Path", "name": "basename", "type": "let basename: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Path", "name": "basename_ext", "type": "let basename_ext: (string, string) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node.Path", "name": "delimiter", "type": "let delimiter: string", "docs": null, "kind": "value"}, {"path": "Node.Path", "name": "dirname", "type": "let dirname: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Path", "name": "dirname_ext", "type": "let dirname_ext: (string, string) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node.Path", "name": "pathObject", "type": "type pathObject = Js.t(\n  &lt; base : string; dir : string; ext : string; name : string; root : string &gt;\n)", "docs": null, "kind": "type"}, {"path": "Node.Path", "name": "format", "type": "let format: pathObject => string", "docs": null, "kind": "value", "args": [["", "pathObject"]]}, {"path": "Node.Path", "name": "isAbsolute", "type": "let isAbsolute: string => bool", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Path", "name": "join2", "type": "let join2: (string, string) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node.Path", "name": "join", "type": "let join: array(string) => string", "docs": null, "kind": "value", "args": [["", "array(string)"]]}, {"path": "Node.Path", "name": "normalize", "type": "let normalize: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Path", "name": "parse", "type": "let parse: string => pathObject", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Path", "name": "relative", "type": "let relative: (~from: string, ~to_: string, unit) => string", "docs": null, "kind": "value", "args": [["from", "string"], ["to_", "string"], ["", "unit"]]}, {"path": "Node.Path", "name": "resolve", "type": "let resolve: (string, string) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node.Path", "name": "sep", "type": "let sep: string", "docs": null, "kind": "value"}, {"path": "Node", "name": "Path", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>basename\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>basename_ext\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>delimiter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dirname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dirname_ext\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isAbsolute\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>join\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>join2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>normalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>relative\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>resolve\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sep\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>pathObject", "docs": null, "kind": "module"}, {"path": "Node.Fs", "name": "readdirSync", "type": "let readdirSync: string => array(string)", "docs": "<p>Most fs functions let you omit the callback argument. If you do, a default callback is used that rethrows errors. To get a trace to the original call site, set the `NODE_DEBUG` environment variable:</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Node.Fs", "name": "renameSync", "type": "let renameSync: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Fs", "name": "fd", "type": "type fd = int", "docs": null, "kind": "type"}, {"path": "Node.Fs", "name": "path", "type": "type path = string", "docs": "<p>The relative path to a filename can be used. Remember, however, that this path will be relative to <code>process.cwd()</code>.</p>\n", "kind": "type"}, {"path": "Node.Fs.Watch", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Node.Fs.Watch", "name": "config", "type": "type config", "docs": null, "kind": "type"}, {"path": "Node.Fs.Watch", "name": "config", "type": "let config: (\n  ~?persistent: option(Js.boolean),\n  ~?recursive: option(Js.boolean),\n  ~?encoding: option(Js_string.t),\n  unit\n) => config", "docs": null, "kind": "value", "args": [["persistent", "Js.boolean (optional)"], ["recursive", "Js.boolean (optional)"], ["encoding", "Js_string.t (optional)"], ["", "unit"]]}, {"path": "Node.Fs.Watch", "name": "watch", "type": "let watch: (string, ~?config: option(config), unit) => t", "docs": "<p>there is no need to accept listener, since we return a <code>watcher</code> back it can register event listener there . Currently we introduce a type <code>string_buffer</code>, for the <code>filename</code>, it will be <code>Buffer</code> when the encoding is `utf8. This is dependent type which can be tracked by GADT in some way, but to make things simple, let&#39;s just introduce an or type</p>\n", "kind": "value", "args": [["", "string"], ["config", "config (optional)"], ["", "unit"]]}, {"path": "Node.Fs.Watch", "name": "on", "type": "let on: (\n  [ `change of (string -&gt; Node.string_buffer -&gt; unit [@bs])\n| `error of (unit -&gt; unit [@bs]) ],\n  t\n) => t", "docs": "<p>there is no need to accept listener, since we return a <code>watcher</code> back it can register event listener there . Currently we introduce a type <code>string_buffer</code>, for the <code>filename</code>, it will be <code>Buffer</code> when the encoding is `utf8. This is dependent type which can be tracked by GADT in some way, but to make things simple, let&#39;s just introduce an or type</p>\n", "kind": "value", "args": [["", "[ `change of (string -&gt; Node.string_buffer -&gt; unit [@bs])\n| `error of (unit -&gt; unit [@bs]) ]"], ["", "t"]]}, {"path": "Node.Fs.Watch", "name": "close", "type": "let close: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Node.Fs", "name": "Watch", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>config\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>on\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>watch\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>config\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Node.Fs", "name": "ftruncateSync", "type": "let ftruncateSync: (fd, int) => unit", "docs": null, "kind": "value", "args": [["", "fd"], ["", "int"]]}, {"path": "Node.Fs", "name": "truncateSync", "type": "let truncateSync: (string, int) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "Node.Fs", "name": "chownSync", "type": "let chownSync: (string, ~uid: int, ~gid: int) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["uid", "int"], ["gid", "int"]]}, {"path": "Node.Fs", "name": "fchownSync", "type": "let fchownSync: (fd, ~uid: int, ~gid: int) => unit", "docs": null, "kind": "value", "args": [["", "fd"], ["uid", "int"], ["gid", "int"]]}, {"path": "Node.Fs", "name": "readlinkSync", "type": "let readlinkSync: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Fs", "name": "unlinkSync", "type": "let unlinkSync: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Fs", "name": "rmdirSync", "type": "let rmdirSync: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Fs", "name": "openSync", "type": "let openSync: (\n  path,\n  [ `Append\n| `Append_fail_if_exists\n| `Append_read\n| `Append_read_fail_if_exists\n| `Read\n| `Read_write\n| `Read_write_sync\n| `Write\n| `Write_fail_if_exists\n| `Write_read\n| `Write_read_fail_if_exists ]\n) => unit", "docs": null, "kind": "value", "args": [["", "path"], ["", "[ `Append\n| `Append_fail_if_exists\n| `Append_read\n| `Append_read_fail_if_exists\n| `Read\n| `Read_write\n| `Read_write_sync\n| `Write\n| `Write_fail_if_exists\n| `Write_read\n| `Write_read_fail_if_exists ]"]]}, {"path": "Node.Fs", "name": "readFileSync", "type": "let readFileSync: (\n  string,\n  [ `ascii | `base64 | `binary | `hex | `latin1 | `ucs2 | `utf16le | `utf8 ]\n) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "[ `ascii | `base64 | `binary | `hex | `latin1 | `ucs2 | `utf16le | `utf8 ]"]]}, {"path": "Node.Fs", "name": "readFileAsUtf8Sync", "type": "let readFileAsUtf8Sync: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Fs", "name": "existsSync", "type": "let existsSync: string => bool", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Fs", "name": "writeFileSync", "type": "let writeFileSync: (\n  string,\n  string,\n  [ `ascii | `base64 | `binary | `hex | `latin1 | `ucs2 | `utf16le | `utf8 ]\n) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"], ["", "[ `ascii | `base64 | `binary | `hex | `latin1 | `ucs2 | `utf16le | `utf8 ]"]]}, {"path": "Node.Fs", "name": "writeFileAsUtf8Sync", "type": "let writeFileAsUtf8Sync: (string, string) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node", "name": "Fs", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chownSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>existsSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fchownSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ftruncateSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>openSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readFileAsUtf8Sync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readFileSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readdirSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readlinkSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>renameSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rmdirSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncateSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unlinkSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>writeFileAsUtf8Sync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>writeFileSync\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>fd\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>path\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Watch", "docs": null, "kind": "module"}, {"path": "Node.Process", "name": "t", "type": "type t = Js.t(\n  &lt; abort : (unit -&gt; unit [@bs.meth]); arch : string; argv : string array;\n  chdir : (string -&gt; unit [@bs.meth]); cwd : (unit -&gt; string [@bs.meth]);\n  disconnect : (unit -&gt; unit [@bs.meth]); env : string Js_dict.t;\n  platform : string &gt;\n)", "docs": null, "kind": "type"}, {"path": "Node.Process", "name": "process", "type": "let process: t", "docs": null, "kind": "value"}, {"path": "Node.Process", "name": "argv", "type": "let argv: array(string)", "docs": null, "kind": "value"}, {"path": "Node.Process", "name": "exit", "type": "let exit: int => unit", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Node.Process", "name": "cwd", "type": "let cwd: unit => string", "docs": "<p>The process.uptime() method returns the number of seconds the current Node.js process has been running.)</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Node.Process", "name": "uptime", "type": "let uptime: (t, unit) => float", "docs": "<p>The process.uptime() method returns the number of seconds the current Node.js process has been running.)</p>\n", "kind": "value", "args": [["", "t"], ["", "unit"]]}, {"path": "Node.Process", "name": "putEnvVar", "type": "let putEnvVar: (string, string) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Node.Process", "name": "deleteEnvVar", "type": "let deleteEnvVar: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node", "name": "Process", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>argv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cwd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>deleteEnvVar\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>process\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>putEnvVar\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uptime\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Node.Module", "name": "module_", "type": "let module_: Js.t(&lt; __cache : Node.node_module Js_dict.t &gt;)", "docs": null, "kind": "value"}, {"path": "Node", "name": "Module", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>module_", "docs": null, "kind": "module"}, {"path": "Node.Buffer", "name": "t", "type": "type t = Node.buffer", "docs": null, "kind": "type"}, {"path": "Node.Buffer", "name": "isBuffer", "type": "let isBuffer: 'a => bool", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Node.Buffer", "name": "fromString", "type": "let fromString: string => t", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node", "name": "Buffer", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isBuffer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Node.Child_process", "name": "option", "type": "type option", "docs": null, "kind": "type"}, {"path": "Node.Child_process", "name": "option", "type": "let option: (~?cwd: option(string), ~?encoding: option(string), unit) => option", "docs": null, "kind": "value", "args": [["cwd", "string (optional)"], ["encoding", "string (optional)"], ["", "unit"]]}, {"path": "Node.Child_process", "name": "execSync", "type": "let execSync: (string, option) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "option"]]}, {"path": "Node.Child_process", "name": "spawnResult", "type": "type spawnResult", "docs": null, "kind": "type"}, {"path": "Node.Child_process", "name": "spawnSync", "type": "let spawnSync: string => spawnResult", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Node.Child_process", "name": "readAs", "type": "let readAs: spawnResult => Js.t(\n  &lt; pid : int; signal : string Js.null; status : int Js.null;\n  stderr : Node.string_buffer Js.null; stdout : Node.string_buffer Js.null &gt;\n)", "docs": null, "kind": "value", "args": [["", "spawnResult"]]}, {"path": "Node", "name": "Child_process", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execSync\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>option\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readAs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>spawnSync\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>spawnResult", "docs": null, "kind": "module"}, {"path": "Node", "name": "node_exports", "type": "type node_exports", "docs": null, "kind": "type"}, {"path": "Node", "name": "node_module", "type": "type node_module = Js.t(\n  &lt; children : node_module array; exports : node_exports; filename : string;\n  id : string; loaded : Js.boolean; parrent : node_module Js.null_undefined;\n  paths : string array &gt;\n)", "docs": null, "kind": "type"}, {"path": "Node", "name": "node_require", "type": "type node_require = Js.t(\n  &lt; main : node_module Js.undefined; resolve : (string -&gt; string [@bs]) &gt;\n)", "docs": null, "kind": "type"}, {"path": "Node", "name": "string_buffer", "type": "type string_buffer", "docs": null, "kind": "type"}, {"path": "Node", "name": "buffer", "type": "type buffer", "docs": null, "kind": "type"}, {"path": "Node", "name": "string_buffer_kind", "type": "type string_buffer_kind('_) = \n  | String: string_buffer_kind(string)\n  | Buffer: string_buffer_kind(buffer)\n", "docs": null, "kind": "type"}, {"path": "Node", "name": "test", "type": "let test: string_buffer => (string_buffer_kind('a), 'a)", "docs": "<p>We expect a good inliner will eliminate such boxing in the future</p>\n", "kind": "value", "args": [["", "string_buffer"]]}, {"path": "", "name": "Node", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>buffer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>node_exports\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>node_module\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>node_require\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>string_buffer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>string_buffer_kind\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Buffer\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Child_process\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Fs\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Module\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Path\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Process", "docs": null, "kind": "module"}, {"path": "Js_vector", "name": "t", "type": "type t('a) = array('a)", "docs": null, "kind": "type"}, {"path": "Js_vector", "name": "filterInPlace", "type": "let filterInPlace: (Js.Internal.fn([ `Arity_1 of 'a6 ], bool), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a6 ], bool)"], ["", "t('a)"]]}, {"path": "Js_vector", "name": "empty", "type": "let empty: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_vector", "name": "pushBack", "type": "let pushBack: ('a, t('a)) => unit", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_vector", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": "<p>shallow copy</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_vector", "name": "memByRef", "type": "let memByRef: ('a, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_vector", "name": "iter", "type": "let iter: (Js.Internal.fn([ `Arity_1 of 'a5 ], unit), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a5 ], unit)"], ["", "t('a)"]]}, {"path": "Js_vector", "name": "iteri", "type": "let iteri: (Js.Internal.fn([ `Arity_2 of int * 'a4 ], unit), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of int * 'a4 ], unit)"], ["", "t('a)"]]}, {"path": "Js_vector", "name": "toList", "type": "let toList: t('a) => list('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_vector", "name": "map", "type": "let map: (Js.Internal.fn([ `Arity_1 of 'a3 ], 'b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a3 ], 'b)"], ["", "t('a)"]]}, {"path": "Js_vector", "name": "mapi", "type": "let mapi: (Js.Internal.fn([ `Arity_2 of int * 'a2 ], 'b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of int * 'a2 ], 'b)"], ["", "t('a)"]]}, {"path": "Js_vector", "name": "foldLeft", "type": "let foldLeft: (Js.Internal.fn([ `Arity_2 of 'a1 * 'b1 ], 'a), 'a, t('b)) => 'a", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a1 * 'b1 ], 'a)"], ["", "'a"], ["", "t('b)"]]}, {"path": "Js_vector", "name": "foldRight", "type": "let foldRight: (Js.Internal.fn([ `Arity_2 of 'b0 * 'a0 ], 'a), t('b), 'a) => 'a", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'b0 * 'a0 ], 'a)"], ["", "t('b)"], ["", "'a"]]}, {"path": "Js_vector", "name": "length", "type": "let length: t('a) => int", "docs": "<p>Return the length (number of elements) of the given array.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_vector", "name": "get", "type": "let get: (t('a), int) => 'a", "docs": "<p><code>Array.get a n</code> returns the element number <code>n</code> of array <code>a</code>. The first element has number 0. The last element has number <code>Array.length a - 1</code>. You can also write <code>a.(n)</code> instead of <code>Array.get a n</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>(Array.length a - 1)</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Js_vector", "name": "set", "type": "let set: (t('a), int, 'a) => unit", "docs": "<p><code>Array.set a n x</code> modifies array <code>a</code> in place, replacing element number <code>n</code> with <code>x</code>. You can also write <code>a.(n) &lt;- x</code> instead of <code>Array.set a n x</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>Array.length a - 1</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"], ["", "'a"]]}, {"path": "Js_vector", "name": "make", "type": "let make: (int, 'a) => t('a)", "docs": "<p><code>Array.make n x</code> returns a fresh array of length <code>n</code>, initialized with <code>x</code>. All the elements of this new array are initially physically equal to <code>x</code> (in the sense of the <code>==</code> predicate). Consequently, if <code>x</code> is mutable, it is shared among all elements of the array, and modifying <code>x</code> through one of the array entries will modify all other entries at the same time.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the value of <code>x</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Js_vector", "name": "init", "type": "let init: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => t('a)", "docs": "<p>Param: n<p>size</p></p>\n<p>Param: fn<p>callback</p></p>\n<p>Raises: RangeError<p>when <code>n</code> is negative</p></p>\n", "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Js_vector", "name": "append", "type": "let append: ('a, t('a)) => t('a)", "docs": "<p><code>append x a</code> returns a fresh array with x appended to a</p>\n", "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_vector", "name": "unsafe_get", "type": "let unsafe_get: (t('a), int) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Js_vector", "name": "unsafe_set", "type": "let unsafe_set: (t('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "int"], ["", "'a"]]}, {"path": "", "name": "Js_vector", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filterInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>foldLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>foldRight\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>memByRef\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pushBack\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_types", "name": "symbol", "type": "type symbol", "docs": "<p>Js symbol type only available in ES6</p>\n", "kind": "type"}, {"path": "Js_types", "name": "obj_val", "type": "type obj_val", "docs": null, "kind": "type"}, {"path": "Js_types", "name": "undefined_val", "type": "type undefined_val", "docs": "<p>This type has only one value <code>undefined</code></p>\n", "kind": "type"}, {"path": "Js_types", "name": "null_val", "type": "type null_val", "docs": "<p>This type has only one value <code>undefined</code></p>\n", "kind": "type"}, {"path": "Js_types", "name": "function_val", "type": "type function_val", "docs": "<p>This type has only one value <code>null</code></p>\n", "kind": "type"}, {"path": "Js_types", "name": "t", "type": "type t('_) = \n  | Undefined: t(undefined_val)\n  | Null: t(null_val)\n  | Boolean: t(Js.boolean)\n  | Number: t(float)\n  | String: t(string)\n  | Function: t(function_val)\n  | Object: t(obj_val)\n  | Symbol: t(symbol)\n", "docs": null, "kind": "type"}, {"path": "Js_types", "name": "reify_type", "type": "let reify_type: 'a => (t('b), 'b)", "docs": "<p>Given any value it returns its type and the same value. Note that since <code>&#39;b t</code> is GADT, the type system will reify its type automatically,</p>\n<pre class='ml'><code class='ml'>match reify_type &quot;3&quot; with\n| String, v -&gt; v  ^ &quot; this type safe control flow analysis will infer v as string&quot;\n| _ -&gt; assert false\n</code></pre>", "kind": "value", "args": [["", "'a"]]}, {"path": "Js_types", "name": "test", "type": "let test: ('a, t('b)) => bool", "docs": "<pre class='ml'><code class='ml'>test &quot;x&quot; String = true\n</code></pre>", "kind": "value", "args": [["", "'a"], ["", "t('b)"]]}, {"path": "Js_types", "name": "tagged_t", "type": "type tagged_t = \n  | JSFalse\n  | JSTrue\n  | JSNull\n  | JSUndefined\n  | JSNumber(float)\n  | JSString(string)\n  | JSFunction(function_val)\n  | JSObject(obj_val)\n  | JSSymbol(symbol)\n", "docs": null, "kind": "type"}, {"path": "Js_types", "name": "classify", "type": "let classify: 'a => tagged_t", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "", "name": "Js_types", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>classify\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reify_type\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>function_val\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>null_val\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>obj_val\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>symbol\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>tagged_t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>undefined_val", "docs": null, "kind": "module"}, {"path": "Js_string", "name": "t", "type": "type t = string", "docs": null, "kind": "type"}, {"path": "Js_string", "name": "make", "type": "let make: 'a => t", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js_string", "name": "fromCharCode", "type": "let fromCharCode: int => t", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Js_string", "name": "fromCharCodeMany", "type": "let fromCharCodeMany: array(int) => t", "docs": null, "kind": "value", "args": [["", "array(int)"]]}, {"path": "Js_string", "name": "fromCodePoint", "type": "let fromCodePoint: int => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Js_string", "name": "fromCodePointMany", "type": "let fromCodePointMany: array(int) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "Js_string", "name": "length", "type": "let length: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_string", "name": "get", "type": "let get: (t, int) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Js_string", "name": "charAt", "type": "let charAt: (int, t) => t", "docs": null, "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "charCodeAt", "type": "let charCodeAt: (int, t) => float", "docs": null, "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "codePointAt", "type": "let codePointAt: (int, t) => option(int)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "concat", "type": "let concat: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "concatMany", "type": "let concatMany: (array(t), t) => t", "docs": null, "kind": "value", "args": [["", "array(t)"], ["", "t"]]}, {"path": "Js_string", "name": "endsWith", "type": "let endsWith: (t, t) => bool", "docs": "failed to parse: File &quot;&quot;, line 1, characters 18-52:\n&#39;{[...]}&#39; (code block) must begin on its own line", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "endsWithFrom", "type": "let endsWithFrom: (t, int, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "includes", "type": "let includes: (t, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "includesFrom", "type": "let includesFrom: (t, int, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "indexOf", "type": "let indexOf: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "indexOfFrom", "type": "let indexOfFrom: (t, int, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "lastIndexOf", "type": "let lastIndexOf: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "lastIndexOfFrom", "type": "let lastIndexOfFrom: (t, int, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "localeCompare", "type": "let localeCompare: (t, t) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "match_", "type": "let match_: (Js_re.t, t) => option(array(t))", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "t"]]}, {"path": "Js_string", "name": "normalize", "type": "let normalize: t => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_string", "name": "normalizeByForm", "type": "let normalizeByForm: (t, t) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "repeat", "type": "let repeat: (int, t) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "replace", "type": "let replace: (t, t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "replaceByRe", "type": "let replaceByRe: (Js_re.t, t, t) => t", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "unsafeReplaceBy0", "type": "let unsafeReplaceBy0: (Js_re.t, (t, int, t) => t, t) => t", "docs": "<p>returns a new string with some or all matches of a pattern replaced by the n function</p>\n<p>afeReplaceBy0 re (fun match offset whole -&gt; &quot;hi&quot;)</p>\n<p>prints &quot;hi world!&quot; *)</p>\n<p>lla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p>\n", "kind": "value", "args": [["", "Js_re.t"], ["", "(t, int, t) => t"], ["", "t"]]}, {"path": "Js_string", "name": "unsafeReplaceBy1", "type": "let unsafeReplaceBy1: (Js_re.t, (t, t, int, t) => t, t) => t", "docs": "<p>returns a new string with some or all matches of a pattern replaced by the n function</p>\n<p>afeReplaceBy1 re (fun match p1 offset whole -&gt; &quot;hi&quot;)</p>\n<p>prints &quot;hi world!&quot; *)</p>\n<p>lla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p>\n", "kind": "value", "args": [["", "Js_re.t"], ["", "(t, t, int, t) => t"], ["", "t"]]}, {"path": "Js_string", "name": "unsafeReplaceBy2", "type": "let unsafeReplaceBy2: (Js_re.t, (t, t, t, int, t) => t, t) => t", "docs": "<p>returns a new string with some or all matches of a pattern replaced by the n function</p>\n<p>afeReplaceBy2 re (fun match p1 p2 offset whole -&gt; &quot;hi&quot;)</p>\n<p>prints &quot;hi world!&quot; *)</p>\n<p>lla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p>\n", "kind": "value", "args": [["", "Js_re.t"], ["", "(t, t, t, int, t) => t"], ["", "t"]]}, {"path": "Js_string", "name": "unsafeReplaceBy3", "type": "let unsafeReplaceBy3: (Js_re.t, (t, t, t, t, int, t) => t, t) => t", "docs": "<p>returns a new string with some or all matches of a pattern replaced by the n function</p>\n<p>afeReplaceBy3 re (fun match p1 p2 p3 offset whole -&gt; &quot;hi&quot;)</p>\n<p>prints &quot;hi world!&quot; *)</p>\n<p>lla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p>\n", "kind": "value", "args": [["", "Js_re.t"], ["", "(t, t, t, t, int, t) => t"], ["", "t"]]}, {"path": "Js_string", "name": "search", "type": "let search: (Js_re.t, t) => int", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "t"]]}, {"path": "Js_string", "name": "slice", "type": "let slice: (~from: int, ~to_: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["to_", "int"], ["", "t"]]}, {"path": "Js_string", "name": "sliceToEnd", "type": "let sliceToEnd: (~from: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["", "t"]]}, {"path": "Js_string", "name": "split", "type": "let split: (t, t) => array(t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "splitAtMost", "type": "let splitAtMost: (t, ~limit: int, t) => array(t)", "docs": null, "kind": "value", "args": [["", "t"], ["limit", "int"], ["", "t"]]}, {"path": "Js_string", "name": "splitLimited", "type": "let splitLimited: (t, int, t) => array(t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "splitByRe", "type": "let splitByRe: (Js_re.t, t) => array(t)", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "t"]]}, {"path": "Js_string", "name": "splitByReAtMost", "type": "let splitByReAtMost: (Js_re.t, ~limit: int, t) => array(t)", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["limit", "int"], ["", "t"]]}, {"path": "Js_string", "name": "splitRegexpLimited", "type": "let splitRegexpLimited: (Js_re.t, int, t) => array(t)", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "startsWith", "type": "let startsWith: (t, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "startsWithFrom", "type": "let startsWithFrom: (t, int, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js_string", "name": "substr", "type": "let substr: (~from: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["", "t"]]}, {"path": "Js_string", "name": "substrAtMost", "type": "let substrAtMost: (~from: int, ~length: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["length", "int"], ["", "t"]]}, {"path": "Js_string", "name": "substring", "type": "let substring: (~from: int, ~to_: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["to_", "int"], ["", "t"]]}, {"path": "Js_string", "name": "substringToEnd", "type": "let substringToEnd: (~from: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["", "t"]]}, {"path": "Js_string", "name": "toLowerCase", "type": "let toLowerCase: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_string", "name": "toLocaleLowerCase", "type": "let toLocaleLowerCase: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_string", "name": "toUpperCase", "type": "let toUpperCase: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_string", "name": "toLocaleUpperCase", "type": "let toLocaleUpperCase: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_string", "name": "trim", "type": "let trim: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_string", "name": "anchor", "type": "let anchor: (t, t) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "link", "type": "let link: (t, t) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js_string", "name": "castToArrayLike", "type": "let castToArrayLike: t => Js_array.array_like(t)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "", "name": "Js_string", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>anchor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>castToArrayLike\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>charAt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>charCodeAt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>codePointAt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>endsWith\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>endsWithFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromCharCode\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromCharCodeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromCodePoint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromCodePointMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>includes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>includesFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>indexOf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>indexOfFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOfFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>link\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>localeCompare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>match_\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>normalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>normalizeByForm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>repeat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>replace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>replaceByRe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>search\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sliceToEnd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitAtMost\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitByRe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitByReAtMost\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitLimited\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitRegexpLimited\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>startsWith\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>startsWithFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>substr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>substrAtMost\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>substringToEnd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleLowerCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleUpperCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLowerCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toUpperCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeReplaceBy0\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeReplaceBy1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeReplaceBy2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeReplaceBy3\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_result", "name": "t", "type": "type t('good, 'bad) = | Ok('good) | Error('bad)\n", "docs": null, "kind": "type"}, {"path": "", "name": "Js_result", "type": "<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_re", "name": "t", "type": "type t", "docs": "<p>the RegExp object</p>\n", "kind": "type"}, {"path": "Js_re", "name": "result", "type": "type result", "docs": "<p>the result of a executing a RegExp on a string</p>\n", "kind": "type"}, {"path": "Js_re", "name": "captures", "type": "let captures: result => array(Js.nullable(string))", "docs": "<p>an array of the match and captures, the first is the full match and the remaining are the substring captures</p>\n", "kind": "value", "args": [["", "result"]]}, {"path": "Js_re", "name": "matches", "type": "let matches: result => array(string)", "docs": "<p>an array of the matches, the first is the full match and the remaining are the substring matches</p>\n<p>Deprecated: <p>Use <code>captures</code> instead.</p></p>\n", "kind": "value", "args": [["", "result"]]}, {"path": "Js_re", "name": "index", "type": "let index: result => int", "docs": "<p>0-based index of the match in the input string</p>\n", "kind": "value", "args": [["", "result"]]}, {"path": "Js_re", "name": "input", "type": "let input: result => string", "docs": "<p>the original input string</p>\n", "kind": "value", "args": [["", "result"]]}, {"path": "Js_re", "name": "fromString", "type": "let fromString: string => t", "docs": "failed to parse: File &quot;&quot;, line 3, characters 8-9:\nunpaired &#39;]&#39; (end of code)", "kind": "value", "args": [["", "string"]]}, {"path": "Js_re", "name": "fromStringWithFlags", "type": "let fromStringWithFlags: (string, ~flags: string) => t", "docs": "failed to parse: File &quot;&quot;, line 5, characters 0-2:\n&#39;{%&#39;: bad markup", "kind": "value", "args": [["", "string"], ["flags", "string"]]}, {"path": "Js_re", "name": "flags", "type": "let flags: t => string", "docs": "<p>returns the enabled flags as a string</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_re", "name": "global", "type": "let global: t => bool", "docs": "<p>returns a bool indicating whether the <code>global</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_re", "name": "ignoreCase", "type": "let ignoreCase: t => bool", "docs": "<p>returns a bool indicating whether the <code>ignoreCase</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_re", "name": "lastIndex", "type": "let lastIndex: t => int", "docs": "failed to parse: File &quot;&quot;, line 22, characters 105-105:\nend of text is not allowed in &#39;{[...]}&#39; (code block)", "kind": "value", "args": [["", "t"]]}, {"path": "Js_re", "name": "setLastIndex", "type": "let setLastIndex: (t, int) => unit", "docs": "<p>sets the index at which the next match will start its search from</p>\n", "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Js_re", "name": "multiline", "type": "let multiline: t => bool", "docs": "<p>returns a bool indicating whether the <code>multiline</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_re", "name": "source", "type": "let source: t => string", "docs": "<p>returns the pattern as a string</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_re", "name": "sticky", "type": "let sticky: t => bool", "docs": "<p>returns a bool indicating whether the <code>sticky</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_re", "name": "unicode", "type": "let unicode: t => bool", "docs": "<p>returns a bool indicating whether the <code>unicode</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_re", "name": "exec", "type": "let exec: (string, t) => option(result)", "docs": "failed to parse: File &quot;&quot;, line 2, characters 7-8:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "string"], ["", "t"]]}, {"path": "Js_re", "name": "test", "type": "let test: (string, t) => bool", "docs": "<p>tests whether the given RegExp object will match a given string</p>\n<p><strong>returns</strong> <code>true</code> if a match is found, <code>false</code> otherwise</p>\n<pre class='ml'><code class='ml'>(* A simple implementation of Js.String.startsWith *)\n\nlet str = &quot;hello world!&quot;\n\nlet startsWith substring target =\n  Js.Re.fromString (&quot;^&quot; ^ substring)\n    |&gt; Js.Re.test target\n\nlet () = Js.log (str |&gt; startsWith &quot;hello&quot;) (* prints &quot;true&quot; *)</code></pre><p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"], ["", "t"]]}, {"path": "", "name": "Js_re", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>captures\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exec\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromStringWithFlags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>global\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ignoreCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>matches\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>multiline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setLastIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>source\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sticky\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unicode\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>result\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_promise", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Js_promise", "name": "error", "type": "type error", "docs": null, "kind": "type"}, {"path": "Js_promise", "name": "make", "type": "let make: (\n  ~resolve: Js.Internal.fn([ `Arity_1 of 'a23 ], unit),\n  ~reject: Js.Internal.fn([ `Arity_1 of exn ], unit)\n) => unit => t('a)", "docs": null, "kind": "value", "args": [["", "(\n  ~resolve: Js.Internal.fn([ `Arity_1 of 'a23 ], unit),\n  ~reject: Js.Internal.fn([ `Arity_1 of exn ], unit)\n) => unit"]]}, {"path": "Js_promise", "name": "resolve", "type": "let resolve: 'a => t('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js_promise", "name": "reject", "type": "let reject: exn => t('a)", "docs": null, "kind": "value", "args": [["", "exn"]]}, {"path": "Js_promise", "name": "all", "type": "let all: array(t('a)) => t(array('a))", "docs": null, "kind": "value", "args": [["", "array(t('a))"]]}, {"path": "Js_promise", "name": "all2", "type": "let all2: (t('a0), t('a1)) => t(('a0, 'a1))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1))"]]}, {"path": "Js_promise", "name": "all3", "type": "let all3: (t('a0), t('a1), t('a2)) => t(('a0, 'a1, 'a2))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1), t('a2))"]]}, {"path": "Js_promise", "name": "all4", "type": "let all4: (t('a0), t('a1), t('a2), t('a3)) => t(('a0, 'a1, 'a2, 'a3))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1), t('a2), t('a3))"]]}, {"path": "Js_promise", "name": "all5", "type": "let all5: (t('a0), t('a1), t('a2), t('a3), t('a4)) => t(('a0, 'a1, 'a2, 'a3, 'a4))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1), t('a2), t('a3), t('a4))"]]}, {"path": "Js_promise", "name": "all6", "type": "let all6: (t('a0), t('a1), t('a2), t('a3), t('a4), t('a5)) => t(('a0, 'a1, 'a2, 'a3, 'a4, 'a5))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1), t('a2), t('a3), t('a4), t('a5))"]]}, {"path": "Js_promise", "name": "race", "type": "let race: array(t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array(t('a))"]]}, {"path": "Js_promise", "name": "then_", "type": "let then_: ('a => t('b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "'a => t('b)"], ["", "t('a)"]]}, {"path": "Js_promise", "name": "catch", "type": "let catch: (error => t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "error => t('a)"], ["", "t('a)"]]}, {"path": "", "name": "Js_promise", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all3\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all4\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all5\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all6\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>catch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>race\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reject\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>resolve\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>then_\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>error\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_option", "name": "t", "type": "type t('a) = option('a)", "docs": null, "kind": "type"}, {"path": "Js_option", "name": "some", "type": "let some: 'a => option('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js_option", "name": "isSome", "type": "let isSome: option('a) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js_option", "name": "isSomeValue", "type": "let isSomeValue: (Js.Internal.fn([ `Arity_2 of 'a21 * 'a21 ], bool), 'a, option('a)) => bool", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a21 * 'a21 ], bool)"], ["", "'a"], ["", "option('a)"]]}, {"path": "Js_option", "name": "isNone", "type": "let isNone: option('a) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js_option", "name": "getExn", "type": "let getExn: option('a) => 'a", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js_option", "name": "equal", "type": "let equal: (Js.Internal.fn([ `Arity_2 of 'a20 * 'b4 ], bool), option('a), option('b)) => bool", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a20 * 'b4 ], bool)"], ["", "option('a)"], ["", "option('b)"]]}, {"path": "Js_option", "name": "andThen", "type": "let andThen: (Js.Internal.fn([ `Arity_1 of 'a19 ], option('b)), option('a)) => option('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a19 ], option('b))"], ["", "option('a)"]]}, {"path": "Js_option", "name": "map", "type": "let map: (Js.Internal.fn([ `Arity_1 of 'a18 ], 'b), option('a)) => option('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a18 ], 'b)"], ["", "option('a)"]]}, {"path": "Js_option", "name": "getWithDefault", "type": "let getWithDefault: ('a, option('a)) => 'a", "docs": null, "kind": "value", "args": [["", "'a"], ["", "option('a)"]]}, {"path": "Js_option", "name": "default", "type": "let default: ('a, option('a)) => 'a", "docs": null, "kind": "value", "args": [["", "'a"], ["", "option('a)"]]}, {"path": "Js_option", "name": "filter", "type": "let filter: (Js.Internal.fn([ `Arity_1 of 'a17 ], bool), option('a)) => option('a)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a17 ], bool)"], ["", "option('a)"]]}, {"path": "Js_option", "name": "firstSome", "type": "let firstSome: (option('a), option('a)) => option('a)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('a)"]]}, {"path": "", "name": "Js_option", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>andThen\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>default\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>equal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>firstSome\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isNone\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSome\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSomeValue\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_obj", "name": "empty", "type": "let empty: unit => Js.t(&lt; .. &gt;)", "docs": "<p><code>empty ()</code> returns the empty object <code>\\{\\}</code></p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js_obj", "name": "assign", "type": "let assign: (Js.t(&lt; .. &gt;), Js.t(&lt; .. &gt;)) => Js.t(&lt; .. &gt;)", "docs": "failed to parse: File &quot;&quot;, line 5, characters 7-8:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "Js.t(&lt; .. &gt;)"], ["", "Js.t(&lt; .. &gt;)"]]}, {"path": "Js_obj", "name": "keys", "type": "let keys: Js.t('a) => array(string)", "docs": "<p><code>keys obj</code> returns an array of the keys of <code>obj</code>&#39;s own enumerable properties</p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "Js.t('a)"]]}, {"path": "", "name": "Js_obj", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>assign\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keys", "docs": null, "kind": "module"}, {"path": "Js_null_undefined", "name": "t", "type": "type t('a) = Js.null_undefined('a)", "docs": "<p>Local alias for <code>&#39;a Js.null_undefined</code></p>\n", "kind": "type"}, {"path": "Js_null_undefined", "name": "return", "type": "let return: 'a => t('a)", "docs": "<p>Constructs a value of <code>&#39;a Js.null_undefined</code> containing a value of <code>&#39;a</code></p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Js_null_undefined", "name": "test", "type": "let test: t('a) => bool", "docs": "<p>Returns <code>true</code> if the given value is <code>null</code> or <code>undefined</code>, <code>false</code> otherwise</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_null_undefined", "name": "null", "type": "let null: t('a)", "docs": "<p>The <code>null</code> value of type <code>&#39;a Js.null_undefined</code></p>\n", "kind": "value"}, {"path": "Js_null_undefined", "name": "undefined", "type": "let undefined: t('a)", "docs": "<p>The <code>undefined</code> value of type <code>&#39;a Js.null_undefined</code></p>\n", "kind": "value"}, {"path": "Js_null_undefined", "name": "bind", "type": "let bind: (t('a), Js.Internal.fn([ `Arity_1 of 'a25 ], 'b)) => t('b)", "docs": "<p>Maps the contained value using the given function</p>\n<p>If <code>&#39;a Js.null_undefined</code> contains a value, that value is unwrapped, mapped to a <code>&#39;b</code> using the given function <code>a&#39; -&gt; &#39;b</code>, then wrapped back up and returned as <code>&#39;b Js.null_undefined</code></p>\n<pre class='ml'><code class='ml'>let maybeGreetWorld (maybeGreeting: string Js.null_undefined) =\n  Js.Undefined.bind maybeGreeting (fun greeting -&gt; greeting ^ &quot; world!&quot;)</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a25 ], 'b)"]]}, {"path": "Js_null_undefined", "name": "iter", "type": "let iter: (t('a), Js.Internal.fn([ `Arity_1 of 'a24 ], unit)) => unit", "docs": "<p>Iterates over the contained value with the given function</p>\n<p>If <code>&#39;a Js.null_undefined</code> contains a value, that value is unwrapped and applied to the given function.</p>\n<pre class='ml'><code class='ml'>let maybeSay (maybeMessage: string Js.null_undefined) =\n  Js.Null_undefined.iter maybeMessage (fun message -&gt; Js.log message)</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a24 ], unit)"]]}, {"path": "Js_null_undefined", "name": "fromOption", "type": "let fromOption: option('a) => t('a)", "docs": "failed to parse: File &quot;&quot;, line 2, characters 0-2:\n&#39;{%&#39;: bad markup", "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js_null_undefined", "name": "from_opt", "type": "let from_opt: option('a) => t('a)", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js_null_undefined", "name": "toOption", "type": "let toOption: t('a) => option('a)", "docs": "failed to parse: File &quot;&quot;, line 2, characters 0-2:\n&#39;{%&#39;: bad markup", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_null_undefined", "name": "to_opt", "type": "let to_opt: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "", "name": "Js_null_undefined", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bind\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromOption\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_opt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>null\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOption\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_opt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>undefined\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_math", "name": "_E", "type": "let _E: float", "docs": "<p>Euler&#39;s number</p>\n", "kind": "value"}, {"path": "Js_math", "name": "_LN2", "type": "let _LN2: float", "docs": "<p>natural logarithm of 2</p>\n", "kind": "value"}, {"path": "Js_math", "name": "_LN10", "type": "let _LN10: float", "docs": "<p>natural logarithm of 10</p>\n", "kind": "value"}, {"path": "Js_math", "name": "_LOG2E", "type": "let _LOG2E: float", "docs": "<p>base 2 logarithm of E</p>\n", "kind": "value"}, {"path": "Js_math", "name": "_LOG10E", "type": "let _LOG10E: float", "docs": "<p>base 10 logarithm of E</p>\n", "kind": "value"}, {"path": "Js_math", "name": "_PI", "type": "let _PI: float", "docs": "<p>Pi... (ratio of the circumference and diameter of a circle)</p>\n", "kind": "value"}, {"path": "Js_math", "name": "_SQRT1_2", "type": "let _SQRT1_2: float", "docs": "<p>square root of 1/2</p>\n", "kind": "value"}, {"path": "Js_math", "name": "_SQRT2", "type": "let _SQRT2: float", "docs": "<p>square root of 2</p>\n", "kind": "value"}, {"path": "Js_math", "name": "abs_int", "type": "let abs_int: int => int", "docs": "<p>absolute value</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Js_math", "name": "abs_float", "type": "let abs_float: float => float", "docs": "<p>absolute value</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "acos", "type": "let acos: float => float", "docs": "<p>arccosine in radians, can return NaN</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "acosh", "type": "let acosh: float => float", "docs": "<p>hyperbolic arccosine in raidans, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "asin", "type": "let asin: float => float", "docs": "<p>arcsine in radians, can return NaN</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "asinh", "type": "let asinh: float => float", "docs": "<p>hyperbolic arcsine in raidans, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "atan", "type": "let atan: float => float", "docs": "<p>arctangent in radians</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "atanh", "type": "let atanh: float => float", "docs": "<p>hyperbolic arctangent in radians, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "atan2", "type": "let atan2: (~y: float, ~x: float, unit) => float", "docs": "<p>arctangent of the quotient of x and y, mostly... this one&#39;s a bit weird</p>\n", "kind": "value", "args": [["y", "float"], ["x", "float"], ["", "unit"]]}, {"path": "Js_math", "name": "cbrt", "type": "let cbrt: float => float", "docs": "<p>cube root, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "unsafe_ceil_int", "type": "let unsafe_ceil_int: float => int", "docs": "<p>may return values not representable by <code>int</code></p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "unsafe_ceil", "type": "let unsafe_ceil: float => int", "docs": "<p>smallest int greater than or equal to the argument</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "ceil_int", "type": "let ceil_int: float => int", "docs": "<p>smallest int greater than or equal to the argument</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "ceil", "type": "let ceil: float => int", "docs": "<p>smallest int greater than or equal to the argument</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "ceil_float", "type": "let ceil_float: float => float", "docs": "<p>smallest int greater than or equal to the argument</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "clz32", "type": "let clz32: int => int", "docs": "<p>number of leading zero bits of the argument&#39;s 32 bit int representation, ES2015</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Js_math", "name": "cos", "type": "let cos: float => float", "docs": "<p>cosine in radians</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "cosh", "type": "let cosh: float => float", "docs": "<p>hyperbolic cosine in radians, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "exp", "type": "let exp: float => float", "docs": "<p>natural exponentional</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "expm1", "type": "let expm1: float => float", "docs": "<p>natural exponential minus 1, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "unsafe_floor_int", "type": "let unsafe_floor_int: float => int", "docs": "<p>may return values not representable by <code>int</code></p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "unsafe_floor", "type": "let unsafe_floor: float => int", "docs": "<p>largest int greater than or equal to the arugment</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "floor_int", "type": "let floor_int: float => int", "docs": "<p>largest int greater than or equal to the arugment</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "floor", "type": "let floor: float => int", "docs": null, "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "floor_float", "type": "let floor_float: float => float", "docs": null, "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "fround", "type": "let fround: float => float", "docs": "<p>round to nearest single precision float, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "hypot", "type": "let hypot: (float, float) => float", "docs": "<p>pythagorean equation, ES2015</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Js_math", "name": "hypotMany", "type": "let hypotMany: array(float) => float", "docs": "<p>generalized pythagorean equation, ES2015</p>\n", "kind": "value", "args": [["", "array(float)"]]}, {"path": "Js_math", "name": "imul", "type": "let imul: (int, int) => int", "docs": "<p>32-bit integer multiplication, ES2015</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Js_math", "name": "log", "type": "let log: float => float", "docs": "<p>natural logarithm, can return NaN</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "log1p", "type": "let log1p: float => float", "docs": "<p>natural logarithm of 1 + the argument, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "log10", "type": "let log10: float => float", "docs": "<p>base 10 logarithm, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "log2", "type": "let log2: float => float", "docs": "<p>base 2 logarithm, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "max_int", "type": "let max_int: (int, int) => int", "docs": "<p>max value</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Js_math", "name": "maxMany_int", "type": "let maxMany_int: array(int) => int", "docs": "<p>max value</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "Js_math", "name": "max_float", "type": "let max_float: (float, float) => float", "docs": "<p>max value</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Js_math", "name": "maxMany_float", "type": "let maxMany_float: array(float) => float", "docs": "<p>max value</p>\n", "kind": "value", "args": [["", "array(float)"]]}, {"path": "Js_math", "name": "min_int", "type": "let min_int: (int, int) => int", "docs": "<p>min value</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Js_math", "name": "minMany_int", "type": "let minMany_int: array(int) => int", "docs": "<p>min value</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "Js_math", "name": "min_float", "type": "let min_float: (float, float) => float", "docs": "<p>min value</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Js_math", "name": "minMany_float", "type": "let minMany_float: array(float) => float", "docs": "<p>min value</p>\n", "kind": "value", "args": [["", "array(float)"]]}, {"path": "Js_math", "name": "pow_int", "type": "let pow_int: (~base: int, ~exp: int) => int", "docs": "<p>base to the power of the exponent</p>\n", "kind": "value", "args": [["base", "int"], ["exp", "int"]]}, {"path": "Js_math", "name": "pow_float", "type": "let pow_float: (~base: float, ~exp: float) => float", "docs": "<p>base to the power of the exponent</p>\n", "kind": "value", "args": [["base", "float"], ["exp", "float"]]}, {"path": "Js_math", "name": "random", "type": "let random: unit => float", "docs": "<p>random number in [min,max)</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js_math", "name": "random_int", "type": "let random_int: (int, int) => int", "docs": "<p>random number in [min,max)</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Js_math", "name": "unsafe_round", "type": "let unsafe_round: float => int", "docs": "<p>rounds to nearest integer</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "round", "type": "let round: float => float", "docs": "<p>rounds to nearest integer</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "sign_int", "type": "let sign_int: int => int", "docs": "<p>the sign of the argument, 1, -1, 0, -0 or NaN, ES2015</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Js_math", "name": "sign_float", "type": "let sign_float: float => float", "docs": "<p>the sign of the argument, 1, -1, 0, -0 or NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "sin", "type": "let sin: float => float", "docs": "<p>sine in radians</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "sinh", "type": "let sinh: float => float", "docs": "<p>hyperbolic sine in radians, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "sqrt", "type": "let sqrt: float => float", "docs": "<p>square root, can return NaN</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "tan", "type": "let tan: float => float", "docs": "<p>tangent in radians</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "tanh", "type": "let tanh: float => float", "docs": "<p>hyperbolic tangent in radians, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "unsafe_trunc", "type": "let unsafe_trunc: float => int", "docs": "<p>truncate, ie. remove fractional digits, returns a value not representable as <code>int</code> if NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_math", "name": "trunc", "type": "let trunc: float => float", "docs": "<p>truncate, ie. remove fractional digits, returns a value not representable as <code>int</code> if NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "", "name": "Js_math", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_E\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_LN10\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_LN2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_LOG10E\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_LOG2E\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_PI\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_SQRT1_2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_SQRT2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abs_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abs_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>acos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>acosh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>asin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>asinh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>atan\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>atan2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>atanh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cbrt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ceil\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ceil_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ceil_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clz32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cosh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>expm1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>floor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>floor_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>floor_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fround\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hypot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hypotMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>imul\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log10\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log1p\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxMany_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxMany_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minMany_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minMany_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pow_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pow_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>random\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>random_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>round\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sign_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sign_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sinh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sqrt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tan\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tanh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trunc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_ceil\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_ceil_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_floor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_floor_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_round\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_trunc", "docs": null, "kind": "module"}, {"path": "Js_mapperRt", "name": "binarySearch", "type": "let binarySearch: (int, int, array((int, 'a))) => 'a", "docs": "<p><code>serach polyvar assocArray</code> Search hashvariant of <code>polyvar</code> to get the returned string, assume that <code>polvar</code> exists in the array</p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "array((int, 'a))"]]}, {"path": "Js_mapperRt", "name": "revSearch", "type": "let revSearch: (int, array((int, string)), string) => option(int)", "docs": "<p><code>revSearch len assocArray value</code> Based on the value to find the associated key, i.e, polyvar</p>\n", "kind": "value", "args": [["", "int"], ["", "array((int, string))"], ["", "string"]]}, {"path": "Js_mapperRt", "name": "revSearchAssert", "type": "let revSearchAssert: (int, array((int, string)), string) => int", "docs": null, "kind": "value", "args": [["", "int"], ["", "array((int, string))"], ["", "string"]]}, {"path": "Js_mapperRt", "name": "toInt", "type": "let toInt: (int, array(int)) => int", "docs": "<p><code>toInt enum array</code> Based on the value of <code>enum</code>, return its mapped int</p>\n", "kind": "value", "args": [["", "int"], ["", "array(int)"]]}, {"path": "Js_mapperRt", "name": "fromInt", "type": "let fromInt: (int, array(int), int) => option(int)", "docs": "<p><code>fromInt len array int</code> return the mapped <code>enum</code></p>\n", "kind": "value", "args": [["", "int"], ["", "array(int)"], ["", "int"]]}, {"path": "Js_mapperRt", "name": "fromIntAssert", "type": "let fromIntAssert: (int, array(int), int) => int", "docs": null, "kind": "value", "args": [["", "int"], ["", "array(int)"], ["", "int"]]}, {"path": "", "name": "Js_mapperRt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromInt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromIntAssert\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>revSearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>revSearchAssert\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toInt", "docs": null, "kind": "module"}, {"path": "Js_list", "name": "t", "type": "type t('a) = list('a)", "docs": null, "kind": "type"}, {"path": "Js_list", "name": "length", "type": "let length: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_list", "name": "cons", "type": "let cons: ('a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_list", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_list", "name": "hd", "type": "let hd: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_list", "name": "tl", "type": "let tl: t('a) => option(t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_list", "name": "nth", "type": "let nth: (t('a), int) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Js_list", "name": "revAppend", "type": "let revAppend: (t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Js_list", "name": "rev", "type": "let rev: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_list", "name": "mapRev", "type": "let mapRev: (Js.Internal.fn([ `Arity_1 of 'a16 ], 'b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a16 ], 'b)"], ["", "t('a)"]]}, {"path": "Js_list", "name": "map", "type": "let map: (Js.Internal.fn([ `Arity_1 of 'a15 ], 'b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a15 ], 'b)"], ["", "t('a)"]]}, {"path": "Js_list", "name": "iter", "type": "let iter: (Js.Internal.fn([ `Arity_1 of 'a14 ], unit), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a14 ], unit)"], ["", "t('a)"]]}, {"path": "Js_list", "name": "iteri", "type": "let iteri: (Js.Internal.fn([ `Arity_2 of int * 'a13 ], unit), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of int * 'a13 ], unit)"], ["", "t('a)"]]}, {"path": "Js_list", "name": "foldLeft", "type": "let foldLeft: (Js.Internal.fn([ `Arity_2 of 'a12 * 'b3 ], 'a), 'a, list('b)) => 'a", "docs": "<p>Application order is left to right, tail recurisve</p>\n", "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a12 * 'b3 ], 'a)"], ["", "'a"], ["", "list('b)"]]}, {"path": "Js_list", "name": "foldRight", "type": "let foldRight: (Js.Internal.fn([ `Arity_2 of 'a11 * 'b2 ], 'b), list('a), 'b) => 'b", "docs": "<p>Application order is right to left tail-recursive.</p>\n", "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a11 * 'b2 ], 'b)"], ["", "list('a)"], ["", "'b"]]}, {"path": "Js_list", "name": "flatten", "type": "let flatten: t(t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t(t('a))"]]}, {"path": "Js_list", "name": "filter", "type": "let filter: (Js.Internal.fn([ `Arity_1 of 'a10 ], bool), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a10 ], bool)"], ["", "t('a)"]]}, {"path": "Js_list", "name": "filterMap", "type": "let filterMap: (Js.Internal.fn([ `Arity_1 of 'a9 ], option('b)), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a9 ], option('b))"], ["", "t('a)"]]}, {"path": "Js_list", "name": "countBy", "type": "let countBy: (Js.Internal.fn([ `Arity_1 of 'a8 ], bool), list('a)) => int", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a8 ], bool)"], ["", "list('a)"]]}, {"path": "Js_list", "name": "init", "type": "let init: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Js_list", "name": "toVector", "type": "let toVector: t('a) => Js_vector.t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_list", "name": "equal", "type": "let equal: (Js.Internal.fn([ `Arity_2 of 'a7 * 'a7 ], bool), list('a), list('a)) => bool", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a7 * 'a7 ], bool)"], ["", "list('a)"], ["", "list('a)"]]}, {"path": "", "name": "Js_list", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cons\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>countBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>equal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filterMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatten\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>foldLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>foldRight\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapRev\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>revAppend\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tl\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toVector\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_json", "name": "t", "type": "type t", "docs": "<p>The JSON data structure</p>\n", "kind": "type"}, {"path": "Js_json", "name": "kind", "type": "type kind('_) = \n  | String: kind(Js_string.t)\n  | Number: kind(float)\n  | Object: kind(Js_dict.t(t))\n  | Array: kind(array(t))\n  | Boolean: kind(Js.boolean)\n  | Null: kind(Js_types.null_val)\n", "docs": "<p>Underlying type of a JSON value</p>\n", "kind": "type"}, {"path": "Js_json", "name": "tagged_t", "type": "type tagged_t = \n  | JSONFalse\n  | JSONTrue\n  | JSONNull\n  | JSONString(string)\n  | JSONNumber(float)\n  | JSONObject(Js_dict.t(t))\n  | JSONArray(array(t))\n", "docs": null, "kind": "type"}, {"path": "Js_json", "name": "classify", "type": "let classify: t => tagged_t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_json", "name": "test", "type": "let test: ('a, kind('b)) => bool", "docs": "<p><code>test v kind</code> returns true if <code>v</code> is of <code>kind</code></p>\n", "kind": "value", "args": [["", "'a"], ["", "kind('b)"]]}, {"path": "Js_json", "name": "decodeString", "type": "let decodeString: t => option(Js_string.t)", "docs": "<p><code>decodeString json</code> returns <code>Some s</code> if <code>json</code> is a string, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_json", "name": "decodeNumber", "type": "let decodeNumber: t => option(float)", "docs": "<p><code>decodeNumber json</code> returns <code>Some n</code> if <code>json</code> is a number, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_json", "name": "decodeObject", "type": "let decodeObject: t => option(Js_dict.t(t))", "docs": "<p><code>decodeObject json</code> returns <code>Some o</code> if <code>json</code> is an object, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_json", "name": "decodeArray", "type": "let decodeArray: t => option(array(t))", "docs": "<p><code>decodeArray json</code> returns <code>Some a</code> if <code>json</code> is an array, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_json", "name": "decodeBoolean", "type": "let decodeBoolean: t => option(Js.boolean)", "docs": "<p><code>decodeBoolean json</code> returns <code>Some b</code> if <code>json</code> is a boolean, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_json", "name": "decodeNull", "type": "let decodeNull: t => option(Js_null.t('a))", "docs": "<p><code>decodeNull json</code> returns <code>Some null</code> if <code>json</code> is a null, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_json", "name": "null", "type": "let null: t", "docs": "<p><code>null</code> is the singleton null JSON value</p>\n", "kind": "value"}, {"path": "Js_json", "name": "string", "type": "let string: string => t", "docs": "<p><code>string s</code> makes a JSON string of the <code>string</code> <code>s</code></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js_json", "name": "number", "type": "let number: float => t", "docs": "<p><code>number n</code> makes a JSON number of the <code>float</code> <code>n</code></p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js_json", "name": "boolean", "type": "let boolean: Js.boolean => t", "docs": "<p><code>boolean b</code> makes a JSON boolean of the <code>Js.boolean</code> <code>b</code></p>\n", "kind": "value", "args": [["", "Js.boolean"]]}, {"path": "Js_json", "name": "object_", "type": "let object_: Js_dict.t(t) => t", "docs": "<p><code>object_ dict</code> makes a JSON objet of the <code>Js.Dict.t</code> <code>dict</code></p>\n", "kind": "value", "args": [["", "Js_dict.t(t)"]]}, {"path": "Js_json", "name": "array", "type": "let array: array(t) => t", "docs": "<p><code>array_ a</code> makes a JSON array of the <code>Js.Json.t array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(t)"]]}, {"path": "Js_json", "name": "stringArray", "type": "let stringArray: array(string) => t", "docs": "<p><code>stringArray a</code> makes a JSON array of the <code>string array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(string)"]]}, {"path": "Js_json", "name": "numberArray", "type": "let numberArray: array(float) => t", "docs": "<p><code>numberArray a</code> makes a JSON array of the <code>float array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(float)"]]}, {"path": "Js_json", "name": "booleanArray", "type": "let booleanArray: array(Js.boolean) => t", "docs": "<p><code>booleanArray</code> makes a JSON array of the <code>Js.boolean array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(Js.boolean)"]]}, {"path": "Js_json", "name": "objectArray", "type": "let objectArray: array(Js_dict.t(t)) => t", "docs": "<p><code>objectArray a</code> makes a JSON array of the <code>JsDict.t array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(Js_dict.t(t))"]]}, {"path": "Js_json", "name": "parseExn", "type": "let parseExn: string => t", "docs": "<p><code>parseExn s</code> parses the string <code>s</code> into a JSON data structure</p>\n<p><strong>Returns</strong> a JSON data structure</p>\n<p>Raises: SyntaxError<p>if given string is not a valid JSON. Note <code>SyntaxError</code> is a JavaScript exception.</p>\n<pre class='ml'><code class='ml'>(* parse a simple JSON string *)\n\nlet json =\n  try\n    Js.Json.parseExn {| &quot;foo&quot; |}\n  with\n  | _ -&gt; failwith &quot;Error parsing JSON string&quot;\nin\nmatch Js.Json.classify json with\n| Js.Json.JSONString value -&gt; Js.log value\n| _ -&gt; failwith &quot;Expected a string&quot;</code></pre><pre class='ml'><code class='ml'>(* parse a complex JSON string *)\n\nlet getIds s =\n  let json =\n    try\n      Js.Json.parseExn s\n    with\n    | _ -&gt; failwith &quot;Error parsing JSON string&quot;\n  in\n  match Js.Json.classify json with\n  | Js.Json.JSONObject value -&gt;\n    (* In this branch, compiler infer value : Js.Json.t Js.Dict.t *)\n    begin match Js.Dict.get value &quot;ids&quot; with\n    | Some ids -&gt;\n      begin match Js.Json.classify ids with\n      | Js.Json.JSONArray ids -&gt;\n        (* In this branch compiler infer ids : Js.Json.t array *)\n        ids\n      | _ -&gt; failwith &quot;Expected an array&quot;\n      end\n    | None -&gt; failwith &quot;Expected an `ids` property&quot;\n    end\n  | _ -&gt; failwith &quot;Expected an object&quot;\n\n(* prints `1, 2, 3` *)\nlet _ =\n  Js.log \\@\\@ getIds {| { &quot;ids&quot; : [1, 2, 3 ] } |}</code></pre></p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js_json", "name": "stringify", "type": "let stringify: t => string", "docs": "failed to parse: File &quot;&quot;, line 2, characters 7-8:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "t"]]}, {"path": "Js_json", "name": "stringifyAny", "type": "let stringifyAny: 'a => option(string)", "docs": "failed to parse: File &quot;&quot;, line 7, characters 103-103:\nend of text is not allowed in &#39;{[...]}&#39; (code block)", "kind": "value", "args": [["", "'a"]]}, {"path": "", "name": "Js_json", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>array\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>boolean\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>booleanArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>classify\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeBoolean\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeNull\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeNumber\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeObject\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>null\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>number\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>numberArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>objectArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>object_\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parseExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stringArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stringify\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stringifyAny\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>kind\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>tagged_t", "docs": null, "kind": "module"}, {"path": "Js_global", "name": "intervalId", "type": "type intervalId", "docs": "<p>Identify an interval started by setInterval</p>\n", "kind": "type"}, {"path": "Js_global", "name": "timeoutId", "type": "type timeoutId", "docs": "<p>Identify timeout started by setTimeout</p>\n", "kind": "type"}, {"path": "Js_global", "name": "clearInterval", "type": "let clearInterval: intervalId => unit", "docs": "<p>Clear an interval started by setInterval</p>\n<pre class='ml'><code class='ml'>(* API for a somewhat aggressive snoozing alarm clock *)\n\nlet interval = ref Js.Nullable.null\n\nlet remind () =\n  Js.log &quot;Wake Up!&quot;;\n  IO.punchSleepyGuy ()\n  \nlet snooze mins =\n  interval := Js.Nullable.return (Js.Global.setInterval remind (mins * 60 * 1000))\n  \nlet cancel () =\n  Js.Nullable.iter !interval (fun[\\@bs] intervalId -&gt; Js.Global.clearInterval intervalId)</code></pre><p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearInterval'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "intervalId"]]}, {"path": "Js_global", "name": "clearTimeout", "type": "let clearTimeout: timeoutId => unit", "docs": "<p>Clear a timeout started by setTimeout</p>\n<pre class='ml'><code class='ml'>(* A simple model of a code monkey&#39;s brain *)\n\nlet timer = ref Js.Nullable.null\n\nlet work () =\n  IO.closeHackerNewsTab ()\n\nlet procrastinate mins =\n  Js.Nullable.iter !timer (fun[\\@bs] timer -&gt; Js.Global.clearTimeout timer);\n  timer := Js.Nullable.return (Js.Global.setTimeout work (mins * 60 * 1000))</code></pre><p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "timeoutId"]]}, {"path": "Js_global", "name": "setInterval", "type": "let setInterval: (unit => unit, int) => intervalId", "docs": "failed to parse: File &quot;&quot;, line 2, characters 6-7:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "unit => unit"], ["", "int"]]}, {"path": "Js_global", "name": "setTimeout", "type": "let setTimeout: (unit => unit, int) => timeoutId", "docs": "failed to parse: File &quot;&quot;, line 2, characters 7-8:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "unit => unit"], ["", "int"]]}, {"path": "Js_global", "name": "encodeURI", "type": "let encodeURI: string => string", "docs": "<p>URL-encodes a string.</p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js_global", "name": "decodeURI", "type": "let decodeURI: string => string", "docs": "<p>Decodes a URL-enmcoded string produced by <code>encodeURI</code></p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js_global", "name": "encodeURIComponent", "type": "let encodeURIComponent: string => string", "docs": "<p>URL-encodes a string, including characters with special meaning in a URI.</p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js_global", "name": "decodeURIComponent", "type": "let decodeURIComponent: string => string", "docs": "<p>Decodes a URL-enmcoded string produced by <code>encodeURIComponent</code></p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "Js_global", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clearInterval\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clearTimeout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeURI\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeURIComponent\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>encodeURI\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>encodeURIComponent\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setInterval\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setTimeout\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>intervalId\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>timeoutId", "docs": null, "kind": "module"}, {"path": "Js_dict", "name": "t", "type": "type t('a)", "docs": "<p>Dictionary type (ie an &#39;{ }&#39; JS object). However it is restricted to hold a single type; therefore values must have the same type.</p>\n<p>This Dictionary type is mostly used with the <code>Js_json.t</code> type.</p>\n", "kind": "type"}, {"path": "Js_dict", "name": "key", "type": "type key = string", "docs": "<p>Key type</p>\n", "kind": "type"}, {"path": "Js_dict", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": "<p><code>get dict key</code> returns <code>None</code> if the <code>key</code> is not found in the dictionary, <code>Some value</code> otherwise</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Js_dict", "name": "unsafeGet", "type": "let unsafeGet: (t('a), key) => 'a", "docs": "<p><code>unsafeGet dict key</code> return the value if the <code>key</code> exists, otherwise an <strong>undefined</strong> value is returned. Must be used only when the existence of a key is certain. (i.e. when having called <code>keys</code> function previously.</p>\n<pre class='ml'><code class='ml'>Array.iter (fun key -&gt; Js.log (Js_dict.unsafeGet dic key)) (Js_dict.keys dict) </code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Js_dict", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>set dict key value</code> sets the <code>key</code>/<code>value</code> in <code>dict</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Js_dict", "name": "keys", "type": "let keys: t('a) => array(string)", "docs": "<p><code>keys dict</code> returns all the keys in the dictionary <code>dict</code></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_dict", "name": "empty", "type": "let empty: unit => t('a)", "docs": "<p><code>empty ()</code> returns an empty dictionary</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js_dict", "name": "unsafeDeleteKey", "type": "let unsafeDeleteKey: Js.Internal.fn([ `Arity_2 of string t * string ], unit)", "docs": "<p>Experimental internal funciton</p>\n", "kind": "value"}, {"path": "Js_dict", "name": "entries", "type": "let entries: t('a) => array((key, 'a))", "docs": "<p><code>entries dict</code> returns the key value pairs in <code>dict</code> (ES2017)</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_dict", "name": "values", "type": "let values: t('a) => array('a)", "docs": "<p><code>entries dict</code> returns the values in <code>dict</code> (ES2017)</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_dict", "name": "fromList", "type": "let fromList: list((key, 'a)) => t('a)", "docs": "<p><code>fromList entries</code> creates a new dictionary containing each <code>(key, value)</code> pair in <code>entries</code></p>\n", "kind": "value", "args": [["", "list((key, 'a))"]]}, {"path": "Js_dict", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": "<p><code>fromArray entries</code> creates a new dictionary containing each <code>(key, value)</code> pair in <code>entries</code></p>\n", "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Js_dict", "name": "map", "type": "let map: (Js.Internal.fn([ `Arity_1 of 'a22 ], 'b), t('a)) => t('b)", "docs": "<p><code>map f dict</code> maps <code>dict</code> to a new dictionary with the same keys, using <code>f</code> to map each value</p>\n", "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a22 ], 'b)"], ["", "t('a)"]]}, {"path": "", "name": "Js_dict", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>entries\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keys\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeDeleteKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeGet\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>values\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_date", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Js_date", "name": "valueOf", "type": "let valueOf: t => float", "docs": "<p>returns the primitive value of this date, equivalent to getTime</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "make", "type": "let make: unit => t", "docs": "<p>returns a date representing the current time</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js_date", "name": "fromFloat", "type": "let fromFloat: float => t", "docs": null, "kind": "value", "args": [["", "float"]]}, {"path": "Js_date", "name": "fromString", "type": "let fromString: string => t", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Js_date", "name": "makeWithYM", "type": "let makeWithYM: (~year: float, ~month: float, unit) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "makeWithYMD", "type": "let makeWithYMD: (~year: float, ~month: float, ~date: float, unit) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "makeWithYMDH", "type": "let makeWithYMDH: (~year: float, ~month: float, ~date: float, ~hours: float, unit) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "makeWithYMDHM", "type": "let makeWithYMDHM: (\n  ~year: float,\n  ~month: float,\n  ~date: float,\n  ~hours: float,\n  ~minutes: float,\n  unit\n) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["minutes", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "makeWithYMDHMS", "type": "let makeWithYMDHMS: (\n  ~year: float,\n  ~month: float,\n  ~date: float,\n  ~hours: float,\n  ~minutes: float,\n  ~seconds: float,\n  unit\n) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "utcWithYM", "type": "let utcWithYM: (~year: float, ~month: float, unit) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "utcWithYMD", "type": "let utcWithYMD: (~year: float, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "utcWithYMDH", "type": "let utcWithYMDH: (~year: float, ~month: float, ~date: float, ~hours: float, unit) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "utcWithYMDHM", "type": "let utcWithYMDHM: (\n  ~year: float,\n  ~month: float,\n  ~date: float,\n  ~hours: float,\n  ~minutes: float,\n  unit\n) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["minutes", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "utcWithYMDHMS", "type": "let utcWithYMDHMS: (\n  ~year: float,\n  ~month: float,\n  ~date: float,\n  ~hours: float,\n  ~minutes: float,\n  ~seconds: float,\n  unit\n) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "now", "type": "let now: unit => float", "docs": "<p>returns the number of milliseconds since Unix epoch</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js_date", "name": "parse", "type": "let parse: string => t", "docs": "<p>returns NaN if passed invalid date string</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js_date", "name": "getDate", "type": "let getDate: t => float", "docs": "<p>return the day of the month (1-31)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getDay", "type": "let getDay: t => float", "docs": "<p>returns the day of the week (0-6)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getFullYear", "type": "let getFullYear: t => float", "docs": "<p>returns the day of the week (0-6)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getHours", "type": "let getHours: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getMilliseconds", "type": "let getMilliseconds: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getMinutes", "type": "let getMinutes: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getMonth", "type": "let getMonth: t => float", "docs": "<p>returns the month (0-11)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getSeconds", "type": "let getSeconds: t => float", "docs": "<p>returns the month (0-11)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getTime", "type": "let getTime: t => float", "docs": "<p>returns the number of milliseconds since Unix epoch</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getTimezoneOffset", "type": "let getTimezoneOffset: t => float", "docs": "<p>returns the number of milliseconds since Unix epoch</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getUTCDate", "type": "let getUTCDate: t => float", "docs": "<p>return the day of the month (1-31)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getUTCDay", "type": "let getUTCDay: t => float", "docs": "<p>returns the day of the week (0-6)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getUTCFullYear", "type": "let getUTCFullYear: t => float", "docs": "<p>returns the day of the week (0-6)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getUTCHours", "type": "let getUTCHours: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getUTCMilliseconds", "type": "let getUTCMilliseconds: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getUTCMinutes", "type": "let getUTCMinutes: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getUTCMonth", "type": "let getUTCMonth: t => float", "docs": "<p>returns the month (0-11)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getUTCSeconds", "type": "let getUTCSeconds: t => float", "docs": "<p>returns the month (0-11)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "getYear", "type": "let getYear: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "setDate", "type": "let setDate: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setFullYear", "type": "let setFullYear: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setFullYearM", "type": "let setFullYearM: (t, ~year: float, ~month: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["year", "float"], ["month", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setFullYearMD", "type": "let setFullYearMD: (t, ~year: float, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["year", "float"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setHours", "type": "let setHours: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setHoursM", "type": "let setHoursM: (t, ~hours: float, ~minutes: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setHoursMS", "type": "let setHoursMS: (t, ~hours: float, ~minutes: float, ~seconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setHoursMSMs", "type": "let setHoursMSMs: (\n  t,\n  ~hours: float,\n  ~minutes: float,\n  ~seconds: float,\n  ~milliseconds: float,\n  unit\n) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setMilliseconds", "type": "let setMilliseconds: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setMinutes", "type": "let setMinutes: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setMinutesS", "type": "let setMinutesS: (t, ~minutes: float, ~seconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setMinutesSMs", "type": "let setMinutesSMs: (t, ~minutes: float, ~seconds: float, ~milliseconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["minutes", "float"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setMonth", "type": "let setMonth: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setMonthD", "type": "let setMonthD: (t, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setSeconds", "type": "let setSeconds: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setSecondsMs", "type": "let setSecondsMs: (t, ~seconds: float, ~milliseconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setTime", "type": "let setTime: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setUTCDate", "type": "let setUTCDate: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setUTCFullYear", "type": "let setUTCFullYear: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setUTCFullYearM", "type": "let setUTCFullYearM: (t, ~year: float, ~month: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["year", "float"], ["month", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setUTCFullYearMD", "type": "let setUTCFullYearMD: (t, ~year: float, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["year", "float"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setUTCHours", "type": "let setUTCHours: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setUTCHoursM", "type": "let setUTCHoursM: (t, ~hours: float, ~minutes: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setUTCHoursMS", "type": "let setUTCHoursMS: (t, ~hours: float, ~minutes: float, ~seconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setUTCHoursMSMs", "type": "let setUTCHoursMSMs: (\n  t,\n  ~hours: float,\n  ~minutes: float,\n  ~seconds: float,\n  ~milliseconds: float,\n  unit\n) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setUTCMilliseconds", "type": "let setUTCMilliseconds: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setUTCMinutes", "type": "let setUTCMinutes: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setUTCMinutesS", "type": "let setUTCMinutesS: (t, ~minutes: float, ~seconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setUTCMinutesSMs", "type": "let setUTCMinutesSMs: (t, ~minutes: float, ~seconds: float, ~milliseconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["minutes", "float"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setUTCMonth", "type": "let setUTCMonth: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setUTCMonthD", "type": "let setUTCMonthD: (t, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setUTCSeconds", "type": "let setUTCSeconds: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setUTCSecondsMs", "type": "let setUTCSecondsMs: (t, ~seconds: float, ~milliseconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js_date", "name": "setUTCTime", "type": "let setUTCTime: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "setYear", "type": "let setYear: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js_date", "name": "toDateString", "type": "let toDateString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "toGMTString", "type": "let toGMTString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "toISOString", "type": "let toISOString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "toJSON", "type": "let toJSON: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "toLocaleDateString", "type": "let toLocaleDateString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "toLocaleString", "type": "let toLocaleString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "toLocaleTimeString", "type": "let toLocaleTimeString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "toString", "type": "let toString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "toTimeString", "type": "let toTimeString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js_date", "name": "toUTCString", "type": "let toUTCString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "", "name": "Js_date", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromFloat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getDate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getDay\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getFullYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getHours\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getMilliseconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getMinutes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getMonth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getSeconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getTime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getTimezoneOffset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCDate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCDay\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCFullYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCHours\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCMilliseconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCMinutes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCMonth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCSeconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYMD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYMDH\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYMDHM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYMDHMS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>now\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setDate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setFullYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setFullYearM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setFullYearMD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setHours\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setHoursM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setHoursMS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setHoursMSMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMilliseconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMinutes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMinutesS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMinutesSMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMonth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMonthD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setSeconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setSecondsMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setTime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCDate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCFullYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCFullYearM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCFullYearMD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCHours\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCHoursM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCHoursMS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCHoursMSMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMilliseconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMinutes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMinutesS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMinutesSMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMonth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMonthD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCSeconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCSecondsMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCTime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toDateString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toGMTString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toISOString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toJSON\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleDateString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleTimeString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toTimeString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toUTCString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYMD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYMDH\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYMDHM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYMDHMS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valueOf\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js_console", "name": "log", "type": "let log: 'a => unit", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js_console", "name": "warn", "type": "let warn: 'a => unit", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js_console", "name": "timeStart", "type": "let timeStart: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Js_console", "name": "timeEnd", "type": "let timeEnd: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "Js_console", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>timeEnd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>timeStart\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>warn", "docs": null, "kind": "module"}, {"path": "Js_cast", "name": "intOfBool", "type": "let intOfBool: bool => int", "docs": "<p><code>intOfBool b</code> returns <code>1</code> for when <code>b</code> is <code>true</code> and <code>0</code> when <code>b</code> is <code>false</code></p>\n", "kind": "value", "args": [["", "bool"]]}, {"path": "Js_cast", "name": "floatOfInt", "type": "let floatOfInt: int => float", "docs": "<p><code>floatOfInt i</code> returns the float value of <code>i</code></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "", "name": "Js_cast", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>floatOfInt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intOfBool", "docs": null, "kind": "module"}, {"path": "Js_boolean", "name": "to_js_boolean", "type": "let to_js_boolean: bool => Js.boolean", "docs": null, "kind": "value", "args": [["", "bool"]]}, {"path": "", "name": "Js_boolean", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_js_boolean", "docs": null, "kind": "module"}, {"path": "Js_array", "name": "t", "type": "type t('a) = array('a)", "docs": null, "kind": "type"}, {"path": "Js_array", "name": "array_like", "type": "type array_like('a)", "docs": null, "kind": "type"}, {"path": "Js_array", "name": "from", "type": "let from: array_like('a) => array('b)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "array_like('a)"]]}, {"path": "Js_array", "name": "fromMap", "type": "let fromMap: (array_like('a), 'a => 'b) => array('b)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "array_like('a)"], ["", "'a => 'b"]]}, {"path": "Js_array", "name": "isArray", "type": "let isArray: 'a => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Js_array", "name": "length", "type": "let length: array('a) => int", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Js_array", "name": "copyWithin", "type": "let copyWithin: (~to_: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["to_", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "copyWithinFrom", "type": "let copyWithinFrom: (~to_: int, ~from: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["to_", "int"], ["from", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "copyWithinFromRange", "type": "let copyWithinFromRange: (~to_: int, ~start: int, ~end_: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["to_", "int"], ["start", "int"], ["end_", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "fillInPlace", "type": "let fillInPlace: ('a, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_array", "name": "fillFromInPlace", "type": "let fillFromInPlace: ('a, ~from: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a"], ["from", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "fillRangeInPlace", "type": "let fillRangeInPlace: ('a, ~start: int, ~end_: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a"], ["start", "int"], ["end_", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "pop", "type": "let pop: t('a) => option('a)", "docs": "<p>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_array", "name": "push", "type": "let push: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_array", "name": "pushMany", "type": "let pushMany: (array('a), t('a)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "t('a)"]]}, {"path": "Js_array", "name": "reverseInPlace", "type": "let reverseInPlace: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_array", "name": "shift", "type": "let shift: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_array", "name": "sortInPlace", "type": "let sortInPlace: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_array", "name": "sortInPlaceWith", "type": "let sortInPlaceWith: (('a, 'a) => int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "('a, 'a) => int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "spliceInPlace", "type": "let spliceInPlace: (~pos: int, ~remove: int, ~add: array('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["pos", "int"], ["remove", "int"], ["add", "array('a)"], ["", "t('a)"]]}, {"path": "Js_array", "name": "removeFromInPlace", "type": "let removeFromInPlace: (~pos: int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["pos", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "removeCountInPlace", "type": "let removeCountInPlace: (~pos: int, ~count: int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["pos", "int"], ["count", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "unshift", "type": "let unshift: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_array", "name": "unshiftMany", "type": "let unshiftMany: (array('a), t('a)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "t('a)"]]}, {"path": "Js_array", "name": "append", "type": "let append: ('a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_array", "name": "concat", "type": "let concat: (t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Js_array", "name": "concatMany", "type": "let concatMany: (array(t('a)), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array(t('a))"], ["", "t('a)"]]}, {"path": "Js_array", "name": "includes", "type": "let includes: ('a, t('a)) => bool", "docs": "<p>ES2016</p>\n", "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_array", "name": "indexOf", "type": "let indexOf: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_array", "name": "indexOfFrom", "type": "let indexOfFrom: ('a, ~from: int, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["from", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "join", "type": "let join: t('a) => string", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_array", "name": "joinWith", "type": "let joinWith: (string, t('a)) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "t('a)"]]}, {"path": "Js_array", "name": "lastIndexOf", "type": "let lastIndexOf: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_array", "name": "lastIndexOfFrom", "type": "let lastIndexOfFrom: ('a, ~from: int, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["from", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "lastIndexOf_start", "type": "let lastIndexOf_start: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js_array", "name": "slice", "type": "let slice: (~start: int, ~end_: int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["start", "int"], ["end_", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_array", "name": "slice_copy", "type": "let slice_copy: (unit, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "unit"], ["", "t('a)"]]}, {"path": "Js_array", "name": "sliceFrom", "type": "let sliceFrom: (int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "slice_start", "type": "let slice_start: (int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "t('a)"]]}, {"path": "Js_array", "name": "toString", "type": "let toString: t('a) => string", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_array", "name": "toLocaleString", "type": "let toLocaleString: t('a) => string", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js_array", "name": "every", "type": "let every: ('a => bool, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js_array", "name": "everyi", "type": "let everyi: (('a, int) => bool, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "Js_array", "name": "filter", "type": "let filter: ('a => bool, t('a)) => t('a)", "docs": "<p>should we use <code>bool</code> or <code>boolan</code> seems they are intechangeable here</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js_array", "name": "filteri", "type": "let filteri: (('a, int) => bool, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "Js_array", "name": "find", "type": "let find: ('a => bool, t('a)) => option('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js_array", "name": "findi", "type": "let findi: (('a, int) => bool, t('a)) => option('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "Js_array", "name": "findIndex", "type": "let findIndex: ('a => bool, t('a)) => int", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js_array", "name": "findIndexi", "type": "let findIndexi: (('a, int) => bool, t('a)) => int", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "Js_array", "name": "forEach", "type": "let forEach: ('a => unit, t('a)) => unit", "docs": null, "kind": "value", "args": [["", "'a => unit"], ["", "t('a)"]]}, {"path": "Js_array", "name": "forEachi", "type": "let forEachi: (('a, int) => unit, t('a)) => unit", "docs": null, "kind": "value", "args": [["", "('a, int) => unit"], ["", "t('a)"]]}, {"path": "Js_array", "name": "map", "type": "let map: ('a => 'b, t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "'a => 'b"], ["", "t('a)"]]}, {"path": "Js_array", "name": "mapi", "type": "let mapi: (('a, int) => 'b, t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "('a, int) => 'b"], ["", "t('a)"]]}, {"path": "Js_array", "name": "reduce", "type": "let reduce: (('b, 'a) => 'b, 'b, t('a)) => 'b", "docs": null, "kind": "value", "args": [["", "('b, 'a) => 'b"], ["", "'b"], ["", "t('a)"]]}, {"path": "Js_array", "name": "reducei", "type": "let reducei: (('b, 'a, int) => 'b, 'b, t('a)) => 'b", "docs": null, "kind": "value", "args": [["", "('b, 'a, int) => 'b"], ["", "'b"], ["", "t('a)"]]}, {"path": "Js_array", "name": "reduceRight", "type": "let reduceRight: (('b, 'a) => 'b, 'b, t('a)) => 'b", "docs": null, "kind": "value", "args": [["", "('b, 'a) => 'b"], ["", "'b"], ["", "t('a)"]]}, {"path": "Js_array", "name": "reduceRighti", "type": "let reduceRighti: (('b, 'a, int) => 'b, 'b, t('a)) => 'b", "docs": null, "kind": "value", "args": [["", "('b, 'a, int) => 'b"], ["", "'b"], ["", "t('a)"]]}, {"path": "Js_array", "name": "some", "type": "let some: ('a => bool, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js_array", "name": "somei", "type": "let somei: (('a, int) => bool, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "", "name": "Js_array", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copyWithin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copyWithinFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copyWithinFromRange\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillFromInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillRangeInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>findIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>findIndexi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>findi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>includes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>indexOf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>indexOfFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>join\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>joinWith\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOfFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOf_start\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>push\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pushMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceRight\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceRighti\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reducei\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCountInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeFromInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sliceFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_start\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>somei\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sortInPlaceWith\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>spliceInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unshift\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unshiftMany\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>array_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Dom_storage", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Dom_storage", "name": "getItem", "type": "let getItem: (string, t) => option(string)", "docs": null, "kind": "value", "args": [["", "string"], ["", "t"]]}, {"path": "Dom_storage", "name": "setItem", "type": "let setItem: (string, string, t) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"], ["", "t"]]}, {"path": "Dom_storage", "name": "removeItem", "type": "let removeItem: (string, t) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "t"]]}, {"path": "Dom_storage", "name": "clear", "type": "let clear: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Dom_storage", "name": "key", "type": "let key: (int, t) => option(string)", "docs": null, "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Dom_storage", "name": "length", "type": "let length: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Dom_storage", "name": "localStorage", "type": "let localStorage: t", "docs": null, "kind": "value"}, {"path": "Dom_storage", "name": "sessionStorage", "type": "let sessionStorage: t", "docs": null, "kind": "value"}, {"path": "", "name": "Dom_storage", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getItem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>key\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>localStorage\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeItem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sessionStorage\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setItem\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Dom", "name": "_baseClass", "type": "type _baseClass", "docs": null, "kind": "type"}, {"path": "Dom", "name": "animation", "type": "type animation", "docs": null, "kind": "type"}, {"path": "Dom", "name": "cssStyleDeclaration", "type": "type cssStyleDeclaration", "docs": null, "kind": "type"}, {"path": "Dom", "name": "cssStyleSheet", "type": "type cssStyleSheet", "docs": null, "kind": "type"}, {"path": "Dom", "name": "eventTarget_like", "type": "type eventTarget_like('a)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "eventTarget", "type": "type eventTarget = eventTarget_like(_baseClass)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_node", "type": "type _node('a)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "node_like", "type": "type node_like('a) = eventTarget_like(_node('a))", "docs": null, "kind": "type"}, {"path": "Dom", "name": "node", "type": "type node = node_like(_baseClass)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_attr", "type": "type _attr", "docs": null, "kind": "type"}, {"path": "Dom", "name": "attr", "type": "type attr = node_like(_attr)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_characterData", "type": "type _characterData('a)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "characterData_like", "type": "type characterData_like('a) = node_like(_characterData('a))", "docs": null, "kind": "type"}, {"path": "Dom", "name": "characterData", "type": "type characterData = characterData_like(_baseClass)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_cdataSection", "type": "type _cdataSection", "docs": null, "kind": "type"}, {"path": "Dom", "name": "cdataSection", "type": "type cdataSection = characterData_like(_cdataSection)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_comment", "type": "type _comment", "docs": null, "kind": "type"}, {"path": "Dom", "name": "comment", "type": "type comment = characterData_like(_comment)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_document", "type": "type _document('a)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "document_like", "type": "type document_like('a) = node_like(_document('a))", "docs": null, "kind": "type"}, {"path": "Dom", "name": "document", "type": "type document = document_like(_baseClass)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_documentFragment", "type": "type _documentFragment", "docs": null, "kind": "type"}, {"path": "Dom", "name": "documentFragment", "type": "type documentFragment = node_like(_documentFragment)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_documentType", "type": "type _documentType", "docs": null, "kind": "type"}, {"path": "Dom", "name": "documentType", "type": "type documentType = node_like(_documentType)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "domImplementation", "type": "type domImplementation", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_element", "type": "type _element('a)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "element_like", "type": "type element_like('a) = node_like(_element('a))", "docs": null, "kind": "type"}, {"path": "Dom", "name": "element", "type": "type element = element_like(_baseClass)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "htmlCollection", "type": "type htmlCollection", "docs": null, "kind": "type"}, {"path": "Dom", "name": "mutationObserver", "type": "type mutationObserver", "docs": null, "kind": "type"}, {"path": "Dom", "name": "mutationRecord", "type": "type mutationRecord", "docs": null, "kind": "type"}, {"path": "Dom", "name": "namedNodeMap", "type": "type namedNodeMap", "docs": null, "kind": "type"}, {"path": "Dom", "name": "nodeList", "type": "type nodeList", "docs": null, "kind": "type"}, {"path": "Dom", "name": "processingInstruction", "type": "type processingInstruction", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_shadowRoot", "type": "type _shadowRoot", "docs": null, "kind": "type"}, {"path": "Dom", "name": "shadowRoot", "type": "type shadowRoot = node_like(_shadowRoot)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_text", "type": "type _text", "docs": null, "kind": "type"}, {"path": "Dom", "name": "text", "type": "type text = characterData_like(_text)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "domRect", "type": "type domRect", "docs": null, "kind": "type"}, {"path": "Dom", "name": "dataTransfer", "type": "type dataTransfer", "docs": null, "kind": "type"}, {"path": "Dom", "name": "domStringMap", "type": "type domStringMap", "docs": null, "kind": "type"}, {"path": "Dom", "name": "history", "type": "type history", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_htmlDocument", "type": "type _htmlDocument", "docs": null, "kind": "type"}, {"path": "Dom", "name": "htmlDocument", "type": "type htmlDocument = document_like(_htmlDocument)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_htmlElement", "type": "type _htmlElement('a)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "htmlElement_like", "type": "type htmlElement_like('a) = element_like(_htmlElement('a))", "docs": null, "kind": "type"}, {"path": "Dom", "name": "htmlElement", "type": "type htmlElement = htmlElement_like(_baseClass)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_htmlSlotElement", "type": "type _htmlSlotElement", "docs": null, "kind": "type"}, {"path": "Dom", "name": "htmlSlotElement", "type": "type htmlSlotElement = htmlElement_like(_htmlSlotElement)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "location", "type": "type location", "docs": null, "kind": "type"}, {"path": "Dom", "name": "window", "type": "type window", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_xmlDocument", "type": "type _xmlDocument", "docs": null, "kind": "type"}, {"path": "Dom", "name": "xmlDocument", "type": "type xmlDocument = document_like(_xmlDocument)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "event_like", "type": "type event_like('a)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "event", "type": "type event = event_like(_baseClass)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_uiEvent", "type": "type _uiEvent('a)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "uiEvent_like", "type": "type uiEvent_like('a) = event_like(_uiEvent('a))", "docs": null, "kind": "type"}, {"path": "Dom", "name": "uiEvent", "type": "type uiEvent = uiEvent_like(_baseClass)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_animationEvent", "type": "type _animationEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "animationEvent", "type": "type animationEvent = event_like(_animationEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_beforeUnloadEvent", "type": "type _beforeUnloadEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "beforeUnloadEvent", "type": "type beforeUnloadEvent = event_like(_beforeUnloadEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_clipboardEvent", "type": "type _clipboardEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "clipboardEvent", "type": "type clipboardEvent = event_like(_clipboardEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_closeEvent", "type": "type _closeEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "closeEvent", "type": "type closeEvent = event_like(_closeEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_compositionEvent", "type": "type _compositionEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "compositionEvent", "type": "type compositionEvent = uiEvent_like(_compositionEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_customEvent", "type": "type _customEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "customEvent", "type": "type customEvent = event_like(_customEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_dragEvent", "type": "type _dragEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "dragEvent", "type": "type dragEvent = event_like(_dragEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_errorEvent", "type": "type _errorEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "errorEvent", "type": "type errorEvent = event_like(_errorEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_focusEvent", "type": "type _focusEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "focusEvent", "type": "type focusEvent = uiEvent_like(_focusEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_idbVersionChangeEvent", "type": "type _idbVersionChangeEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "idbVersionChangeEvent", "type": "type idbVersionChangeEvent = event_like(_idbVersionChangeEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_inputEvent", "type": "type _inputEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "inputEvent", "type": "type inputEvent = uiEvent_like(_inputEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_keyboardEvent", "type": "type _keyboardEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "keyboardEvent", "type": "type keyboardEvent = uiEvent_like(_keyboardEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_mouseEvent", "type": "type _mouseEvent('a)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "mouseEvent_like", "type": "type mouseEvent_like('a) = uiEvent_like(_mouseEvent('a))", "docs": null, "kind": "type"}, {"path": "Dom", "name": "mouseEvent", "type": "type mouseEvent = mouseEvent_like(_baseClass)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_pageTransitionEvent", "type": "type _pageTransitionEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "pageTransitionEvent", "type": "type pageTransitionEvent = event_like(_pageTransitionEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_pointerEvent", "type": "type _pointerEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "pointerEvent", "type": "type pointerEvent = mouseEvent_like(_pointerEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_popStateEvent", "type": "type _popStateEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "popStateEvent", "type": "type popStateEvent = event_like(_popStateEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_progressEvent", "type": "type _progressEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "progressEvent", "type": "type progressEvent = event_like(_progressEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_relatedEvent", "type": "type _relatedEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "relatedEvent", "type": "type relatedEvent = event_like(_relatedEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_storageEvent", "type": "type _storageEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "storageEvent", "type": "type storageEvent = event_like(_storageEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_svgZoomEvent", "type": "type _svgZoomEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "svgZoomEvent", "type": "type svgZoomEvent = event_like(_svgZoomEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_timeEvent", "type": "type _timeEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "timeEvent", "type": "type timeEvent = event_like(_timeEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_touchEvent", "type": "type _touchEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "touchEvent", "type": "type touchEvent = uiEvent_like(_touchEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_trackEvent", "type": "type _trackEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "trackEvent", "type": "type trackEvent = event_like(_trackEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_transitionEvent", "type": "type _transitionEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "transitionEvent", "type": "type transitionEvent = event_like(_transitionEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_webGlContextEvent", "type": "type _webGlContextEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "webGlContextEvent", "type": "type webGlContextEvent = event_like(_webGlContextEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "_wheelEvent", "type": "type _wheelEvent", "docs": null, "kind": "type"}, {"path": "Dom", "name": "wheelEvent", "type": "type wheelEvent = uiEvent_like(_wheelEvent)", "docs": null, "kind": "type"}, {"path": "Dom", "name": "range", "type": "type range", "docs": null, "kind": "type"}, {"path": "Dom", "name": "selection", "type": "type selection", "docs": null, "kind": "type"}, {"path": "Dom", "name": "domTokenList", "type": "type domTokenList", "docs": null, "kind": "type"}, {"path": "Dom", "name": "domSettableTokenList", "type": "type domSettableTokenList", "docs": null, "kind": "type"}, {"path": "Dom", "name": "nodeFilter", "type": "type nodeFilter = {acceptNode: element => int}", "docs": null, "kind": "type"}, {"path": "Dom", "name": "nodeIterator", "type": "type nodeIterator", "docs": null, "kind": "type"}, {"path": "Dom", "name": "treeWalker", "type": "type treeWalker", "docs": null, "kind": "type"}, {"path": "Dom", "name": "svgRect", "type": "type svgRect", "docs": null, "kind": "type"}, {"path": "Dom", "name": "svgPoint", "type": "type svgPoint", "docs": null, "kind": "type"}, {"path": "Dom", "name": "eventPointerId", "type": "type eventPointerId", "docs": null, "kind": "type"}, {"path": "Dom.Storage", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Dom.Storage", "name": "getItem", "type": "let getItem: (string, t) => option(string)", "docs": null, "kind": "value", "args": [["", "string"], ["", "t"]]}, {"path": "Dom.Storage", "name": "setItem", "type": "let setItem: (string, string, t) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"], ["", "t"]]}, {"path": "Dom.Storage", "name": "removeItem", "type": "let removeItem: (string, t) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "t"]]}, {"path": "Dom.Storage", "name": "clear", "type": "let clear: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Dom.Storage", "name": "key", "type": "let key: (int, t) => option(string)", "docs": null, "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Dom.Storage", "name": "length", "type": "let length: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Dom.Storage", "name": "localStorage", "type": "let localStorage: t", "docs": null, "kind": "value"}, {"path": "Dom.Storage", "name": "sessionStorage", "type": "let sessionStorage: t", "docs": null, "kind": "value"}, {"path": "Dom", "name": "Storage", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getItem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>key\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>localStorage\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeItem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sessionStorage\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setItem\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "", "name": "Dom", "type": "<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_animationEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_attr\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_baseClass\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_beforeUnloadEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_cdataSection\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_characterData\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_clipboardEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_closeEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_comment\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_compositionEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_customEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_document\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_documentFragment\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_documentType\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_dragEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_element\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_errorEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_focusEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_htmlDocument\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_htmlElement\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_htmlSlotElement\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_idbVersionChangeEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_inputEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_keyboardEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_mouseEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_node\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_pageTransitionEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_pointerEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_popStateEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_progressEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_relatedEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_shadowRoot\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_storageEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_svgZoomEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_text\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_timeEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_touchEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_trackEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_transitionEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_uiEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_webGlContextEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_wheelEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>_xmlDocument\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>animation\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>animationEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>attr\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>beforeUnloadEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cdataSection\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>characterData\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>characterData_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>clipboardEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>closeEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>comment\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>compositionEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cssStyleDeclaration\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cssStyleSheet\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>customEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>dataTransfer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>document\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>documentFragment\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>documentType\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>document_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>domImplementation\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>domRect\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>domSettableTokenList\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>domStringMap\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>domTokenList\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>dragEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>errorEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>event\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>eventPointerId\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>eventTarget\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>eventTarget_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>event_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>focusEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>history\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>htmlCollection\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>htmlDocument\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>htmlElement\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>htmlElement_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>htmlSlotElement\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>idbVersionChangeEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>inputEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>keyboardEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>location\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>mouseEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>mouseEvent_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>mutationObserver\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>mutationRecord\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>namedNodeMap\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>node\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>nodeFilter\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>nodeIterator\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>nodeList\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>node_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>pageTransitionEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>pointerEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>popStateEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>processingInstruction\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>progressEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>range\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>relatedEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>selection\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>shadowRoot\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>storageEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>svgPoint\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>svgRect\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>svgZoomEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>text\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>timeEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>touchEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>trackEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>transitionEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>treeWalker\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>uiEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>uiEvent_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>webGlContextEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>wheelEvent\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>window\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>xmlDocument\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Storage", "docs": null, "kind": "module"}, {"path": "Belt_SortArrayString", "name": "element", "type": "type element = string", "docs": null, "kind": "type"}, {"path": "Belt_SortArrayString", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArrayString", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArrayString", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArrayString", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArrayString", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_SortArrayString", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArrayString", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArrayString", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "", "name": "Belt_SortArrayString", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": null, "kind": "module"}, {"path": "Belt_SortArrayInt", "name": "element", "type": "type element = int", "docs": null, "kind": "type"}, {"path": "Belt_SortArrayInt", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArrayInt", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArrayInt", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArrayInt", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArrayInt", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_SortArrayInt", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArrayInt", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArrayInt", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "", "name": "Belt_SortArrayInt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": null, "kind": "module"}, {"path": "Belt_SortArray.Int", "name": "element", "type": "type element = int", "docs": null, "kind": "type"}, {"path": "Belt_SortArray.Int", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArray.Int", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArray.Int", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArray.Int", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArray.Int", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_SortArray.Int", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArray.Int", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArray.Int", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArray", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_SortArray.String", "name": "element", "type": "type element = string", "docs": null, "kind": "type"}, {"path": "Belt_SortArray.String", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArray.String", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArray.String", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArray.String", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_SortArray.String", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_SortArray.String", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArray.String", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArray.String", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_SortArray", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_SortArray", "name": "strictlySortedLengthU", "type": "let strictlySortedLengthU: (array('a), Js.Internal.fn([ `Arity_2 of 'a119 * 'a119 ], bool)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a119 * 'a119 ], bool)"]]}, {"path": "Belt_SortArray", "name": "strictlySortedLength", "type": "let strictlySortedLength: (array('a), ('a, 'a) => bool) => int", "docs": "<p><code>strictlySortedLenght xs cmp</code> return <code>+n</code> means increasing order <code>-n</code> means negative order</p>\n<pre class='ml'><code class='ml'>strictlySortedLength [|1;2;3;4;3|] (fun x y -&gt; x &lt; y) = 4;;\nstrictlySortedLength [||] (fun x y -&gt; x &lt; y) = 0;;\nstrictlySortedLength [|1|] (fun x y -&gt; x &lt; y) = 1;;\nstrictlySortedLength [|4;3;2;1|] (fun x y -&gt; x &lt; y) = -4;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_SortArray", "name": "isSortedU", "type": "let isSortedU: (array('a), Js.Internal.fn([ `Arity_2 of 'a118 * 'a118 ], int)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a118 * 'a118 ], int)"]]}, {"path": "Belt_SortArray", "name": "isSorted", "type": "let isSorted: (array('a), ('a, 'a) => int) => bool", "docs": "<p><code>isSorted arr cmp</code></p>\n<p>Returns: <p>true if array is increasingly sorted (equal is okay )</p>\n<pre class='ml'><code class='ml'>isSorted [|1;1;2;3;4|] (fun x y -&gt; compare x y)) = true\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_SortArray", "name": "stableSortInPlaceByU", "type": "let stableSortInPlaceByU: (array('a), Js.Internal.fn([ `Arity_2 of 'a117 * 'a117 ], int)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a117 * 'a117 ], int)"]]}, {"path": "Belt_SortArray", "name": "stableSortInPlaceBy", "type": "let stableSortInPlaceBy: (array('a), ('a, 'a) => int) => unit", "docs": "<p><code>stableSortBy xs cmp</code></p>\n<p>Sort xs in place using comparator <code>cmp</code>, the stable means if the elements are equal, their order will be preserved</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_SortArray", "name": "stableSortByU", "type": "let stableSortByU: (array('a), Js.Internal.fn([ `Arity_2 of 'a116 * 'a116 ], int)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a116 * 'a116 ], int)"]]}, {"path": "Belt_SortArray", "name": "stableSortBy", "type": "let stableSortBy: (array('a), ('a, 'a) => int) => array('a)", "docs": "<p><code>stableSort xs cmp</code></p>\n<p>Returns: <p>a fresh array</p>\n<p>The same as stableSortInPlaceBy except that <code>xs</code> is not modified</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_SortArray", "name": "binarySearchByU", "type": "let binarySearchByU: (array('a), 'a, Js.Internal.fn([ `Arity_2 of 'a115 * 'a115 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a115 * 'a115 ], int)"]]}, {"path": "Belt_SortArray", "name": "binarySearchBy", "type": "let binarySearchBy: (array('a), 'a, ('a, 'a) => int) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n<pre class='ml'><code class='ml'>binarySearchBy [|1;2;3;4;33;35;36|] 33 = 4;;\nlnot (binarySearchBy [|1;3;5;7|] 4) = 2;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "'a"], ["", "('a, 'a) => int"]]}, {"path": "Belt_SortArray", "name": "unionU", "type": "let unionU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a114 * 'a114 ], int)\n) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a114 * 'a114 ], int)"]]}, {"path": "Belt_SortArray", "name": "union", "type": "let union: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p><code>union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp</code> assume <code>src</code> and <code>src2</code> is strictly sorted. for equivalent elements, it is picked from <code>src</code> also assume that <code>dst</code> is large enough to store all elements</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt_SortArray", "name": "intersectU", "type": "let intersectU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a113 * 'a113 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a113 * 'a113 ], int)"]]}, {"path": "Belt_SortArray", "name": "intersect", "type": "let intersect: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p><code>union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp</code> return the <code>offset</code> in the output array</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt_SortArray", "name": "diffU", "type": "let diffU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a112 * 'a112 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a112 * 'a112 ], int)"]]}, {"path": "Belt_SortArray", "name": "diff", "type": "let diff: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "", "name": "Belt_SortArray", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearchBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearchByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diffU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersectU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSortedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlaceBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlaceByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLengthU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unionU\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt_SetString", "name": "value", "type": "type value = string", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt_SetString", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt_SetString", "name": "empty", "type": "let empty: t", "docs": null, "kind": "value"}, {"path": "Belt_SetString", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_SetString", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_SetString", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_SetString", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_SetString", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetString", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetString", "name": "add", "type": "let add: (t, value) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetString", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_SetString", "name": "remove", "type": "let remove: (t, value) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetString", "name": "removeMany", "type": "let removeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_SetString", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetString", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetString", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetString", "name": "subset", "type": "let subset: (t, t) => bool", "docs": "<p><code>subset s1 s2</code> tests whether the set <code>s1</code> is a subset of the set <code>s2</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetString", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetString", "name": "eq", "type": "let eq: (t, t) => bool", "docs": "<p><code>eq s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> are equal, that is, contain equal elements.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetString", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt_SetString", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt_SetString", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a77 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a77 * value ], 'a)"]]}, {"path": "Belt_SetString", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt_SetString", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_SetString", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_SetString", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_SetString", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_SetString", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_SetString", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep p s</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_SetString", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_SetString", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_SetString", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetString", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetString", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetString", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetString", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetString", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetString", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetString", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetString", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetString", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetString", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split x s</code> returns a triple <code>(l, present, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetString", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "", "name": "Belt_SetString", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": null, "kind": "module"}, {"path": "Belt_SetInt", "name": "value", "type": "type value = int", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt_SetInt", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt_SetInt", "name": "empty", "type": "let empty: t", "docs": null, "kind": "value"}, {"path": "Belt_SetInt", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_SetInt", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_SetInt", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_SetInt", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_SetInt", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetInt", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetInt", "name": "add", "type": "let add: (t, value) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetInt", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_SetInt", "name": "remove", "type": "let remove: (t, value) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetInt", "name": "removeMany", "type": "let removeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_SetInt", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetInt", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetInt", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetInt", "name": "subset", "type": "let subset: (t, t) => bool", "docs": "<p><code>subset s1 s2</code> tests whether the set <code>s1</code> is a subset of the set <code>s2</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetInt", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetInt", "name": "eq", "type": "let eq: (t, t) => bool", "docs": "<p><code>eq s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> are equal, that is, contain equal elements.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_SetInt", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt_SetInt", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt_SetInt", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a78 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a78 * value ], 'a)"]]}, {"path": "Belt_SetInt", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt_SetInt", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_SetInt", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_SetInt", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_SetInt", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_SetInt", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_SetInt", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep p s</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_SetInt", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_SetInt", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_SetInt", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetInt", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetInt", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetInt", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetInt", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetInt", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetInt", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_SetInt", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetInt", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetInt", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetInt", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split x s</code> returns a triple <code>(l, present, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_SetInt", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "", "name": "Belt_SetInt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": null, "kind": "module"}, {"path": "Belt_SetDict", "name": "t", "type": "type t('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_SetDict", "name": "cmp", "type": "type cmp('key, 'id) = Belt_Id.cmp('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_SetDict", "name": "empty", "type": "let empty: t('value, 'id)", "docs": null, "kind": "value"}, {"path": "Belt_SetDict", "name": "ofArray", "type": "let ofArray: (array('k), ~cmp: cmp('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_SetDict", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array('value) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"]]}, {"path": "Belt_SetDict", "name": "fromArray", "type": "let fromArray: (array('k), ~cmp: cmp('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_SetDict", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array('value) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"]]}, {"path": "Belt_SetDict", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_SetDict", "name": "has", "type": "let has: (t('k, 'id), 'k, ~cmp: cmp('k, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_SetDict", "name": "add", "type": "let add: (t('k, 'id), 'k, ~cmp: cmp('k, 'id)) => t('k, 'id)", "docs": "<p><code>add s x</code> If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t('k, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_SetDict", "name": "mergeMany", "type": "let mergeMany: (t('value, 'id), array('value), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "remove", "type": "let remove: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": "<p><code>remove m x</code> If <code>x</code> was not in <code>m</code>, <code>m</code> is returned reference unchanged.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "removeMany", "type": "let removeMany: (t('value, 'id), array('value), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "union", "type": "let union: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "intersect", "type": "let intersect: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "diff", "type": "let diff: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "subset", "type": "let subset: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "cmp", "type": "let cmp: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "eq", "type": "let eq: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => bool", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "forEachU", "type": "let forEachU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value19 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value19 ], unit)"]]}, {"path": "Belt_SetDict", "name": "forEach", "type": "let forEach: (t('value, 'id), 'value => unit) => unit", "docs": "<p><code>forEach s f</code> applies <code>f</code> in turn to all elements of <code>s</code>. In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => unit"]]}, {"path": "Belt_SetDict", "name": "reduceU", "type": "let reduceU: (t('value, 'id), 'a, Js.Internal.fn([ `Arity_2 of 'a76 * 'value18 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a76 * 'value18 ], 'a)"]]}, {"path": "Belt_SetDict", "name": "reduce", "type": "let reduce: (t('value, 'id), 'a, ('a, 'value) => 'a) => 'a", "docs": "<p>In increasing order.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "('a, 'value) => 'a"]]}, {"path": "Belt_SetDict", "name": "everyU", "type": "let everyU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value17 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value17 ], bool)"]]}, {"path": "Belt_SetDict", "name": "every", "type": "let every: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_SetDict", "name": "someU", "type": "let someU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value16 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value16 ], bool)"]]}, {"path": "Belt_SetDict", "name": "some", "type": "let some: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_SetDict", "name": "keepU", "type": "let keepU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value15 ], bool)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value15 ], bool)"]]}, {"path": "Belt_SetDict", "name": "keep", "type": "let keep: (t('value, 'id), 'value => bool) => t('value, 'id)", "docs": "<p><code>keep m p</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_SetDict", "name": "partitionU", "type": "let partitionU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value14 ], bool)) => (\n  t('value, 'id),\n  t('value, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value14 ], bool)"]]}, {"path": "Belt_SetDict", "name": "partition", "type": "let partition: (t('value, 'id), 'value => bool) => (t('value, 'id), t('value, 'id))", "docs": "<p><code>partition m p</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_SetDict", "name": "size", "type": "let size: t('value, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "toList", "type": "let toList: t('value, 'id) => list('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "toArray", "type": "let toArray: t('value, 'id) => array('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "minimum", "type": "let minimum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "minUndefined", "type": "let minUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "maximum", "type": "let maximum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "maxUndefined", "type": "let maxUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "get", "type": "let get: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "getUndefined", "type": "let getUndefined: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "getExn", "type": "let getExn: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => 'value", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "split", "type": "let split: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => (\n  (t('value, 'id), t('value, 'id)),\n  bool\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_SetDict", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "", "name": "Belt_SetDict", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_Set.Int", "name": "value", "type": "type value = int", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt_Set.Int", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt_Set.Int", "name": "empty", "type": "let empty: t", "docs": null, "kind": "value"}, {"path": "Belt_Set.Int", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_Set.Int", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_Set.Int", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_Set.Int", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_Set.Int", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.Int", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.Int", "name": "add", "type": "let add: (t, value) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.Int", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_Set.Int", "name": "remove", "type": "let remove: (t, value) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.Int", "name": "removeMany", "type": "let removeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_Set.Int", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.Int", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.Int", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.Int", "name": "subset", "type": "let subset: (t, t) => bool", "docs": "<p><code>subset s1 s2</code> tests whether the set <code>s1</code> is a subset of the set <code>s2</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.Int", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.Int", "name": "eq", "type": "let eq: (t, t) => bool", "docs": "<p><code>eq s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> are equal, that is, contain equal elements.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.Int", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt_Set.Int", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt_Set.Int", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a78 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a78 * value ], 'a)"]]}, {"path": "Belt_Set.Int", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt_Set.Int", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_Set.Int", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_Set.Int", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_Set.Int", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_Set.Int", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_Set.Int", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep p s</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_Set.Int", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_Set.Int", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_Set.Int", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.Int", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.Int", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.Int", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.Int", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.Int", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.Int", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.Int", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.Int", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.Int", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.Int", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split x s</code> returns a triple <code>(l, present, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": "<p>Specalized when value type is <code>int</code>, more efficient than the gerneic type, its compare behavior is fixed using the built-in comparison</p>\n", "kind": "module"}, {"path": "Belt_Set.String", "name": "value", "type": "type value = string", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt_Set.String", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt_Set.String", "name": "empty", "type": "let empty: t", "docs": null, "kind": "value"}, {"path": "Belt_Set.String", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_Set.String", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_Set.String", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_Set.String", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_Set.String", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.String", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.String", "name": "add", "type": "let add: (t, value) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.String", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_Set.String", "name": "remove", "type": "let remove: (t, value) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.String", "name": "removeMany", "type": "let removeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_Set.String", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.String", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.String", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.String", "name": "subset", "type": "let subset: (t, t) => bool", "docs": "<p><code>subset s1 s2</code> tests whether the set <code>s1</code> is a subset of the set <code>s2</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.String", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.String", "name": "eq", "type": "let eq: (t, t) => bool", "docs": "<p><code>eq s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> are equal, that is, contain equal elements.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_Set.String", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt_Set.String", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt_Set.String", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a77 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a77 * value ], 'a)"]]}, {"path": "Belt_Set.String", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt_Set.String", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_Set.String", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_Set.String", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_Set.String", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_Set.String", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_Set.String", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep p s</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_Set.String", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_Set.String", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_Set.String", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.String", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.String", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.String", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.String", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.String", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.String", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set.String", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.String", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.String", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.String", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split x s</code> returns a triple <code>(l, present, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_Set.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_Set", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": "<p>Specalized when value type is <code>string</code>, more efficient than the gerneic type, its compare behavior is fixed using the built-in comparison</p>\n", "kind": "module"}, {"path": "Belt_Set.Dict", "name": "t", "type": "type t('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_Set.Dict", "name": "cmp", "type": "type cmp('key, 'id) = Belt_Id.cmp('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_Set.Dict", "name": "empty", "type": "let empty: t('value, 'id)", "docs": null, "kind": "value"}, {"path": "Belt_Set.Dict", "name": "ofArray", "type": "let ofArray: (array('k), ~cmp: cmp('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array('value) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"]]}, {"path": "Belt_Set.Dict", "name": "fromArray", "type": "let fromArray: (array('k), ~cmp: cmp('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array('value) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"]]}, {"path": "Belt_Set.Dict", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_Set.Dict", "name": "has", "type": "let has: (t('k, 'id), 'k, ~cmp: cmp('k, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "add", "type": "let add: (t('k, 'id), 'k, ~cmp: cmp('k, 'id)) => t('k, 'id)", "docs": "<p><code>add s x</code> If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t('k, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "mergeMany", "type": "let mergeMany: (t('value, 'id), array('value), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "remove", "type": "let remove: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": "<p><code>remove m x</code> If <code>x</code> was not in <code>m</code>, <code>m</code> is returned reference unchanged.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "removeMany", "type": "let removeMany: (t('value, 'id), array('value), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "union", "type": "let union: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "intersect", "type": "let intersect: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "diff", "type": "let diff: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "subset", "type": "let subset: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "cmp", "type": "let cmp: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "eq", "type": "let eq: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => bool", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "forEachU", "type": "let forEachU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value19 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value19 ], unit)"]]}, {"path": "Belt_Set.Dict", "name": "forEach", "type": "let forEach: (t('value, 'id), 'value => unit) => unit", "docs": "<p><code>forEach s f</code> applies <code>f</code> in turn to all elements of <code>s</code>. In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => unit"]]}, {"path": "Belt_Set.Dict", "name": "reduceU", "type": "let reduceU: (t('value, 'id), 'a, Js.Internal.fn([ `Arity_2 of 'a76 * 'value18 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a76 * 'value18 ], 'a)"]]}, {"path": "Belt_Set.Dict", "name": "reduce", "type": "let reduce: (t('value, 'id), 'a, ('a, 'value) => 'a) => 'a", "docs": "<p>In increasing order.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "('a, 'value) => 'a"]]}, {"path": "Belt_Set.Dict", "name": "everyU", "type": "let everyU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value17 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value17 ], bool)"]]}, {"path": "Belt_Set.Dict", "name": "every", "type": "let every: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_Set.Dict", "name": "someU", "type": "let someU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value16 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value16 ], bool)"]]}, {"path": "Belt_Set.Dict", "name": "some", "type": "let some: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_Set.Dict", "name": "keepU", "type": "let keepU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value15 ], bool)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value15 ], bool)"]]}, {"path": "Belt_Set.Dict", "name": "keep", "type": "let keep: (t('value, 'id), 'value => bool) => t('value, 'id)", "docs": "<p><code>keep m p</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_Set.Dict", "name": "partitionU", "type": "let partitionU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value14 ], bool)) => (\n  t('value, 'id),\n  t('value, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value14 ], bool)"]]}, {"path": "Belt_Set.Dict", "name": "partition", "type": "let partition: (t('value, 'id), 'value => bool) => (t('value, 'id), t('value, 'id))", "docs": "<p><code>partition m p</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_Set.Dict", "name": "size", "type": "let size: t('value, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "toList", "type": "let toList: t('value, 'id) => list('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "toArray", "type": "let toArray: t('value, 'id) => array('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "minimum", "type": "let minimum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "minUndefined", "type": "let minUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "maximum", "type": "let maximum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "maxUndefined", "type": "let maxUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "get", "type": "let get: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "getUndefined", "type": "let getUndefined: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "getExn", "type": "let getExn: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => 'value", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "split", "type": "let split: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => (\n  (t('value, 'id), t('value, 'id)),\n  bool\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt_Set.Dict", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_Set", "name": "Dict", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>This module seprate identity from data, it is a bit more verbsoe but slightly more efficient due to the fact that there is no need to pack identity and data back after each operation</p>\n", "kind": "module"}, {"path": "Belt_Set", "name": "t", "type": "type t('value, 'identity)", "docs": "<p><code>(&#39;value, &#39;identity) t</code></p>\n<p><code>&#39;value</code> is the element type</p>\n<p><code>&#39;identity</code> the identity of the collection</p>\n", "kind": "type"}, {"path": "Belt_Set", "name": "id", "type": "type id('value, 'id) = Belt_Id.comparable('value, 'id)", "docs": "<p>The identity needed for making a set from scratch</p>\n", "kind": "type"}, {"path": "Belt_Set", "name": "make", "type": "let make: (~id: id('value, 'id)) => t('value, 'id)", "docs": "<p><code>make ~id</code> creates a new set by taking in the comparator</p>\n<pre class='ml'><code class='ml'>let s = make ~id:(module IntCmp)\n</code></pre>", "kind": "value", "args": [["id", "id('value, 'id)"]]}, {"path": "Belt_Set", "name": "ofArray", "type": "let ofArray: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt_Set", "name": "fromArray", "type": "let fromArray: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": "<p><code>fromArray xs ~id</code></p>\n<pre class='ml'><code class='ml'>toArray (fromArray [1;3;2;4] (module IntCmp)) = [1;2;3;4]\n</code></pre>", "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt_Set", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt_Set", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": "<p><code>fromSortedArrayUnsafe xs ~id</code></p>\n<p>The same as fromArray except it is after assuming the input array <code>x</code> is already sorted</p>\n<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt_Set", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": "<pre class='ml'><code class='ml'>isEmpty (fromArray [||] ~id:(module IntCmp)) = true;;\nisEmpty (fromArray [|1|] ~id:(module IntCmp)) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_Set", "name": "has", "type": "let has: (t('value, 'id), 'value) => bool", "docs": "<pre class='ml'><code class='ml'>isEmpty (fromArray [||] ~id:(module IntCmp)) = true;;\nisEmpty (fromArray [|1|] ~id:(module IntCmp)) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_Set", "name": "add", "type": "let add: (t('value, 'id), 'value) => t('value, 'id)", "docs": "<p><code>add s x</code> If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n<pre class='ml'><code class='ml'>let s0 = make ~id:(module IntCmp);;\nlet s1 = add s0 1 ;;\nlet s2 = add s1 2;;\nlet s3 = add s2 2;;\ntoArray s0 = [||];;\ntoArray s1 = [|1|];;\ntoArray s2 = [|1;2|];;\ntoArray s3 = [|1;2|];;\ns2 == s3;;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_Set", "name": "mergeMany", "type": "let mergeMany: (t('value, 'id), array('value)) => t('value, 'id)", "docs": "<p><code>mergeMany s xs</code></p>\n<p>Adding each of <code>xs</code> to <code>s</code>, note unlike add, the reference of return value might be changed even if all values in <code>xs</code> exist <code>s</code></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"]]}, {"path": "Belt_Set", "name": "remove", "type": "let remove: (t('value, 'id), 'value) => t('value, 'id)", "docs": "<p><code>mergeMany s xs</code></p>\n<p>Adding each of <code>xs</code> to <code>s</code>, note unlike add, the reference of return value might be changed even if all values in <code>xs</code> exist <code>s</code></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_Set", "name": "removeMany", "type": "let removeMany: (t('value, 'id), array('value)) => t('value, 'id)", "docs": "<p><code>removeMany s xs</code></p>\n<p>Removing each of <code>xs</code> to <code>s</code>, note unlike remove, the reference of return value might be changed even if none in <code>xs</code> exists <code>s</code></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"]]}, {"path": "Belt_Set", "name": "union", "type": "let union: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": "<p><code>union s0 s1</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet s1 = fromArray ~id:(module IntCmp) [|5;2;3;1;5;4;|];;\ntoArray (union s0 s1) =  [|1;2;3;4;5;6|]\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "intersect", "type": "let intersect: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": "<p><code>intersect s0 s1</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet s1 = fromArray ~id:(module IntCmp) [|5;2;3;1;5;4;|];;\ntoArray (intersect s0 s1) =  [|2;3;5|]\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "diff", "type": "let diff: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": "<p><code>intersect s0 s1</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet s1 = fromArray ~id:(module IntCmp) [|5;2;3;1;5;4;|];;\ntoArray (intersect s0 s1) =  [|2;3;5|]\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "subset", "type": "let subset: (t('value, 'id), t('value, 'id)) => bool", "docs": "<p><code>subset s0 s1</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet s1 = fromArray ~id:(module IntCmp) [|5;2;3;1;5;4;|];;\nlet s2 = intersect s0 s1;;\nsubset s2 s0 = true;;\nsubset s2 s1 = true;;\nsubset s1 s0 = false;;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "cmp", "type": "let cmp: (t('value, 'id), t('value, 'id)) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets. It compare <code>size</code> first and then iterate over each element following the order of elements</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "eq", "type": "let eq: (t('value, 'id), t('value, 'id)) => bool", "docs": "<p><code>eq s0 s1</code></p>\n<p>Returns: <p>true if <code>toArray s0 = toArray s1</code></p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "forEachU", "type": "let forEachU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value13 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value13 ], unit)"]]}, {"path": "Belt_Set", "name": "forEach", "type": "let forEach: (t('value, 'id), 'value => unit) => unit", "docs": "<p><code>forEach s f</code> applies <code>f</code> in turn to all elements of <code>s</code>. In increasing order</p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet acc = ref [] ;;\nforEach s0 (fun x -&gt; acc := x !acc);;\n!acc = [6;5;3;2];;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => unit"]]}, {"path": "Belt_Set", "name": "reduceU", "type": "let reduceU: (t('value, 'id), 'a, Js.Internal.fn([ `Arity_2 of 'a75 * 'value12 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a75 * 'value12 ], 'a)"]]}, {"path": "Belt_Set", "name": "reduce", "type": "let reduce: (t('value, 'id), 'a, ('a, 'value) => 'a) => 'a", "docs": "<p>In increasing order.</p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nreduce s0 [] Bs.List.add = [6;5;3;2];;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "('a, 'value) => 'a"]]}, {"path": "Belt_Set", "name": "everyU", "type": "let everyU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value11 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value11 ], bool)"]]}, {"path": "Belt_Set", "name": "every", "type": "let every: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_Set", "name": "someU", "type": "let someU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value10 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value10 ], bool)"]]}, {"path": "Belt_Set", "name": "some", "type": "let some: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_Set", "name": "keepU", "type": "let keepU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value9 ], bool)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value9 ], bool)"]]}, {"path": "Belt_Set", "name": "keep", "type": "let keep: (t('value, 'id), 'value => bool) => t('value, 'id)", "docs": "<p><code>keep m p</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_Set", "name": "partitionU", "type": "let partitionU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value8 ], bool)) => (\n  t('value, 'id),\n  t('value, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value8 ], bool)"]]}, {"path": "Belt_Set", "name": "partition", "type": "let partition: (t('value, 'id), 'value => bool) => (t('value, 'id), t('value, 'id))", "docs": "<p><code>partition m p</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_Set", "name": "size", "type": "let size: t('value, 'id) => int", "docs": "<p><code>size s</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nsize s0 = 4;;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "toArray", "type": "let toArray: t('value, 'id) => array('value)", "docs": "<p><code>toArray s0</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\ntoArray s0 = [|2;3;5;6|];;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "toList", "type": "let toList: t('value, 'id) => list('value)", "docs": "<p>In increasing order</p>\n<p><strong>See</strong> toArray</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "minimum", "type": "let minimum: t('value, 'id) => option('value)", "docs": "<p><code>minimum s0</code></p>\n<p>Returns: <p>the minimum element of the collection, <code>None</code> if it is empty</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "minUndefined", "type": "let minUndefined: t('value, 'id) => Js.undefined('value)", "docs": "<p><code>minUndefined s0</code></p>\n<p>Returns: <p>the minimum element of the collection, <code>undefined</code> if it is empty</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "maximum", "type": "let maximum: t('value, 'id) => option('value)", "docs": "<p><code>maximum s0</code></p>\n<p>Returns: <p>the maximum element of the collection, <code>None</code> if it is empty</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "maxUndefined", "type": "let maxUndefined: t('value, 'id) => Js.undefined('value)", "docs": "<p><code>maximum s0</code></p>\n<p>Returns: <p>the maximum element of the collection, <code>None</code> if it is empty</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "get", "type": "let get: (t('value, 'id), 'value) => option('value)", "docs": "<p><code>get s0 k</code></p>\n<p>Returns: <p>the reference of the value <code>k&#39;</code> which is equivalent to <code>k</code> using the comparator specifiecd by this collection, <code>None</code> if it does not exist</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_Set", "name": "getUndefined", "type": "let getUndefined: (t('value, 'id), 'value) => Js.undefined('value)", "docs": "<p><strong>See</strong> get</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_Set", "name": "getExn", "type": "let getExn: (t('value, 'id), 'value) => 'value", "docs": "<p><strong>See</strong> get</p>\n<p><strong>raise</strong> if not exist</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_Set", "name": "split", "type": "let split: (t('value, 'id), 'value) => ((t('value, 'id), t('value, 'id)), bool)", "docs": "<p><code>split set ele</code></p>\n<p>Returns: <p>a tuple <code>((smaller, larger), present)</code>, <code>present</code> is true when <code>ele</code> exist in <code>set</code></p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_Set", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_Set", "name": "getData", "type": "let getData: t('value, 'id) => Belt_SetDict.t('value, 'id)", "docs": "<p><code>getData s0</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the raw data (detached from comparator), but its type is still manifested, so that user can pass identity directly without boxing</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "getId", "type": "let getId: t('value, 'id) => id('value, 'id)", "docs": "<p><code>getId s0</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the identity of <code>s0</code></p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_Set", "name": "packIdData", "type": "let packIdData: (~id: id('value, 'id), ~data: Belt_SetDict.t('value, 'id)) => t('value, 'id)", "docs": "<p><code>packIdData ~id ~data</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the packed collection</p></p>\n", "kind": "value", "args": [["id", "id('value, 'id)"], ["data", "Belt_SetDict.t('value, 'id)"]]}, {"path": "", "name": "Belt_Set", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getData\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getId\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>packIdData\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Dict\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt_Range", "name": "forEachU", "type": "let forEachU: (int, int, Js.Internal.fn([ `Arity_1 of int ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], unit)"]]}, {"path": "Belt_Range", "name": "forEach", "type": "let forEach: (int, int, int => unit) => unit", "docs": "<p><code>forEach start finish action</code></p>\n<p>equivalent to <code>Belt.Array.(forEach (range start finish) action)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "int => unit"]]}, {"path": "Belt_Range", "name": "everyU", "type": "let everyU: (int, int, Js.Internal.fn([ `Arity_1 of int ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], bool)"]]}, {"path": "Belt_Range", "name": "every", "type": "let every: (int, int, int => bool) => bool", "docs": "<p><code>every start finish p</code></p>\n<p>equivalent to <code>Belt.Array.(every (range start finish) p )</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "int => bool"]]}, {"path": "Belt_Range", "name": "everyByU", "type": "let everyByU: (int, int, ~step: int, Js.Internal.fn([ `Arity_1 of int ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], bool)"]]}, {"path": "Belt_Range", "name": "everyBy", "type": "let everyBy: (int, int, ~step: int, int => bool) => bool", "docs": "<p><code>everyBy start finish ~step p</code></p>\n<p><strong>See</strong> rangeBy</p>\n<p>equivalent to <code>Belt.Array.(every (rangeBy start finish ~step) p)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"], ["", "int => bool"]]}, {"path": "Belt_Range", "name": "someU", "type": "let someU: (int, int, Js.Internal.fn([ `Arity_1 of int ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], bool)"]]}, {"path": "Belt_Range", "name": "some", "type": "let some: (int, int, int => bool) => bool", "docs": "<p><code>some start finish p</code></p>\n<p>equivalent to <code>Belt.Array.(some (range start finish) p)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "int => bool"]]}, {"path": "Belt_Range", "name": "someByU", "type": "let someByU: (int, int, ~step: int, Js.Internal.fn([ `Arity_1 of int ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], bool)"]]}, {"path": "Belt_Range", "name": "someBy", "type": "let someBy: (int, int, ~step: int, int => bool) => bool", "docs": "<p><code>someBy start finish ~step  p</code></p>\n<p><strong>See</strong> rangeBy</p>\n<p>equivalent to <code>Belt.Array.(some (rangeBy start finish ~step) p)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"], ["", "int => bool"]]}, {"path": "", "name": "Belt_Range", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU", "docs": null, "kind": "module"}, {"path": "Belt_Option", "name": "getExn", "type": "let getExn: option('a) => 'a", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Belt_Option", "name": "mapWithDefaultU", "type": "let mapWithDefaultU: (option('a), 'b, Js.Internal.fn([ `Arity_1 of 'a30 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_1 of 'a30 ], 'b)"]]}, {"path": "Belt_Option", "name": "mapWithDefault", "type": "let mapWithDefault: (option('a), 'b, 'a => 'b) => 'b", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'b"], ["", "'a => 'b"]]}, {"path": "Belt_Option", "name": "mapU", "type": "let mapU: (option('a), Js.Internal.fn([ `Arity_1 of 'a29 ], 'b)) => option('b)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a29 ], 'b)"]]}, {"path": "Belt_Option", "name": "map", "type": "let map: (option('a), 'a => 'b) => option('b)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'a => 'b"]]}, {"path": "Belt_Option", "name": "flatMapU", "type": "let flatMapU: (option('a), Js.Internal.fn([ `Arity_1 of 'a28 ], option('b))) => option('b)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a28 ], option('b))"]]}, {"path": "Belt_Option", "name": "flatMap", "type": "let flatMap: (option('a), 'a => option('b)) => option('b)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'a => option('b)"]]}, {"path": "Belt_Option", "name": "getWithDefault", "type": "let getWithDefault: (option('a), 'a) => 'a", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'a"]]}, {"path": "Belt_Option", "name": "isSome", "type": "let isSome: option('a) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Belt_Option", "name": "isNone", "type": "let isNone: option('a) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Belt_Option", "name": "eqU", "type": "let eqU: (option('a), option('b), Js.Internal.fn([ `Arity_2 of 'a27 * 'b6 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a27 * 'b6 ], bool)"]]}, {"path": "Belt_Option", "name": "eq", "type": "let eq: (option('a), option('b), ('a, 'b) => bool) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_Option", "name": "cmpU", "type": "let cmpU: (option('a), option('b), Js.Internal.fn([ `Arity_2 of 'a26 * 'b5 ], int)) => int", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a26 * 'b5 ], int)"]]}, {"path": "Belt_Option", "name": "cmp", "type": "let cmp: (option('a), option('b), ('a, 'b) => int) => int", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('b)"], ["", "('a, 'b) => int"]]}, {"path": "", "name": "Belt_Option", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isNone\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSome\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithDefaultU", "docs": null, "kind": "module"}, {"path": "Belt_MutableStack", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Belt_MutableStack", "name": "make", "type": "let make: unit => t('a)", "docs": "<p>Returns: <p>a new stack, initially empty.</p></p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableStack", "name": "clear", "type": "let clear: t('a) => unit", "docs": "<p>Discard all elements from the stack.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableStack", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": "<p>Discard all elements from the stack.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableStack", "name": "push", "type": "let push: (t('a), 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"]]}, {"path": "Belt_MutableStack", "name": "popUndefined", "type": "let popUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableStack", "name": "pop", "type": "let pop: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableStack", "name": "topUndefined", "type": "let topUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableStack", "name": "top", "type": "let top: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableStack", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableStack", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableStack", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_1 of 'a108 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a108 ], unit)"]]}, {"path": "Belt_MutableStack", "name": "forEach", "type": "let forEach: (t('a), 'a => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => unit"]]}, {"path": "Belt_MutableStack", "name": "dynamicPopIterU", "type": "let dynamicPopIterU: (t('a), Js.Internal.fn([ `Arity_1 of 'a107 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a107 ], unit)"]]}, {"path": "Belt_MutableStack", "name": "dynamicPopIter", "type": "let dynamicPopIter: (t('a), 'a => unit) => unit", "docs": "<p><code>dynamicPopIter s f </code> apply <code>f</code> to each element of <code>s</code>. The item is poped before applying <code>f</code>, <code>s</code> will be empty after this opeartion. This function is useful for worklist algorithm</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => unit"]]}, {"path": "", "name": "Belt_MutableStack", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dynamicPopIter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dynamicPopIterU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>popUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>push\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>top\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>topUndefined\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_MutableSetString", "name": "value", "type": "type value = string", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt_MutableSetString", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt_MutableSetString", "name": "make", "type": "let make: unit => t", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableSetString", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSetString", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSetString", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSetString", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSetString", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetString", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetString", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetString", "name": "add", "type": "let add: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetString", "name": "addCheck", "type": "let addCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetString", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_MutableSetString", "name": "remove", "type": "let remove: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetString", "name": "removeCheck", "type": "let removeCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetString", "name": "removeMany", "type": "let removeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_MutableSetString", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetString", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetString", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetString", "name": "subset", "type": "let subset: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetString", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetString", "name": "eq", "type": "let eq: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetString", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt_MutableSetString", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt_MutableSetString", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a63 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a63 * value ], 'a)"]]}, {"path": "Belt_MutableSetString", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt_MutableSetString", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSetString", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSetString", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSetString", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSetString", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSetString", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep s p</code> returns a fresh copy of the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSetString", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSetString", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition s p</code> returns a fresh copy pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSetString", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetString", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetString", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetString", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetString", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetString", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetString", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetString", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetString", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetString", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetString", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split s key</code> return a fresh copy of each</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetString", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "", "name": "Belt_MutableSetString", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": null, "kind": "module"}, {"path": "Belt_MutableSetInt", "name": "value", "type": "type value = int", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt_MutableSetInt", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt_MutableSetInt", "name": "make", "type": "let make: unit => t", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableSetInt", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSetInt", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSetInt", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSetInt", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSetInt", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetInt", "name": "add", "type": "let add: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetInt", "name": "addCheck", "type": "let addCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetInt", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_MutableSetInt", "name": "remove", "type": "let remove: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetInt", "name": "removeCheck", "type": "let removeCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetInt", "name": "removeMany", "type": "let removeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_MutableSetInt", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "subset", "type": "let subset: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "eq", "type": "let eq: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt_MutableSetInt", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt_MutableSetInt", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a64 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a64 * value ], 'a)"]]}, {"path": "Belt_MutableSetInt", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt_MutableSetInt", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSetInt", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSetInt", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSetInt", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSetInt", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSetInt", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep s p</code> returns a fresh copy of the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSetInt", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSetInt", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition s p</code> returns a fresh copy pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSetInt", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSetInt", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetInt", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetInt", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetInt", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split s key</code> return a fresh copy of each</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSetInt", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "", "name": "Belt_MutableSetInt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": null, "kind": "module"}, {"path": "Belt_MutableSet.Int", "name": "value", "type": "type value = int", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt_MutableSet.Int", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt_MutableSet.Int", "name": "make", "type": "let make: unit => t", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableSet.Int", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSet.Int", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSet.Int", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSet.Int", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSet.Int", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.Int", "name": "add", "type": "let add: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.Int", "name": "addCheck", "type": "let addCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.Int", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_MutableSet.Int", "name": "remove", "type": "let remove: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.Int", "name": "removeCheck", "type": "let removeCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.Int", "name": "removeMany", "type": "let removeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_MutableSet.Int", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "subset", "type": "let subset: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "eq", "type": "let eq: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt_MutableSet.Int", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt_MutableSet.Int", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a64 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a64 * value ], 'a)"]]}, {"path": "Belt_MutableSet.Int", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt_MutableSet.Int", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSet.Int", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSet.Int", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSet.Int", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSet.Int", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSet.Int", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep s p</code> returns a fresh copy of the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSet.Int", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSet.Int", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition s p</code> returns a fresh copy pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSet.Int", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.Int", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.Int", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.Int", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.Int", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split s key</code> return a fresh copy of each</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_MutableSet.String", "name": "value", "type": "type value = string", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt_MutableSet.String", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt_MutableSet.String", "name": "make", "type": "let make: unit => t", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableSet.String", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSet.String", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSet.String", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSet.String", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt_MutableSet.String", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.String", "name": "add", "type": "let add: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.String", "name": "addCheck", "type": "let addCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.String", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_MutableSet.String", "name": "remove", "type": "let remove: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.String", "name": "removeCheck", "type": "let removeCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.String", "name": "removeMany", "type": "let removeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt_MutableSet.String", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "subset", "type": "let subset: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "eq", "type": "let eq: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt_MutableSet.String", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt_MutableSet.String", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a63 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a63 * value ], 'a)"]]}, {"path": "Belt_MutableSet.String", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt_MutableSet.String", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSet.String", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSet.String", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSet.String", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSet.String", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSet.String", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep s p</code> returns a fresh copy of the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSet.String", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt_MutableSet.String", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition s p</code> returns a fresh copy pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt_MutableSet.String", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet.String", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.String", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.String", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.String", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split s key</code> return a fresh copy of each</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_MutableSet.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt_MutableSet", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_MutableSet", "name": "t", "type": "type t('k, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_MutableSet", "name": "id", "type": "type id('k, 'id) = Belt_Id.comparable('k, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_MutableSet", "name": "make", "type": "let make: (~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["id", "id('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "fromArray", "type": "let fromArray: (array('k), ~id: id('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["id", "id('k, 'id)"]]}, {"path": "Belt_MutableSet", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "copy", "type": "let copy: t('k, 'id) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'id)"]]}, {"path": "Belt_MutableSet", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_MutableSet", "name": "has", "type": "let has: (t('value, 'a), 'value) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'a)"], ["", "'value"]]}, {"path": "Belt_MutableSet", "name": "add", "type": "let add: (t('value, 'id), 'value) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_MutableSet", "name": "addCheck", "type": "let addCheck: (t('value, 'id), 'value) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_MutableSet", "name": "mergeMany", "type": "let mergeMany: (t('value, 'id), array('value)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"]]}, {"path": "Belt_MutableSet", "name": "remove", "type": "let remove: (t('value, 'id), 'value) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_MutableSet", "name": "removeCheck", "type": "let removeCheck: (t('value, 'id), 'value) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_MutableSet", "name": "removeMany", "type": "let removeMany: (t('value, 'id), array('value)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"]]}, {"path": "Belt_MutableSet", "name": "union", "type": "let union: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "intersect", "type": "let intersect: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "diff", "type": "let diff: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "subset", "type": "let subset: (t('value, 'id), t('value, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "cmp", "type": "let cmp: (t('value, 'id), t('value, 'id)) => int", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "eq", "type": "let eq: (t('value, 'id), t('value, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "forEachU", "type": "let forEachU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value7 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value7 ], unit)"]]}, {"path": "Belt_MutableSet", "name": "forEach", "type": "let forEach: (t('value, 'id), 'value => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> in turn to all elements of <code>m</code>. In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => unit"]]}, {"path": "Belt_MutableSet", "name": "reduceU", "type": "let reduceU: (t('value, 'id), 'a, Js.Internal.fn([ `Arity_2 of 'a62 * 'value6 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a62 * 'value6 ], 'a)"]]}, {"path": "Belt_MutableSet", "name": "reduce", "type": "let reduce: (t('value, 'id), 'a, ('a, 'value) => 'a) => 'a", "docs": "<p>In increasing order.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "('a, 'value) => 'a"]]}, {"path": "Belt_MutableSet", "name": "everyU", "type": "let everyU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value5 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value5 ], bool)"]]}, {"path": "Belt_MutableSet", "name": "every", "type": "let every: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>every s p</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_MutableSet", "name": "someU", "type": "let someU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value4 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value4 ], bool)"]]}, {"path": "Belt_MutableSet", "name": "some", "type": "let some: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_MutableSet", "name": "keepU", "type": "let keepU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value3 ], bool)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value3 ], bool)"]]}, {"path": "Belt_MutableSet", "name": "keep", "type": "let keep: (t('value, 'id), 'value => bool) => t('value, 'id)", "docs": "<p><code>keep s p</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_MutableSet", "name": "partitionU", "type": "let partitionU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value2 ], bool)) => (\n  t('value, 'id),\n  t('value, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value2 ], bool)"]]}, {"path": "Belt_MutableSet", "name": "partition", "type": "let partition: (t('value, 'id), 'value => bool) => (t('value, 'id), t('value, 'id))", "docs": "<p><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt_MutableSet", "name": "size", "type": "let size: t('value, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "toList", "type": "let toList: t('value, 'id) => list('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "toArray", "type": "let toArray: t('value, 'id) => array('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "minimum", "type": "let minimum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "minUndefined", "type": "let minUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "maximum", "type": "let maximum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "maxUndefined", "type": "let maxUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt_MutableSet", "name": "get", "type": "let get: (t('value, 'id), 'value) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_MutableSet", "name": "getUndefined", "type": "let getUndefined: (t('value, 'id), 'value) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_MutableSet", "name": "getExn", "type": "let getExn: (t('value, 'id), 'value) => 'value", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_MutableSet", "name": "split", "type": "let split: (t('value, 'id), 'value) => ((t('value, 'id), t('value, 'id)), bool)", "docs": "<p><code>split s x</code> returns a triple <code>((l, r), present)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>. <code>l,r</code> are freshly made, no sharing with <code>s</code></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt_MutableSet", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_MutableSet", "name": "ofArray", "type": "let ofArray: (array('k), ~id: id('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["id", "id('k, 'id)"]]}, {"path": "Belt_MutableSet", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "", "name": "Belt_MutableSet", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt_MutableQueue", "name": "t", "type": "type t('a)", "docs": "<p>The type of queues containing elements of type <code>&#39;a</code>.</p>\n", "kind": "type"}, {"path": "Belt_MutableQueue", "name": "make", "type": "let make: unit => t('a)", "docs": "<p>Returns: <p>a new queue, initially empty.</p></p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableQueue", "name": "clear", "type": "let clear: t('a) => unit", "docs": "<p>Discard all elements from the queue.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": "<p>Returns: <p><code>true</code> if the given queue is empty, <code>false</code> otherwise.</p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "ofArray", "type": "let ofArray: array('a) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_MutableQueue", "name": "fromArray", "type": "let fromArray: array('a) => t('a)", "docs": "<p><code>fromArray a</code> is equivalent to <code>Array.forEach a (add q a)</code></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_MutableQueue", "name": "add", "type": "let add: (t('a), 'a) => unit", "docs": "<p><code>add q x</code> adds the element <code>x</code> at the end of the queue <code>q</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a"]]}, {"path": "Belt_MutableQueue", "name": "peek", "type": "let peek: t('a) => option('a)", "docs": "<p><code>peekOpt q</code> returns the first element in queue <code>q</code>, without removing it from the queue.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "peekUndefined", "type": "let peekUndefined: t('a) => Js.undefined('a)", "docs": "<p><code>peekUndefined q</code> returns <code>undefined</code> if not found</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "peekExn", "type": "let peekExn: t('a) => 'a", "docs": "<p><code>peekUndefined q</code> returns <code>undefined</code> if not found</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "pop", "type": "let pop: t('a) => option('a)", "docs": "<p><code>pop q</code> removes and returns the first element in queue <code>q</code>.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "popUndefined", "type": "let popUndefined: t('a) => Js.undefined('a)", "docs": "<p><code>popUndefined q</code> removes and returns the first element in queue <code>q</code>. it will return undefined if it is already empty</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "popExn", "type": "let popExn: t('a) => 'a", "docs": "<p><code>popExn q</code></p>\n<p><strong>raise</strong> an exception if <code>q</code> is empty</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": "<p><code>copy q</code></p>\n<p>Returns: <p>a fresh queue</p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "size", "type": "let size: t('a) => int", "docs": "<p>Returns: <p>the number of elements in a queue.</p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a111 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a111 ], 'b)"]]}, {"path": "Belt_MutableQueue", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt_MutableQueue", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_1 of 'a110 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a110 ], unit)"]]}, {"path": "Belt_MutableQueue", "name": "forEach", "type": "let forEach: (t('a), 'a => unit) => unit", "docs": "<p><code>forEach q f</code> applies <code>f</code> in turn to all elements of <code>q</code>, from the least recently entered to the most recently entered. The queue itself is unchanged.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => unit"]]}, {"path": "Belt_MutableQueue", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'b30 * 'a109 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b30 * 'a109 ], 'b)"]]}, {"path": "Belt_MutableQueue", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b", "docs": "<p><code>reduce q accu f</code> is equivalent to <code>List.reduce l accu f</code>, where <code>l</code> is the list of <code>q</code>&#39;s elements. The queue remains unchanged.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt_MutableQueue", "name": "transfer", "type": "let transfer: (t('a), t('a)) => unit", "docs": "<p><code>transfer q1 q2</code> adds all of <code>q1</code>&#39;s elements at the end of the queue <code>q2</code>, then clears <code>q1</code>. It is equivalent to the sequence <code>forEach (fun x -&gt; add x q2) q1; clear q1</code>, but runs in constant time.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt_MutableQueue", "name": "toArray", "type": "let toArray: t('a) => array('a)", "docs": "<p>First added will be in the beginning of the array</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "", "name": "Belt_MutableQueue", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>peek\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>peekExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>peekUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>popExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>popUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>transfer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_MutableMapString", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt_MutableMapString", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Belt_MutableMapString", "name": "make", "type": "let make: unit => t('a)", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableMapString", "name": "clear", "type": "let clear: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "has", "type": "let has: (t('a), key) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapString", "name": "cmpU", "type": "let cmpU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a52 * 'a52 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a52 * 'a52 ], int)"]]}, {"path": "Belt_MutableMapString", "name": "cmp", "type": "let cmp: (t('a), t('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_MutableMapString", "name": "eqU", "type": "let eqU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a51 * 'a51 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a51 * 'a51 ], bool)"]]}, {"path": "Belt_MutableMapString", "name": "eq", "type": "let eq: (t('a), t('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 cmp</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_MutableMapString", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a50 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a50 ], unit)"]]}, {"path": "Belt_MutableMapString", "name": "forEach", "type": "let forEach: (t('a), (key, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The application order of <code>f</code> is in increasing order.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => unit"]]}, {"path": "Belt_MutableMapString", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_3 of 'b12 * key * 'a49 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b12 * key * 'a49 ], 'b)"]]}, {"path": "Belt_MutableMapString", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, key, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, key, 'a) => 'b"]]}, {"path": "Belt_MutableMapString", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a48 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a48 ], bool)"]]}, {"path": "Belt_MutableMapString", "name": "every", "type": "let every: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt_MutableMapString", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a47 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a47 ], bool)"]]}, {"path": "Belt_MutableMapString", "name": "some", "type": "let some: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt_MutableMapString", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "toList", "type": "let toList: t('a) => list((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_MutableMapString", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_MutableMapString", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "minimum", "type": "let minimum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "minUndefined", "type": "let minUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "maximum", "type": "let maximum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "maxUndefined", "type": "let maxUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapString", "name": "getUndefined", "type": "let getUndefined: (t('a), key) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapString", "name": "getWithDefault", "type": "let getWithDefault: (t('a), key, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_MutableMapString", "name": "getExn", "type": "let getExn: (t('a), key) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapString", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapString", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapString", "name": "removeMany", "type": "let removeMany: (t('a), array(key)) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "array(key)"]]}, {"path": "Belt_MutableMapString", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>add m x y</code> do the in-place modification, return <code>m</code> for chaining. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_MutableMapString", "name": "updateU", "type": "let updateU: (t('a), key, Js.Internal.fn([ `Arity_1 of 'a46 option ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'a46 option ], option('a))"]]}, {"path": "Belt_MutableMapString", "name": "update", "type": "let update: (t('a), key, option('a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "option('a) => option('a)"]]}, {"path": "Belt_MutableMapString", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a45 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a45 ], 'b)"]]}, {"path": "Belt_MutableMapString", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt_MutableMapString", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a44 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a44 ], 'b)"]]}, {"path": "Belt_MutableMapString", "name": "mapWithKey", "type": "let mapWithKey: (t('a), (key, 'a) => 'b) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => 'b"]]}, {"path": "", "name": "Belt_MutableMapString", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_MutableMapInt", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt_MutableMapInt", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Belt_MutableMapInt", "name": "make", "type": "let make: unit => t('a)", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableMapInt", "name": "clear", "type": "let clear: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "has", "type": "let has: (t('a), key) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapInt", "name": "cmpU", "type": "let cmpU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a61 * 'a61 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a61 * 'a61 ], int)"]]}, {"path": "Belt_MutableMapInt", "name": "cmp", "type": "let cmp: (t('a), t('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_MutableMapInt", "name": "eqU", "type": "let eqU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a60 * 'a60 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a60 * 'a60 ], bool)"]]}, {"path": "Belt_MutableMapInt", "name": "eq", "type": "let eq: (t('a), t('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 cmp</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_MutableMapInt", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a59 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a59 ], unit)"]]}, {"path": "Belt_MutableMapInt", "name": "forEach", "type": "let forEach: (t('a), (key, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The application order of <code>f</code> is in increasing order.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => unit"]]}, {"path": "Belt_MutableMapInt", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_3 of 'b13 * key * 'a58 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b13 * key * 'a58 ], 'b)"]]}, {"path": "Belt_MutableMapInt", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, key, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, key, 'a) => 'b"]]}, {"path": "Belt_MutableMapInt", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a57 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a57 ], bool)"]]}, {"path": "Belt_MutableMapInt", "name": "every", "type": "let every: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt_MutableMapInt", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a56 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a56 ], bool)"]]}, {"path": "Belt_MutableMapInt", "name": "some", "type": "let some: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt_MutableMapInt", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "toList", "type": "let toList: t('a) => list((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_MutableMapInt", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_MutableMapInt", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "minimum", "type": "let minimum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "minUndefined", "type": "let minUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "maximum", "type": "let maximum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "maxUndefined", "type": "let maxUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapInt", "name": "getUndefined", "type": "let getUndefined: (t('a), key) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapInt", "name": "getWithDefault", "type": "let getWithDefault: (t('a), key, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_MutableMapInt", "name": "getExn", "type": "let getExn: (t('a), key) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapInt", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMapInt", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMapInt", "name": "removeMany", "type": "let removeMany: (t('a), array(key)) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "array(key)"]]}, {"path": "Belt_MutableMapInt", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>add m x y</code> do the in-place modification, return <code>m</code> for chaining. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_MutableMapInt", "name": "updateU", "type": "let updateU: (t('a), key, Js.Internal.fn([ `Arity_1 of 'a55 option ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'a55 option ], option('a))"]]}, {"path": "Belt_MutableMapInt", "name": "update", "type": "let update: (t('a), key, option('a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "option('a) => option('a)"]]}, {"path": "Belt_MutableMapInt", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a54 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a54 ], 'b)"]]}, {"path": "Belt_MutableMapInt", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt_MutableMapInt", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a53 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a53 ], 'b)"]]}, {"path": "Belt_MutableMapInt", "name": "mapWithKey", "type": "let mapWithKey: (t('a), (key, 'a) => 'b) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => 'b"]]}, {"path": "", "name": "Belt_MutableMapInt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_MutableMap.Int", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt_MutableMap.Int", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Belt_MutableMap.Int", "name": "make", "type": "let make: unit => t('a)", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableMap.Int", "name": "clear", "type": "let clear: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "has", "type": "let has: (t('a), key) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.Int", "name": "cmpU", "type": "let cmpU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a61 * 'a61 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a61 * 'a61 ], int)"]]}, {"path": "Belt_MutableMap.Int", "name": "cmp", "type": "let cmp: (t('a), t('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_MutableMap.Int", "name": "eqU", "type": "let eqU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a60 * 'a60 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a60 * 'a60 ], bool)"]]}, {"path": "Belt_MutableMap.Int", "name": "eq", "type": "let eq: (t('a), t('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 cmp</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_MutableMap.Int", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a59 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a59 ], unit)"]]}, {"path": "Belt_MutableMap.Int", "name": "forEach", "type": "let forEach: (t('a), (key, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The application order of <code>f</code> is in increasing order.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => unit"]]}, {"path": "Belt_MutableMap.Int", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_3 of 'b13 * key * 'a58 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b13 * key * 'a58 ], 'b)"]]}, {"path": "Belt_MutableMap.Int", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, key, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, key, 'a) => 'b"]]}, {"path": "Belt_MutableMap.Int", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a57 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a57 ], bool)"]]}, {"path": "Belt_MutableMap.Int", "name": "every", "type": "let every: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt_MutableMap.Int", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a56 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a56 ], bool)"]]}, {"path": "Belt_MutableMap.Int", "name": "some", "type": "let some: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt_MutableMap.Int", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "toList", "type": "let toList: t('a) => list((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_MutableMap.Int", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_MutableMap.Int", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "minimum", "type": "let minimum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "minUndefined", "type": "let minUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "maximum", "type": "let maximum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "maxUndefined", "type": "let maxUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.Int", "name": "getUndefined", "type": "let getUndefined: (t('a), key) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.Int", "name": "getWithDefault", "type": "let getWithDefault: (t('a), key, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_MutableMap.Int", "name": "getExn", "type": "let getExn: (t('a), key) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.Int", "name": "removeMany", "type": "let removeMany: (t('a), array(key)) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "array(key)"]]}, {"path": "Belt_MutableMap.Int", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>add m x y</code> do the in-place modification, return <code>m</code> for chaining. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_MutableMap.Int", "name": "updateU", "type": "let updateU: (t('a), key, Js.Internal.fn([ `Arity_1 of 'a55 option ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'a55 option ], option('a))"]]}, {"path": "Belt_MutableMap.Int", "name": "update", "type": "let update: (t('a), key, option('a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "option('a) => option('a)"]]}, {"path": "Belt_MutableMap.Int", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a54 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a54 ], 'b)"]]}, {"path": "Belt_MutableMap.Int", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt_MutableMap.Int", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a53 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a53 ], 'b)"]]}, {"path": "Belt_MutableMap.Int", "name": "mapWithKey", "type": "let mapWithKey: (t('a), (key, 'a) => 'b) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => 'b"]]}, {"path": "Belt_MutableMap", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_MutableMap.String", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt_MutableMap.String", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Belt_MutableMap.String", "name": "make", "type": "let make: unit => t('a)", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt_MutableMap.String", "name": "clear", "type": "let clear: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "has", "type": "let has: (t('a), key) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.String", "name": "cmpU", "type": "let cmpU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a52 * 'a52 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a52 * 'a52 ], int)"]]}, {"path": "Belt_MutableMap.String", "name": "cmp", "type": "let cmp: (t('a), t('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_MutableMap.String", "name": "eqU", "type": "let eqU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a51 * 'a51 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a51 * 'a51 ], bool)"]]}, {"path": "Belt_MutableMap.String", "name": "eq", "type": "let eq: (t('a), t('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 cmp</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_MutableMap.String", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a50 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a50 ], unit)"]]}, {"path": "Belt_MutableMap.String", "name": "forEach", "type": "let forEach: (t('a), (key, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The application order of <code>f</code> is in increasing order.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => unit"]]}, {"path": "Belt_MutableMap.String", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_3 of 'b12 * key * 'a49 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b12 * key * 'a49 ], 'b)"]]}, {"path": "Belt_MutableMap.String", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, key, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, key, 'a) => 'b"]]}, {"path": "Belt_MutableMap.String", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a48 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a48 ], bool)"]]}, {"path": "Belt_MutableMap.String", "name": "every", "type": "let every: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt_MutableMap.String", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a47 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a47 ], bool)"]]}, {"path": "Belt_MutableMap.String", "name": "some", "type": "let some: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt_MutableMap.String", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "toList", "type": "let toList: t('a) => list((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_MutableMap.String", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_MutableMap.String", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "minimum", "type": "let minimum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "minUndefined", "type": "let minUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "maximum", "type": "let maximum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "maxUndefined", "type": "let maxUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.String", "name": "getUndefined", "type": "let getUndefined: (t('a), key) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.String", "name": "getWithDefault", "type": "let getWithDefault: (t('a), key, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_MutableMap.String", "name": "getExn", "type": "let getExn: (t('a), key) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MutableMap.String", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_MutableMap.String", "name": "removeMany", "type": "let removeMany: (t('a), array(key)) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "array(key)"]]}, {"path": "Belt_MutableMap.String", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>add m x y</code> do the in-place modification, return <code>m</code> for chaining. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_MutableMap.String", "name": "updateU", "type": "let updateU: (t('a), key, Js.Internal.fn([ `Arity_1 of 'a46 option ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'a46 option ], option('a))"]]}, {"path": "Belt_MutableMap.String", "name": "update", "type": "let update: (t('a), key, option('a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "option('a) => option('a)"]]}, {"path": "Belt_MutableMap.String", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a45 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a45 ], 'b)"]]}, {"path": "Belt_MutableMap.String", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt_MutableMap.String", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a44 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a44 ], 'b)"]]}, {"path": "Belt_MutableMap.String", "name": "mapWithKey", "type": "let mapWithKey: (t('a), (key, 'a) => 'b) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => 'b"]]}, {"path": "Belt_MutableMap", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_MutableMap", "name": "t", "type": "type t('k, 'v, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_MutableMap", "name": "id", "type": "type id('key, 'id) = Belt_Id.comparable('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_MutableMap", "name": "make", "type": "let make: (~id: id('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["id", "id('k, 'id)"]]}, {"path": "Belt_MutableMap", "name": "clear", "type": "let clear: t('a, 'a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "isEmpty", "type": "let isEmpty: t('a, 'a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "has", "type": "let has: (t('k, 'a, 'a), 'k) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"], ["", "'k"]]}, {"path": "Belt_MutableMap", "name": "cmpU", "type": "let cmpU: (t('k, 'a, 'id), t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'a43 * 'a43 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'a43 * 'a43 ], int)"]]}, {"path": "Belt_MutableMap", "name": "cmp", "type": "let cmp: (t('k, 'a, 'id), t('k, 'a, 'id), ('a, 'a) => int) => int", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_MutableMap", "name": "eqU", "type": "let eqU: (t('k, 'a, 'id), t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'a42 * 'a42 ], bool)) => bool", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'a42 * 'a42 ], bool)"]]}, {"path": "Belt_MutableMap", "name": "eq", "type": "let eq: (t('k, 'a, 'id), t('k, 'a, 'id), ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 eqf</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>eqf</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_MutableMap", "name": "forEachU", "type": "let forEachU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k4 * 'a41 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k4 * 'a41 ], unit)"]]}, {"path": "Belt_MutableMap", "name": "forEach", "type": "let forEach: (t('k, 'a, 'id), ('k, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the &#39;k as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => unit"]]}, {"path": "Belt_MutableMap", "name": "reduceU", "type": "let reduceU: (t('k, 'a, 'id), 'b, Js.Internal.fn([ `Arity_3 of 'b11 * 'k3 * 'a40 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b11 * 'k3 * 'a40 ], 'b)"]]}, {"path": "Belt_MutableMap", "name": "reduce", "type": "let reduce: (t('k, 'a, 'id), 'b, ('b, 'k, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "('b, 'k, 'a) => 'b"]]}, {"path": "Belt_MutableMap", "name": "everyU", "type": "let everyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k2 * 'a39 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k2 * 'a39 ], bool)"]]}, {"path": "Belt_MutableMap", "name": "every", "type": "let every: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_MutableMap", "name": "someU", "type": "let someU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k1 * 'a38 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k1 * 'a38 ], bool)"]]}, {"path": "Belt_MutableMap", "name": "some", "type": "let some: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_MutableMap", "name": "size", "type": "let size: t('k, 'a, 'id) => int", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_MutableMap", "name": "toList", "type": "let toList: t('k, 'a, 'id) => list(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_MutableMap", "name": "toArray", "type": "let toArray: t('k, 'a, 'id) => array(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_MutableMap", "name": "fromArray", "type": "let fromArray: (array(('k, 'a)), ~id: id('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["id", "id('k, 'id)"]]}, {"path": "Belt_MutableMap", "name": "keysToArray", "type": "let keysToArray: t('k, 'a, 'a) => array('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "valuesToArray", "type": "let valuesToArray: t('a, 'a, 'a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "minKey", "type": "let minKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "maxKey", "type": "let maxKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "minimum", "type": "let minimum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "minUndefined", "type": "let minUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "maximum", "type": "let maximum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "maxUndefined", "type": "let maxUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "get", "type": "let get: (t('k, 'a, 'id), 'k) => option('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"]]}, {"path": "Belt_MutableMap", "name": "getUndefined", "type": "let getUndefined: (t('k, 'a, 'id), 'k) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"]]}, {"path": "Belt_MutableMap", "name": "getWithDefault", "type": "let getWithDefault: (t('k, 'a, 'id), 'k, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "'a"]]}, {"path": "Belt_MutableMap", "name": "getExn", "type": "let getExn: (t('k, 'a, 'id), 'k) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"]]}, {"path": "Belt_MutableMap", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_MutableMap", "name": "ofArray", "type": "let ofArray: (array(('k, 'a)), ~id: id('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["id", "id('k, 'id)"]]}, {"path": "Belt_MutableMap", "name": "remove", "type": "let remove: (t('k, 'a, 'id), 'k) => unit", "docs": "<p><code>remove m x</code> do the in-place modification,</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"]]}, {"path": "Belt_MutableMap", "name": "removeMany", "type": "let removeMany: (t('k, 'a, 'id), array('k)) => unit", "docs": "<p><code>remove m x</code> do the in-place modification,</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "array('k)"]]}, {"path": "Belt_MutableMap", "name": "set", "type": "let set: (t('k, 'a, 'id), 'k, 'a) => unit", "docs": "<p><code>set m x y </code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "'a"]]}, {"path": "Belt_MutableMap", "name": "updateU", "type": "let updateU: (t('k, 'a, 'id), 'k, Js.Internal.fn([ `Arity_1 of 'a37 option ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "Js.Internal.fn([ `Arity_1 of 'a37 option ], option('a))"]]}, {"path": "Belt_MutableMap", "name": "update", "type": "let update: (t('k, 'a, 'id), 'k, option('a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "option('a) => option('a)"]]}, {"path": "Belt_MutableMap", "name": "mergeMany", "type": "let mergeMany: (t('k, 'a, 'id), array(('k, 'a))) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "array(('k, 'a))"]]}, {"path": "Belt_MutableMap", "name": "mapU", "type": "let mapU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_1 of 'a36 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'a36 ], 'b)"]]}, {"path": "Belt_MutableMap", "name": "map", "type": "let map: (t('k, 'a, 'id), 'a => 'b) => t('k, 'b, 'id)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'a => 'b"]]}, {"path": "Belt_MutableMap", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k0 * 'a35 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k0 * 'a35 ], 'b)"]]}, {"path": "Belt_MutableMap", "name": "mapWithKey", "type": "let mapWithKey: (t('k, 'a, 'id), ('k, 'a) => 'b) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => 'b"]]}, {"path": "", "name": "Belt_MutableMap", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt_MapString", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt_MapString", "name": "t", "type": "type t('value)", "docs": "<p>The type of maps from type <code>key</code> to type <code>&#39;value</code>.</p>\n", "kind": "type"}, {"path": "Belt_MapString", "name": "empty", "type": "let empty: t('v)", "docs": null, "kind": "value"}, {"path": "Belt_MapString", "name": "isEmpty", "type": "let isEmpty: t('v) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "has", "type": "let has: (t('v), key) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapString", "name": "cmpU", "type": "let cmpU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v26 * 'v26 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v26 * 'v26 ], int)"]]}, {"path": "Belt_MapString", "name": "cmp", "type": "let cmp: (t('v), t('v), ('v, 'v) => int) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => int"]]}, {"path": "Belt_MapString", "name": "eqU", "type": "let eqU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v25 * 'v25 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v25 * 'v25 ], bool)"]]}, {"path": "Belt_MapString", "name": "eq", "type": "let eq: (t('v), t('v), ('v, 'v) => bool) => bool", "docs": "<p><code>equal m1 m2 cmp</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => bool"]]}, {"path": "Belt_MapString", "name": "forEachU", "type": "let forEachU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v24 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v24 ], unit)"]]}, {"path": "Belt_MapString", "name": "forEach", "type": "let forEach: (t('v), (key, 'v) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => unit"]]}, {"path": "Belt_MapString", "name": "reduceU", "type": "let reduceU: (t('v), 'v2, Js.Internal.fn([ `Arity_3 of 'v22 * key * 'v23 ], 'v2)) => 'v2", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "Js.Internal.fn([ `Arity_3 of 'v22 * key * 'v23 ], 'v2)"]]}, {"path": "Belt_MapString", "name": "reduce", "type": "let reduce: (t('v), 'v2, ('v2, key, 'v) => 'v2) => 'v2", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "('v2, key, 'v) => 'v2"]]}, {"path": "Belt_MapString", "name": "everyU", "type": "let everyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v19 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v19 ], bool)"]]}, {"path": "Belt_MapString", "name": "every", "type": "let every: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_MapString", "name": "someU", "type": "let someU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v18 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v18 ], bool)"]]}, {"path": "Belt_MapString", "name": "some", "type": "let some: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_MapString", "name": "size", "type": "let size: t('v) => int", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "toList", "type": "let toList: t('v) => list((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "toArray", "type": "let toArray: t('v) => array((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "ofArray", "type": "let ofArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt_MapString", "name": "fromArray", "type": "let fromArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt_MapString", "name": "keysToArray", "type": "let keysToArray: t('v) => array(key)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "valuesToArray", "type": "let valuesToArray: t('v) => array('v)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapString", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapString", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapString", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapString", "name": "minimum", "type": "let minimum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "minUndefined", "type": "let minUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "maximum", "type": "let maximum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "maxUndefined", "type": "let maxUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapString", "name": "get", "type": "let get: (t('v), key) => option('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapString", "name": "getUndefined", "type": "let getUndefined: (t('v), key) => Js.undefined('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapString", "name": "getWithDefault", "type": "let getWithDefault: (t('v), key, 'v) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt_MapString", "name": "getExn", "type": "let getExn: (t('v), key) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapString", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapString", "name": "remove", "type": "let remove: (t('v), key) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapString", "name": "removeMany", "type": "let removeMany: (t('v), array(key)) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "array(key)"]]}, {"path": "Belt_MapString", "name": "set", "type": "let set: (t('v), key, 'v) => t('v)", "docs": "<p><code>add m x y</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt_MapString", "name": "updateU", "type": "let updateU: (t('v), key, Js.Internal.fn([ `Arity_1 of 'v17 option ], option('v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'v17 option ], option('v))"]]}, {"path": "Belt_MapString", "name": "update", "type": "let update: (t('v), key, option('v) => option('v)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "option('v) => option('v)"]]}, {"path": "Belt_MapString", "name": "mergeArray", "type": "let mergeArray: (t('v), array((key, 'v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "array((key, 'v))"]]}, {"path": "Belt_MapString", "name": "mergeU", "type": "let mergeU: (\n  t('v),\n  t('v2),\n  Js.Internal.fn([ `Arity_3 of key * 'v16 option * 'v21 option ], option('c))\n) => t('c)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "Js.Internal.fn([ `Arity_3 of key * 'v16 option * 'v21 option ], option('c))"]]}, {"path": "Belt_MapString", "name": "merge", "type": "let merge: (t('v), t('v2), (key, option('v), option('v2)) => option('c)) => t('c)", "docs": "<p><code>merge m1 m2 f</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "(key, option('v), option('v2)) => option('c)"]]}, {"path": "Belt_MapString", "name": "keepU", "type": "let keepU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v15 ], bool)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v15 ], bool)"]]}, {"path": "Belt_MapString", "name": "keep", "type": "let keep: (t('v), (key, 'v) => bool) => t('v)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_MapString", "name": "partitionU", "type": "let partitionU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v14 ], bool)) => (t('v), t('v))", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v14 ], bool)"]]}, {"path": "Belt_MapString", "name": "partition", "type": "let partition: (t('v), (key, 'v) => bool) => (t('v), t('v))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_MapString", "name": "split", "type": "let split: (key, t('v)) => (t('v), option('v), t('v))", "docs": "<p><code>split x m</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p>\n", "kind": "value", "args": [["", "key"], ["", "t('v)"]]}, {"path": "Belt_MapString", "name": "mapU", "type": "let mapU: (t('v), Js.Internal.fn([ `Arity_1 of 'v13 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_1 of 'v13 ], 'v2)"]]}, {"path": "Belt_MapString", "name": "map", "type": "let map: (t('v), 'v => 'v2) => t('v2)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v => 'v2"]]}, {"path": "Belt_MapString", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v12 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v12 ], 'v2)"]]}, {"path": "Belt_MapString", "name": "mapWithKey", "type": "let mapWithKey: (t('v), (key, 'v) => 'v2) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => 'v2"]]}, {"path": "Belt_MapString", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "", "name": "Belt_MapString", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_MapInt", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt_MapInt", "name": "t", "type": "type t('value)", "docs": "<p>The type of maps from type <code>key</code> to type <code>&#39;value</code>.</p>\n", "kind": "type"}, {"path": "Belt_MapInt", "name": "empty", "type": "let empty: t('v)", "docs": null, "kind": "value"}, {"path": "Belt_MapInt", "name": "isEmpty", "type": "let isEmpty: t('v) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "has", "type": "let has: (t('v), key) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapInt", "name": "cmpU", "type": "let cmpU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v38 * 'v38 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v38 * 'v38 ], int)"]]}, {"path": "Belt_MapInt", "name": "cmp", "type": "let cmp: (t('v), t('v), ('v, 'v) => int) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => int"]]}, {"path": "Belt_MapInt", "name": "eqU", "type": "let eqU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v37 * 'v37 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v37 * 'v37 ], bool)"]]}, {"path": "Belt_MapInt", "name": "eq", "type": "let eq: (t('v), t('v), ('v, 'v) => bool) => bool", "docs": "<p><code>equal m1 m2 cmp</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => bool"]]}, {"path": "Belt_MapInt", "name": "forEachU", "type": "let forEachU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v36 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v36 ], unit)"]]}, {"path": "Belt_MapInt", "name": "forEach", "type": "let forEach: (t('v), (key, 'v) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => unit"]]}, {"path": "Belt_MapInt", "name": "reduceU", "type": "let reduceU: (t('v), 'v2, Js.Internal.fn([ `Arity_3 of 'v211 * key * 'v35 ], 'v2)) => 'v2", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "Js.Internal.fn([ `Arity_3 of 'v211 * key * 'v35 ], 'v2)"]]}, {"path": "Belt_MapInt", "name": "reduce", "type": "let reduce: (t('v), 'v2, ('v2, key, 'v) => 'v2) => 'v2", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "('v2, key, 'v) => 'v2"]]}, {"path": "Belt_MapInt", "name": "everyU", "type": "let everyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v34 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v34 ], bool)"]]}, {"path": "Belt_MapInt", "name": "every", "type": "let every: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_MapInt", "name": "someU", "type": "let someU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v33 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v33 ], bool)"]]}, {"path": "Belt_MapInt", "name": "some", "type": "let some: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_MapInt", "name": "size", "type": "let size: t('v) => int", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "toList", "type": "let toList: t('v) => list((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "toArray", "type": "let toArray: t('v) => array((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "ofArray", "type": "let ofArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt_MapInt", "name": "fromArray", "type": "let fromArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt_MapInt", "name": "keysToArray", "type": "let keysToArray: t('v) => array(key)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "valuesToArray", "type": "let valuesToArray: t('v) => array('v)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapInt", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapInt", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapInt", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapInt", "name": "minimum", "type": "let minimum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "minUndefined", "type": "let minUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "maximum", "type": "let maximum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "maxUndefined", "type": "let maxUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "get", "type": "let get: (t('v), key) => option('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapInt", "name": "getUndefined", "type": "let getUndefined: (t('v), key) => Js.undefined('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapInt", "name": "getWithDefault", "type": "let getWithDefault: (t('v), key, 'v) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt_MapInt", "name": "getExn", "type": "let getExn: (t('v), key) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapInt", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_MapInt", "name": "remove", "type": "let remove: (t('v), key) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_MapInt", "name": "removeMany", "type": "let removeMany: (t('v), array(key)) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "array(key)"]]}, {"path": "Belt_MapInt", "name": "set", "type": "let set: (t('v), key, 'v) => t('v)", "docs": "<p><code>add m x y</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt_MapInt", "name": "updateU", "type": "let updateU: (t('v), key, Js.Internal.fn([ `Arity_1 of 'v32 option ], option('v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'v32 option ], option('v))"]]}, {"path": "Belt_MapInt", "name": "update", "type": "let update: (t('v), key, option('v) => option('v)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "option('v) => option('v)"]]}, {"path": "Belt_MapInt", "name": "mergeArray", "type": "let mergeArray: (t('v), array((key, 'v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "array((key, 'v))"]]}, {"path": "Belt_MapInt", "name": "mergeU", "type": "let mergeU: (\n  t('v),\n  t('v2),\n  Js.Internal.fn([ `Arity_3 of key * 'v31 option * 'v210 option ], option('c))\n) => t('c)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "Js.Internal.fn([ `Arity_3 of key * 'v31 option * 'v210 option ], option('c))"]]}, {"path": "Belt_MapInt", "name": "merge", "type": "let merge: (t('v), t('v2), (key, option('v), option('v2)) => option('c)) => t('c)", "docs": "<p><code>merge m1 m2 f</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "(key, option('v), option('v2)) => option('c)"]]}, {"path": "Belt_MapInt", "name": "keepU", "type": "let keepU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v30 ], bool)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v30 ], bool)"]]}, {"path": "Belt_MapInt", "name": "keep", "type": "let keep: (t('v), (key, 'v) => bool) => t('v)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_MapInt", "name": "partitionU", "type": "let partitionU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v29 ], bool)) => (t('v), t('v))", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v29 ], bool)"]]}, {"path": "Belt_MapInt", "name": "partition", "type": "let partition: (t('v), (key, 'v) => bool) => (t('v), t('v))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_MapInt", "name": "split", "type": "let split: (key, t('v)) => (t('v), option('v), t('v))", "docs": "<p><code>split x m</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p>\n", "kind": "value", "args": [["", "key"], ["", "t('v)"]]}, {"path": "Belt_MapInt", "name": "mapU", "type": "let mapU: (t('v), Js.Internal.fn([ `Arity_1 of 'v28 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_1 of 'v28 ], 'v2)"]]}, {"path": "Belt_MapInt", "name": "map", "type": "let map: (t('v), 'v => 'v2) => t('v2)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v => 'v2"]]}, {"path": "Belt_MapInt", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v27 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v27 ], 'v2)"]]}, {"path": "Belt_MapInt", "name": "mapWithKey", "type": "let mapWithKey: (t('v), (key, 'v) => 'v2) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => 'v2"]]}, {"path": "Belt_MapInt", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "", "name": "Belt_MapInt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_MapDict", "name": "t", "type": "type t('key, 'value, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_MapDict", "name": "cmp", "type": "type cmp('key, 'id) = Belt_Id.cmp('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_MapDict", "name": "empty", "type": "let empty: t('k, 'v, 'id)", "docs": null, "kind": "value"}, {"path": "Belt_MapDict", "name": "isEmpty", "type": "let isEmpty: t('k, 'v, 'id) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt_MapDict", "name": "has", "type": "let has: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_MapDict", "name": "cmpU", "type": "let cmpU: (\n  t('k, 'v, 'id),\n  t('k, 'v, 'id),\n  ~kcmp: cmp('k, 'id),\n  ~vcmp: Js.Internal.fn([ `Arity_2 of 'v11 * 'v11 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["kcmp", "cmp('k, 'id)"], ["vcmp", "Js.Internal.fn([ `Arity_2 of 'v11 * 'v11 ], int)"]]}, {"path": "Belt_MapDict", "name": "cmp", "type": "let cmp: (t('k, 'v, 'id), t('k, 'v, 'id), ~kcmp: cmp('k, 'id), ~vcmp: ('v, 'v) => int) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["kcmp", "cmp('k, 'id)"], ["vcmp", "('v, 'v) => int"]]}, {"path": "Belt_MapDict", "name": "eqU", "type": "let eqU: (\n  t('k, 'a, 'id),\n  t('k, 'a, 'id),\n  ~kcmp: cmp('k, 'id),\n  ~veq: Js.Internal.fn([ `Arity_2 of 'a74 * 'a74 ], bool)\n) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["kcmp", "cmp('k, 'id)"], ["veq", "Js.Internal.fn([ `Arity_2 of 'a74 * 'a74 ], bool)"]]}, {"path": "Belt_MapDict", "name": "eq", "type": "let eq: (t('k, 'a, 'id), t('k, 'a, 'id), ~kcmp: cmp('k, 'id), ~veq: ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 cmp</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["kcmp", "cmp('k, 'id)"], ["veq", "('a, 'a) => bool"]]}, {"path": "Belt_MapDict", "name": "forEachU", "type": "let forEachU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k19 * 'a73 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k19 * 'a73 ], unit)"]]}, {"path": "Belt_MapDict", "name": "forEach", "type": "let forEach: (t('k, 'a, 'id), ('k, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the &#39;k as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => unit"]]}, {"path": "Belt_MapDict", "name": "reduceU", "type": "let reduceU: (t('k, 'a, 'id), 'b, Js.Internal.fn([ `Arity_3 of 'b16 * 'k18 * 'a72 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b16 * 'k18 * 'a72 ], 'b)"]]}, {"path": "Belt_MapDict", "name": "reduce", "type": "let reduce: (t('k, 'a, 'id), 'b, ('b, 'k, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "('b, 'k, 'a) => 'b"]]}, {"path": "Belt_MapDict", "name": "everyU", "type": "let everyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k17 * 'a71 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k17 * 'a71 ], bool)"]]}, {"path": "Belt_MapDict", "name": "every", "type": "let every: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_MapDict", "name": "someU", "type": "let someU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k16 * 'a70 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k16 * 'a70 ], bool)"]]}, {"path": "Belt_MapDict", "name": "some", "type": "let some: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_MapDict", "name": "size", "type": "let size: t('k, 'a, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_MapDict", "name": "toList", "type": "let toList: t('k, 'a, 'id) => list(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_MapDict", "name": "toArray", "type": "let toArray: t('k, 'a, 'id) => array(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_MapDict", "name": "ofArray", "type": "let ofArray: (array(('k, 'a)), ~cmp: cmp('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_MapDict", "name": "fromArray", "type": "let fromArray: (array(('k, 'a)), ~cmp: cmp('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_MapDict", "name": "keysToArray", "type": "let keysToArray: t('k, 'a, 'id) => array('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_MapDict", "name": "valuesToArray", "type": "let valuesToArray: t('k, 'a, 'id) => array('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_MapDict", "name": "minKey", "type": "let minKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MapDict", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MapDict", "name": "maxKey", "type": "let maxKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MapDict", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MapDict", "name": "minimum", "type": "let minimum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MapDict", "name": "minUndefined", "type": "let minUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MapDict", "name": "maximum", "type": "let maximum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MapDict", "name": "maxUndefined", "type": "let maxUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_MapDict", "name": "get", "type": "let get: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => option('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_MapDict", "name": "getUndefined", "type": "let getUndefined: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_MapDict", "name": "getWithDefault", "type": "let getWithDefault: (t('k, 'a, 'id), 'k, 'a, ~cmp: cmp('k, 'id)) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "'a"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_MapDict", "name": "getExn", "type": "let getExn: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_MapDict", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_MapDict", "name": "remove", "type": "let remove: (t('a, 'b, 'id), 'a, ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_MapDict", "name": "removeMany", "type": "let removeMany: (t('a, 'b, 'id), array('a), ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "array('a)"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_MapDict", "name": "set", "type": "let set: (t('a, 'b, 'id), 'a, 'b, ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["", "'b"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_MapDict", "name": "updateU", "type": "let updateU: (\n  t('a, 'b, 'id),\n  'a,\n  Js.Internal.fn([ `Arity_1 of 'b15 option ], option('b)),\n  ~cmp: cmp('a, 'id)\n) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_1 of 'b15 option ], option('b))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_MapDict", "name": "update", "type": "let update: (t('a, 'b, 'id), 'a, option('b) => option('b), ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["", "option('b) => option('b)"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_MapDict", "name": "mergeU", "type": "let mergeU: (\n  t('a, 'b, 'id),\n  t('a, 'c, 'id),\n  Js.Internal.fn([ `Arity_3 of 'a69 * 'b14 option * 'c6 option ], option('d)),\n  ~cmp: cmp('a, 'id)\n) => t('a, 'd, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "t('a, 'c, 'id)"], ["", "Js.Internal.fn([ `Arity_3 of 'a69 * 'b14 option * 'c6 option ], option('d))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_MapDict", "name": "merge", "type": "let merge: (\n  t('a, 'b, 'id),\n  t('a, 'c, 'id),\n  ('a, option('b), option('c)) => option('d),\n  ~cmp: cmp('a, 'id)\n) => t('a, 'd, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "t('a, 'c, 'id)"], ["", "('a, option('b), option('c)) => option('d)"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_MapDict", "name": "mergeMany", "type": "let mergeMany: (t('a, 'b, 'id), array(('a, 'b)), ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "array(('a, 'b))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_MapDict", "name": "keepU", "type": "let keepU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k15 * 'a68 ], bool)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k15 * 'a68 ], bool)"]]}, {"path": "Belt_MapDict", "name": "keep", "type": "let keep: (t('k, 'a, 'id), ('k, 'a) => bool) => t('k, 'a, 'id)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_MapDict", "name": "partitionU", "type": "let partitionU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k14 * 'a67 ], bool)) => (\n  t('k, 'a, 'id),\n  t('k, 'a, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k14 * 'a67 ], bool)"]]}, {"path": "Belt_MapDict", "name": "partition", "type": "let partition: (t('k, 'a, 'id), ('k, 'a) => bool) => (t('k, 'a, 'id), t('k, 'a, 'id))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_MapDict", "name": "split", "type": "let split: (t('a, 'b, 'id), 'a, ~cmp: cmp('a, 'id)) => (\n  (t('a, 'b, 'id), t('a, 'b, 'id)),\n  option('b)\n)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_MapDict", "name": "mapU", "type": "let mapU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_1 of 'a66 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'a66 ], 'b)"]]}, {"path": "Belt_MapDict", "name": "map", "type": "let map: (t('k, 'a, 'id), 'a => 'b) => t('k, 'b, 'id)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'a => 'b"]]}, {"path": "Belt_MapDict", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k13 * 'a65 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k13 * 'a65 ], 'b)"]]}, {"path": "Belt_MapDict", "name": "mapWithKey", "type": "let mapWithKey: (t('k, 'a, 'id), ('k, 'a) => 'b) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => 'b"]]}, {"path": "", "name": "Belt_MapDict", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_Map.Int", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt_Map.Int", "name": "t", "type": "type t('value)", "docs": "<p>The type of maps from type <code>key</code> to type <code>&#39;value</code>.</p>\n", "kind": "type"}, {"path": "Belt_Map.Int", "name": "empty", "type": "let empty: t('v)", "docs": null, "kind": "value"}, {"path": "Belt_Map.Int", "name": "isEmpty", "type": "let isEmpty: t('v) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "has", "type": "let has: (t('v), key) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.Int", "name": "cmpU", "type": "let cmpU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v38 * 'v38 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v38 * 'v38 ], int)"]]}, {"path": "Belt_Map.Int", "name": "cmp", "type": "let cmp: (t('v), t('v), ('v, 'v) => int) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => int"]]}, {"path": "Belt_Map.Int", "name": "eqU", "type": "let eqU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v37 * 'v37 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v37 * 'v37 ], bool)"]]}, {"path": "Belt_Map.Int", "name": "eq", "type": "let eq: (t('v), t('v), ('v, 'v) => bool) => bool", "docs": "<p><code>equal m1 m2 cmp</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => bool"]]}, {"path": "Belt_Map.Int", "name": "forEachU", "type": "let forEachU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v36 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v36 ], unit)"]]}, {"path": "Belt_Map.Int", "name": "forEach", "type": "let forEach: (t('v), (key, 'v) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => unit"]]}, {"path": "Belt_Map.Int", "name": "reduceU", "type": "let reduceU: (t('v), 'v2, Js.Internal.fn([ `Arity_3 of 'v211 * key * 'v35 ], 'v2)) => 'v2", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "Js.Internal.fn([ `Arity_3 of 'v211 * key * 'v35 ], 'v2)"]]}, {"path": "Belt_Map.Int", "name": "reduce", "type": "let reduce: (t('v), 'v2, ('v2, key, 'v) => 'v2) => 'v2", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "('v2, key, 'v) => 'v2"]]}, {"path": "Belt_Map.Int", "name": "everyU", "type": "let everyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v34 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v34 ], bool)"]]}, {"path": "Belt_Map.Int", "name": "every", "type": "let every: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_Map.Int", "name": "someU", "type": "let someU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v33 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v33 ], bool)"]]}, {"path": "Belt_Map.Int", "name": "some", "type": "let some: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_Map.Int", "name": "size", "type": "let size: t('v) => int", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "toList", "type": "let toList: t('v) => list((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "toArray", "type": "let toArray: t('v) => array((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "ofArray", "type": "let ofArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt_Map.Int", "name": "fromArray", "type": "let fromArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt_Map.Int", "name": "keysToArray", "type": "let keysToArray: t('v) => array(key)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "valuesToArray", "type": "let valuesToArray: t('v) => array('v)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.Int", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.Int", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.Int", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.Int", "name": "minimum", "type": "let minimum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "minUndefined", "type": "let minUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "maximum", "type": "let maximum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "maxUndefined", "type": "let maxUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "get", "type": "let get: (t('v), key) => option('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.Int", "name": "getUndefined", "type": "let getUndefined: (t('v), key) => Js.undefined('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.Int", "name": "getWithDefault", "type": "let getWithDefault: (t('v), key, 'v) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt_Map.Int", "name": "getExn", "type": "let getExn: (t('v), key) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.Int", "name": "remove", "type": "let remove: (t('v), key) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.Int", "name": "removeMany", "type": "let removeMany: (t('v), array(key)) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "array(key)"]]}, {"path": "Belt_Map.Int", "name": "set", "type": "let set: (t('v), key, 'v) => t('v)", "docs": "<p><code>add m x y</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt_Map.Int", "name": "updateU", "type": "let updateU: (t('v), key, Js.Internal.fn([ `Arity_1 of 'v32 option ], option('v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'v32 option ], option('v))"]]}, {"path": "Belt_Map.Int", "name": "update", "type": "let update: (t('v), key, option('v) => option('v)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "option('v) => option('v)"]]}, {"path": "Belt_Map.Int", "name": "mergeArray", "type": "let mergeArray: (t('v), array((key, 'v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "array((key, 'v))"]]}, {"path": "Belt_Map.Int", "name": "mergeU", "type": "let mergeU: (\n  t('v),\n  t('v2),\n  Js.Internal.fn([ `Arity_3 of key * 'v31 option * 'v210 option ], option('c))\n) => t('c)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "Js.Internal.fn([ `Arity_3 of key * 'v31 option * 'v210 option ], option('c))"]]}, {"path": "Belt_Map.Int", "name": "merge", "type": "let merge: (t('v), t('v2), (key, option('v), option('v2)) => option('c)) => t('c)", "docs": "<p><code>merge m1 m2 f</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "(key, option('v), option('v2)) => option('c)"]]}, {"path": "Belt_Map.Int", "name": "keepU", "type": "let keepU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v30 ], bool)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v30 ], bool)"]]}, {"path": "Belt_Map.Int", "name": "keep", "type": "let keep: (t('v), (key, 'v) => bool) => t('v)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_Map.Int", "name": "partitionU", "type": "let partitionU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v29 ], bool)) => (t('v), t('v))", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v29 ], bool)"]]}, {"path": "Belt_Map.Int", "name": "partition", "type": "let partition: (t('v), (key, 'v) => bool) => (t('v), t('v))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_Map.Int", "name": "split", "type": "let split: (key, t('v)) => (t('v), option('v), t('v))", "docs": "<p><code>split x m</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p>\n", "kind": "value", "args": [["", "key"], ["", "t('v)"]]}, {"path": "Belt_Map.Int", "name": "mapU", "type": "let mapU: (t('v), Js.Internal.fn([ `Arity_1 of 'v28 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_1 of 'v28 ], 'v2)"]]}, {"path": "Belt_Map.Int", "name": "map", "type": "let map: (t('v), 'v => 'v2) => t('v2)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v => 'v2"]]}, {"path": "Belt_Map.Int", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v27 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v27 ], 'v2)"]]}, {"path": "Belt_Map.Int", "name": "mapWithKey", "type": "let mapWithKey: (t('v), (key, 'v) => 'v2) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => 'v2"]]}, {"path": "Belt_Map.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type, its compare behavior is fixed using the built-in comparison</p>\n", "kind": "module"}, {"path": "Belt_Map.String", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt_Map.String", "name": "t", "type": "type t('value)", "docs": "<p>The type of maps from type <code>key</code> to type <code>&#39;value</code>.</p>\n", "kind": "type"}, {"path": "Belt_Map.String", "name": "empty", "type": "let empty: t('v)", "docs": null, "kind": "value"}, {"path": "Belt_Map.String", "name": "isEmpty", "type": "let isEmpty: t('v) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "has", "type": "let has: (t('v), key) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.String", "name": "cmpU", "type": "let cmpU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v26 * 'v26 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v26 * 'v26 ], int)"]]}, {"path": "Belt_Map.String", "name": "cmp", "type": "let cmp: (t('v), t('v), ('v, 'v) => int) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => int"]]}, {"path": "Belt_Map.String", "name": "eqU", "type": "let eqU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v25 * 'v25 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v25 * 'v25 ], bool)"]]}, {"path": "Belt_Map.String", "name": "eq", "type": "let eq: (t('v), t('v), ('v, 'v) => bool) => bool", "docs": "<p><code>equal m1 m2 cmp</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => bool"]]}, {"path": "Belt_Map.String", "name": "forEachU", "type": "let forEachU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v24 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v24 ], unit)"]]}, {"path": "Belt_Map.String", "name": "forEach", "type": "let forEach: (t('v), (key, 'v) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => unit"]]}, {"path": "Belt_Map.String", "name": "reduceU", "type": "let reduceU: (t('v), 'v2, Js.Internal.fn([ `Arity_3 of 'v22 * key * 'v23 ], 'v2)) => 'v2", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "Js.Internal.fn([ `Arity_3 of 'v22 * key * 'v23 ], 'v2)"]]}, {"path": "Belt_Map.String", "name": "reduce", "type": "let reduce: (t('v), 'v2, ('v2, key, 'v) => 'v2) => 'v2", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "('v2, key, 'v) => 'v2"]]}, {"path": "Belt_Map.String", "name": "everyU", "type": "let everyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v19 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v19 ], bool)"]]}, {"path": "Belt_Map.String", "name": "every", "type": "let every: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_Map.String", "name": "someU", "type": "let someU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v18 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v18 ], bool)"]]}, {"path": "Belt_Map.String", "name": "some", "type": "let some: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_Map.String", "name": "size", "type": "let size: t('v) => int", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "toList", "type": "let toList: t('v) => list((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "toArray", "type": "let toArray: t('v) => array((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "ofArray", "type": "let ofArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt_Map.String", "name": "fromArray", "type": "let fromArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt_Map.String", "name": "keysToArray", "type": "let keysToArray: t('v) => array(key)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "valuesToArray", "type": "let valuesToArray: t('v) => array('v)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.String", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.String", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.String", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.String", "name": "minimum", "type": "let minimum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "minUndefined", "type": "let minUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "maximum", "type": "let maximum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "maxUndefined", "type": "let maxUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "get", "type": "let get: (t('v), key) => option('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.String", "name": "getUndefined", "type": "let getUndefined: (t('v), key) => Js.undefined('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.String", "name": "getWithDefault", "type": "let getWithDefault: (t('v), key, 'v) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt_Map.String", "name": "getExn", "type": "let getExn: (t('v), key) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map.String", "name": "remove", "type": "let remove: (t('v), key) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt_Map.String", "name": "removeMany", "type": "let removeMany: (t('v), array(key)) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "array(key)"]]}, {"path": "Belt_Map.String", "name": "set", "type": "let set: (t('v), key, 'v) => t('v)", "docs": "<p><code>add m x y</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt_Map.String", "name": "updateU", "type": "let updateU: (t('v), key, Js.Internal.fn([ `Arity_1 of 'v17 option ], option('v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'v17 option ], option('v))"]]}, {"path": "Belt_Map.String", "name": "update", "type": "let update: (t('v), key, option('v) => option('v)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "option('v) => option('v)"]]}, {"path": "Belt_Map.String", "name": "mergeArray", "type": "let mergeArray: (t('v), array((key, 'v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "array((key, 'v))"]]}, {"path": "Belt_Map.String", "name": "mergeU", "type": "let mergeU: (\n  t('v),\n  t('v2),\n  Js.Internal.fn([ `Arity_3 of key * 'v16 option * 'v21 option ], option('c))\n) => t('c)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "Js.Internal.fn([ `Arity_3 of key * 'v16 option * 'v21 option ], option('c))"]]}, {"path": "Belt_Map.String", "name": "merge", "type": "let merge: (t('v), t('v2), (key, option('v), option('v2)) => option('c)) => t('c)", "docs": "<p><code>merge m1 m2 f</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "(key, option('v), option('v2)) => option('c)"]]}, {"path": "Belt_Map.String", "name": "keepU", "type": "let keepU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v15 ], bool)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v15 ], bool)"]]}, {"path": "Belt_Map.String", "name": "keep", "type": "let keep: (t('v), (key, 'v) => bool) => t('v)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_Map.String", "name": "partitionU", "type": "let partitionU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v14 ], bool)) => (t('v), t('v))", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v14 ], bool)"]]}, {"path": "Belt_Map.String", "name": "partition", "type": "let partition: (t('v), (key, 'v) => bool) => (t('v), t('v))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt_Map.String", "name": "split", "type": "let split: (key, t('v)) => (t('v), option('v), t('v))", "docs": "<p><code>split x m</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p>\n", "kind": "value", "args": [["", "key"], ["", "t('v)"]]}, {"path": "Belt_Map.String", "name": "mapU", "type": "let mapU: (t('v), Js.Internal.fn([ `Arity_1 of 'v13 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_1 of 'v13 ], 'v2)"]]}, {"path": "Belt_Map.String", "name": "map", "type": "let map: (t('v), 'v => 'v2) => t('v2)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v => 'v2"]]}, {"path": "Belt_Map.String", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v12 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v12 ], 'v2)"]]}, {"path": "Belt_Map.String", "name": "mapWithKey", "type": "let mapWithKey: (t('v), (key, 'v) => 'v2) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => 'v2"]]}, {"path": "Belt_Map.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_Map", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>specalized when key type is <code>string</code>, more efficient than the gerneic type, its compare behavior is fixed using the built-in comparison</p>\n", "kind": "module"}, {"path": "Belt_Map.Dict", "name": "t", "type": "type t('key, 'value, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_Map.Dict", "name": "cmp", "type": "type cmp('key, 'id) = Belt_Id.cmp('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_Map.Dict", "name": "empty", "type": "let empty: t('k, 'v, 'id)", "docs": null, "kind": "value"}, {"path": "Belt_Map.Dict", "name": "isEmpty", "type": "let isEmpty: t('k, 'v, 'id) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "has", "type": "let has: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "cmpU", "type": "let cmpU: (\n  t('k, 'v, 'id),\n  t('k, 'v, 'id),\n  ~kcmp: cmp('k, 'id),\n  ~vcmp: Js.Internal.fn([ `Arity_2 of 'v11 * 'v11 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["kcmp", "cmp('k, 'id)"], ["vcmp", "Js.Internal.fn([ `Arity_2 of 'v11 * 'v11 ], int)"]]}, {"path": "Belt_Map.Dict", "name": "cmp", "type": "let cmp: (t('k, 'v, 'id), t('k, 'v, 'id), ~kcmp: cmp('k, 'id), ~vcmp: ('v, 'v) => int) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["kcmp", "cmp('k, 'id)"], ["vcmp", "('v, 'v) => int"]]}, {"path": "Belt_Map.Dict", "name": "eqU", "type": "let eqU: (\n  t('k, 'a, 'id),\n  t('k, 'a, 'id),\n  ~kcmp: cmp('k, 'id),\n  ~veq: Js.Internal.fn([ `Arity_2 of 'a74 * 'a74 ], bool)\n) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["kcmp", "cmp('k, 'id)"], ["veq", "Js.Internal.fn([ `Arity_2 of 'a74 * 'a74 ], bool)"]]}, {"path": "Belt_Map.Dict", "name": "eq", "type": "let eq: (t('k, 'a, 'id), t('k, 'a, 'id), ~kcmp: cmp('k, 'id), ~veq: ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 cmp</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["kcmp", "cmp('k, 'id)"], ["veq", "('a, 'a) => bool"]]}, {"path": "Belt_Map.Dict", "name": "forEachU", "type": "let forEachU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k19 * 'a73 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k19 * 'a73 ], unit)"]]}, {"path": "Belt_Map.Dict", "name": "forEach", "type": "let forEach: (t('k, 'a, 'id), ('k, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the &#39;k as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => unit"]]}, {"path": "Belt_Map.Dict", "name": "reduceU", "type": "let reduceU: (t('k, 'a, 'id), 'b, Js.Internal.fn([ `Arity_3 of 'b16 * 'k18 * 'a72 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b16 * 'k18 * 'a72 ], 'b)"]]}, {"path": "Belt_Map.Dict", "name": "reduce", "type": "let reduce: (t('k, 'a, 'id), 'b, ('b, 'k, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "('b, 'k, 'a) => 'b"]]}, {"path": "Belt_Map.Dict", "name": "everyU", "type": "let everyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k17 * 'a71 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k17 * 'a71 ], bool)"]]}, {"path": "Belt_Map.Dict", "name": "every", "type": "let every: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_Map.Dict", "name": "someU", "type": "let someU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k16 * 'a70 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k16 * 'a70 ], bool)"]]}, {"path": "Belt_Map.Dict", "name": "some", "type": "let some: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_Map.Dict", "name": "size", "type": "let size: t('k, 'a, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "toList", "type": "let toList: t('k, 'a, 'id) => list(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "toArray", "type": "let toArray: t('k, 'a, 'id) => array(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "ofArray", "type": "let ofArray: (array(('k, 'a)), ~cmp: cmp('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "fromArray", "type": "let fromArray: (array(('k, 'a)), ~cmp: cmp('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "keysToArray", "type": "let keysToArray: t('k, 'a, 'id) => array('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "valuesToArray", "type": "let valuesToArray: t('k, 'a, 'id) => array('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "minKey", "type": "let minKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map.Dict", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map.Dict", "name": "maxKey", "type": "let maxKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map.Dict", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map.Dict", "name": "minimum", "type": "let minimum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map.Dict", "name": "minUndefined", "type": "let minUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map.Dict", "name": "maximum", "type": "let maximum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map.Dict", "name": "maxUndefined", "type": "let maxUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map.Dict", "name": "get", "type": "let get: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => option('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "getUndefined", "type": "let getUndefined: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "getWithDefault", "type": "let getWithDefault: (t('k, 'a, 'id), 'k, 'a, ~cmp: cmp('k, 'id)) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "'a"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "getExn", "type": "let getExn: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_Map.Dict", "name": "remove", "type": "let remove: (t('a, 'b, 'id), 'a, ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "removeMany", "type": "let removeMany: (t('a, 'b, 'id), array('a), ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "array('a)"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "set", "type": "let set: (t('a, 'b, 'id), 'a, 'b, ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["", "'b"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "updateU", "type": "let updateU: (\n  t('a, 'b, 'id),\n  'a,\n  Js.Internal.fn([ `Arity_1 of 'b15 option ], option('b)),\n  ~cmp: cmp('a, 'id)\n) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_1 of 'b15 option ], option('b))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "update", "type": "let update: (t('a, 'b, 'id), 'a, option('b) => option('b), ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["", "option('b) => option('b)"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "mergeU", "type": "let mergeU: (\n  t('a, 'b, 'id),\n  t('a, 'c, 'id),\n  Js.Internal.fn([ `Arity_3 of 'a69 * 'b14 option * 'c6 option ], option('d)),\n  ~cmp: cmp('a, 'id)\n) => t('a, 'd, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "t('a, 'c, 'id)"], ["", "Js.Internal.fn([ `Arity_3 of 'a69 * 'b14 option * 'c6 option ], option('d))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "merge", "type": "let merge: (\n  t('a, 'b, 'id),\n  t('a, 'c, 'id),\n  ('a, option('b), option('c)) => option('d),\n  ~cmp: cmp('a, 'id)\n) => t('a, 'd, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "t('a, 'c, 'id)"], ["", "('a, option('b), option('c)) => option('d)"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "mergeMany", "type": "let mergeMany: (t('a, 'b, 'id), array(('a, 'b)), ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "array(('a, 'b))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "keepU", "type": "let keepU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k15 * 'a68 ], bool)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k15 * 'a68 ], bool)"]]}, {"path": "Belt_Map.Dict", "name": "keep", "type": "let keep: (t('k, 'a, 'id), ('k, 'a) => bool) => t('k, 'a, 'id)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_Map.Dict", "name": "partitionU", "type": "let partitionU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k14 * 'a67 ], bool)) => (\n  t('k, 'a, 'id),\n  t('k, 'a, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k14 * 'a67 ], bool)"]]}, {"path": "Belt_Map.Dict", "name": "partition", "type": "let partition: (t('k, 'a, 'id), ('k, 'a) => bool) => (t('k, 'a, 'id), t('k, 'a, 'id))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt_Map.Dict", "name": "split", "type": "let split: (t('a, 'b, 'id), 'a, ~cmp: cmp('a, 'id)) => (\n  (t('a, 'b, 'id), t('a, 'b, 'id)),\n  option('b)\n)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_Map.Dict", "name": "mapU", "type": "let mapU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_1 of 'a66 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'a66 ], 'b)"]]}, {"path": "Belt_Map.Dict", "name": "map", "type": "let map: (t('k, 'a, 'id), 'a => 'b) => t('k, 'b, 'id)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'a => 'b"]]}, {"path": "Belt_Map.Dict", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k13 * 'a65 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k13 * 'a65 ], 'b)"]]}, {"path": "Belt_Map.Dict", "name": "mapWithKey", "type": "let mapWithKey: (t('k, 'a, 'id), ('k, 'a) => 'b) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => 'b"]]}, {"path": "Belt_Map", "name": "Dict", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>This module seprate identity from data, it is a bit more verbsoe but slightly more efficient due to the fact that there is no need to pack identity and data back after each operation</p>\n<p><strong>Advanced usage only</strong></p>\n", "kind": "module"}, {"path": "Belt_Map", "name": "t", "type": "type t('key, 'value, 'identity)", "docs": "<p><code>(&#39;key, &#39;identity) t</code></p>\n<p><code>&#39;key</code> is the field type</p>\n<p><code>&#39;value</code> is the element type</p>\n<p><code>&#39;identity</code> the identity of the collection</p>\n", "kind": "type"}, {"path": "Belt_Map", "name": "id", "type": "type id('key, 'id) = Belt_Id.comparable('key, 'id)", "docs": "<p>The identity needed for making an empty map</p>\n", "kind": "type"}, {"path": "Belt_Map", "name": "make", "type": "let make: (~id: id('k, 'id)) => t('k, 'v, 'id)", "docs": "<p><code>make ~id</code> creates a new map by taking in the comparator</p>\n<pre class='ml'><code class='ml'>let m = Belt.Map.make ~id:(module IntCmp)\n</code></pre>", "kind": "value", "args": [["id", "id('k, 'id)"]]}, {"path": "Belt_Map", "name": "isEmpty", "type": "let isEmpty: t('a, 'a, 'a) => bool", "docs": "<p><code>isEmpty m</code> checks whether a map m is empty</p>\n<pre class='ml'><code class='ml'>isEmpty (fromArray [|1,&quot;1&quot;|] ~id:(module IntCmp)) = false\n</code></pre>", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_Map", "name": "has", "type": "let has: (t('k, 'v, 'id), 'k) => bool", "docs": "<p><code>has m k</code> checks whether m has the key k</p>\n<pre class='ml'><code class='ml'>has (fromArray [|1,&quot;1&quot;|] ~id:(module IntCmp)) 1 = true\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt_Map", "name": "cmpU", "type": "let cmpU: (t('k, 'v, 'id), t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'v10 * 'v10 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'v10 * 'v10 ], int)"]]}, {"path": "Belt_Map", "name": "cmp", "type": "let cmp: (t('k, 'v, 'id), t('k, 'v, 'id), ('v, 'v) => int) => int", "docs": "<p><code>cmp m0 m1 vcmp</code></p>\n<p>Total ordering of map given total ordering of value function.</p>\n<p>It will compare size first and each element following the order one by one.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["", "('v, 'v) => int"]]}, {"path": "Belt_Map", "name": "eqU", "type": "let eqU: (t('k, 'v, 'id), t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'v9 * 'v9 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'v9 * 'v9 ], bool)"]]}, {"path": "Belt_Map", "name": "eq", "type": "let eq: (t('k, 'v, 'id), t('k, 'v, 'id), ('v, 'v) => bool) => bool", "docs": "<p><code>eq m1 m2 veq</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>veq</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["", "('v, 'v) => bool"]]}, {"path": "Belt_Map", "name": "forEachU", "type": "let forEachU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k12 * 'v8 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k12 * 'v8 ], unit)"]]}, {"path": "Belt_Map", "name": "forEach", "type": "let forEach: (t('k, 'v, 'id), ('k, 'v) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the &#39;k as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|4,&quot;4&quot;;1,&quot;1&quot;;2,&quot;2,&quot;3&quot;&quot;|];;\nlet acc = ref [] ;;\nforEach s0 (fun k v -&gt; acc := (k,v) :: !acc);;\n\n!acc = [4,&quot;4&quot;; 3,&quot;3&quot;; 2,&quot;2&quot;; 1,&quot;1&quot;]\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => unit"]]}, {"path": "Belt_Map", "name": "reduceU", "type": "let reduceU: (t('k, 'v, 'id), 'acc, Js.Internal.fn([ `Arity_3 of 'acc * 'k11 * 'v7 ], 'acc)) => 'acc", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'acc"], ["", "Js.Internal.fn([ `Arity_3 of 'acc * 'k11 * 'v7 ], 'acc)"]]}, {"path": "Belt_Map", "name": "reduce", "type": "let reduce: (t('k, 'v, 'id), 'acc, ('acc, 'k, 'v) => 'acc) => 'acc", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|4,&quot;4&quot;;1,&quot;1&quot;;2,&quot;2,&quot;3&quot;&quot;|];;\nreduce s0 [] (fun acc k v -&gt; (k,v) acc ) = [4,&quot;4&quot;;3,&quot;3&quot;;2,&quot;2&quot;;1,&quot;1&quot;];;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'acc"], ["", "('acc, 'k, 'v) => 'acc"]]}, {"path": "Belt_Map", "name": "everyU", "type": "let everyU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k10 * 'v6 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k10 * 'v6 ], bool)"]]}, {"path": "Belt_Map", "name": "every", "type": "let every: (t('k, 'v, 'id), ('k, 'v) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => bool"]]}, {"path": "Belt_Map", "name": "someU", "type": "let someU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k9 * 'v5 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k9 * 'v5 ], bool)"]]}, {"path": "Belt_Map", "name": "some", "type": "let some: (t('k, 'v, 'id), ('k, 'v) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => bool"]]}, {"path": "Belt_Map", "name": "size", "type": "let size: t('k, 'v, 'id) => int", "docs": "<p><code>size s</code></p>\n<pre class='ml'><code class='ml'>size (fromArray [2,&quot;2&quot;; 2,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = 2 ;;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt_Map", "name": "toArray", "type": "let toArray: t('k, 'v, 'id) => array(('k, 'v))", "docs": "<p><code>size s</code></p>\n<pre class='ml'><code class='ml'>size (fromArray [2,&quot;2&quot;; 2,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = 2 ;;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt_Map", "name": "toList", "type": "let toList: t('k, 'v, 'id) => list(('k, 'v))", "docs": "<p><code>toArray s</code></p>\n<pre class='ml'><code class='ml'>toArray (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = [1,&quot;1&quot;;2,&quot;2&quot;;3,&quot;3&quot;]\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt_Map", "name": "ofArray", "type": "let ofArray: (array(('k, 'v)), ~id: id('k, 'id)) => t('k, 'v, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'v))"], ["id", "id('k, 'id)"]]}, {"path": "Belt_Map", "name": "fromArray", "type": "let fromArray: (array(('k, 'v)), ~id: id('k, 'id)) => t('k, 'v, 'id)", "docs": "<p><code>fromArray kvs ~id</code></p>\n<pre class='ml'><code class='ml'>toArray (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = [1,&quot;1&quot;;2,&quot;2&quot;;3,&quot;3&quot;]\n</code></pre>", "kind": "value", "args": [["", "array(('k, 'v))"], ["id", "id('k, 'id)"]]}, {"path": "Belt_Map", "name": "keysToArray", "type": "let keysToArray: t('k, 'v, 'id) => array('k)", "docs": "<p><code>fromArray kvs ~id</code></p>\n<pre class='ml'><code class='ml'>toArray (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = [1,&quot;1&quot;;2,&quot;2&quot;;3,&quot;3&quot;]\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt_Map", "name": "valuesToArray", "type": "let valuesToArray: t('k, 'v, 'id) => array('v)", "docs": "<p><code>keysToArray s</code></p>\n<pre class='ml'><code class='ml'>keysToArray (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) =\n[|1;2;3|];;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt_Map", "name": "minKey", "type": "let minKey: t('k, 'a, 'a) => option('k)", "docs": "<p><code>minKey s</code></p>\n<p>Returns: <p>the minimum key, None if not exist</p></p>\n", "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": "<p><strong>See</strong> minKey</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map", "name": "maxKey", "type": "let maxKey: t('k, 'a, 'a) => option('k)", "docs": "<p><code>maxKey s</code></p>\n<p>Returns: <p>the maximum key, None if not exist</p></p>\n", "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": "<p><strong>See</strong> maxKey</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt_Map", "name": "minimum", "type": "let minimum: t('k, 'v, 'a) => option(('k, 'v))", "docs": "<p><code>minimum s</code></p>\n<p>Returns: <p>the minimum key value pair, None if not exist</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'a)"]]}, {"path": "Belt_Map", "name": "minUndefined", "type": "let minUndefined: t('k, 'v, 'a) => Js.undefined(('k, 'v))", "docs": "<p><strong>See</strong> minimum</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'a)"]]}, {"path": "Belt_Map", "name": "maximum", "type": "let maximum: t('k, 'v, 'a) => option(('k, 'v))", "docs": "<p><code>maximum s</code></p>\n<p>Returns: <p>the maximum key value pair, None if not exist</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'a)"]]}, {"path": "Belt_Map", "name": "maxUndefined", "type": "let maxUndefined: t('k, 'v, 'a) => Js.undefined(('k, 'v))", "docs": "<p><strong>See</strong> maximum</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'a)"]]}, {"path": "Belt_Map", "name": "get", "type": "let get: (t('k, 'v, 'id), 'k) => option('v)", "docs": "<p><code>get s k</code></p>\n<pre class='ml'><code class='ml'>get (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) 2 =\nSome &quot;2&quot;;;\nget (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) 2 =\nNone;;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt_Map", "name": "getUndefined", "type": "let getUndefined: (t('k, 'v, 'id), 'k) => Js.undefined('v)", "docs": "<p><strong>See</strong> get</p>\n<p>Returns: <p><code>undefined</code> when not found</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt_Map", "name": "getWithDefault", "type": "let getWithDefault: (t('k, 'v, 'id), 'k, 'v) => 'v", "docs": "<p><strong>See</strong> get</p>\n<p>Returns: <p><code>undefined</code> when not found</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"], ["", "'v"]]}, {"path": "Belt_Map", "name": "getExn", "type": "let getExn: (t('k, 'v, 'id), 'k) => 'v", "docs": "<p><code>getWithDefault s k default</code></p>\n<p><strong>See</strong> get</p>\n<p>Returns: <p><code>default</code> when <code>k</code> is not found</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt_Map", "name": "remove", "type": "let remove: (t('k, 'v, 'id), 'k) => t('k, 'v, 'id)", "docs": "<p><code>remove m x</code> when <code>x</code> is not in <code>m</code>, <code>m</code> is returned reference unchanged.</p>\n<pre class='ml'><code class='ml'>let s0 =  (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp));;\n\nlet s1 = remove s0 1;;\nlet s2 = remove s1 1;;\ns1 == s2 ;;\nkeysToArray s1 = [|2;3|];;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt_Map", "name": "removeMany", "type": "let removeMany: (t('k, 'v, 'id), array('k)) => t('k, 'v, 'id)", "docs": "<p><code>removeMany s xs</code></p>\n<p>Removing each of <code>xs</code> to <code>s</code>, note unlike remove, the reference of return value might be changed even if none in <code>xs</code> exists <code>s</code></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "array('k)"]]}, {"path": "Belt_Map", "name": "set", "type": "let set: (t('k, 'v, 'id), 'k, 'v) => t('k, 'v, 'id)", "docs": "<p><code>set m x y </code> returns a map containing the same bindings as <code>m</code>, with a new binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n<pre class='ml'><code class='ml'>let s0 =  (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp));;\n\nlet s1 = set s0 2 &quot;3&quot;;;\n\nvaluesToArray s1 =  [&quot;1&quot;;&quot;3&quot;;&quot;3&quot;];;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"], ["", "'v"]]}, {"path": "Belt_Map", "name": "updateU", "type": "let updateU: (t('k, 'v, 'id), 'k, Js.Internal.fn([ `Arity_1 of 'v4 option ], option('v))) => t(\n  'k,\n  'v,\n  'id\n)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"], ["", "Js.Internal.fn([ `Arity_1 of 'v4 option ], option('v))"]]}, {"path": "Belt_Map", "name": "update", "type": "let update: (t('k, 'v, 'id), 'k, option('v) => option('v)) => t('k, 'v, 'id)", "docs": "<p><code>update m x f</code> returns a map containing the same bindings as <code>m</code>, except for the binding of <code>x</code>. Depending on the value of <code>y</code> where <code>y</code> is <code>f (get x m)</code>, the binding of <code>x</code> is added, removed or updated. If <code>y</code> is <code>None</code>, the binding is removed if it exists; otherwise, if <code>y</code> is <code>Some z</code> then <code>x</code> is associated to <code>z</code> in the resulting map.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"], ["", "option('v) => option('v)"]]}, {"path": "Belt_Map", "name": "mergeMany", "type": "let mergeMany: (t('k, 'v, 'id), array(('k, 'v))) => t('k, 'v, 'id)", "docs": "<p><code>mergeMany s xs</code></p>\n<p>Adding each of <code>xs</code> to <code>s</code>, note unlike add, the reference of return value might be changed even if all values in <code>xs</code> exist <code>s</code></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "array(('k, 'v))"]]}, {"path": "Belt_Map", "name": "mergeU", "type": "let mergeU: (\n  t('k, 'v, 'id),\n  t('k, 'v2, 'id),\n  Js.Internal.fn([ `Arity_3 of 'k8 * 'v3 option * 'v20 option ], option('v3))\n) => t('k, 'v3, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v2, 'id)"], ["", "Js.Internal.fn([ `Arity_3 of 'k8 * 'v3 option * 'v20 option ], option('v3))"]]}, {"path": "Belt_Map", "name": "merge", "type": "let merge: (t('k, 'v, 'id), t('k, 'v2, 'id), ('k, option('v), option('v2)) => option('v3)) => t(\n  'k,\n  'v3,\n  'id\n)", "docs": "<p><code>merge m1 m2 f</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v2, 'id)"], ["", "('k, option('v), option('v2)) => option('v3)"]]}, {"path": "Belt_Map", "name": "keepU", "type": "let keepU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k7 * 'v2 ], bool)) => t('k, 'v, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k7 * 'v2 ], bool)"]]}, {"path": "Belt_Map", "name": "keep", "type": "let keep: (t('k, 'v, 'id), ('k, 'v) => bool) => t('k, 'v, 'id)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => bool"]]}, {"path": "Belt_Map", "name": "partitionU", "type": "let partitionU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k6 * 'v1 ], bool)) => (\n  t('k, 'v, 'id),\n  t('k, 'v, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k6 * 'v1 ], bool)"]]}, {"path": "Belt_Map", "name": "partition", "type": "let partition: (t('k, 'v, 'id), ('k, 'v) => bool) => (t('k, 'v, 'id), t('k, 'v, 'id))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => bool"]]}, {"path": "Belt_Map", "name": "split", "type": "let split: (t('k, 'v, 'id), 'k) => ((t('k, 'v, 'id), t('k, 'v, 'id)), option('v))", "docs": "<p><code>split x m</code> returns a tuple <code>(l r), data</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose &#39;k is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose &#39;k is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt_Map", "name": "mapU", "type": "let mapU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_1 of 'v0 ], 'v2)) => t('k, 'v2, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'v0 ], 'v2)"]]}, {"path": "Belt_Map", "name": "map", "type": "let map: (t('k, 'v, 'id), 'v => 'v2) => t('k, 'v2, 'id)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'v => 'v2"]]}, {"path": "Belt_Map", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k5 * 'v ], 'v2)) => t('k, 'v2, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k5 * 'v ], 'v2)"]]}, {"path": "Belt_Map", "name": "mapWithKey", "type": "let mapWithKey: (t('k, 'v, 'id), ('k, 'v) => 'v2) => t('k, 'v2, 'id)", "docs": "<p><code>mapWithKey m f</code></p>\n<p>The same as map except that <code>f</code> is supplied with one more argument: the key</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => 'v2"]]}, {"path": "Belt_Map", "name": "getData", "type": "let getData: t('k, 'v, 'id) => Belt_MapDict.t('k, 'v, 'id)", "docs": "<p><code>getData s0</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the raw data (detached from comparator), but its type is still manifested, so that user can pass identity directly without boxing</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt_Map", "name": "getId", "type": "let getId: t('k, 'v, 'id) => id('k, 'id)", "docs": "<p><code>getId s0</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the identity of <code>s0</code></p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt_Map", "name": "packIdData", "type": "let packIdData: (~id: id('k, 'id), ~data: Belt_MapDict.t('k, 'v, 'id)) => t('k, 'v, 'id)", "docs": "<p><code>packIdData ~id ~data</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the packed collection</p></p>\n", "kind": "value", "args": [["id", "id('k, 'id)"], ["data", "Belt_MapDict.t('k, 'v, 'id)"]]}, {"path": "Belt_Map", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a, 'a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "", "name": "Belt_Map", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getData\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getId\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>packIdData\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Dict\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt_List", "name": "t", "type": "type t('a) = list('a)", "docs": "<p><code>&#39;a t</code> is compatible with built-in <code>list</code> type</p>\n", "kind": "type"}, {"path": "Belt_List", "name": "length", "type": "let length: t('a) => int", "docs": "<p><code>length xs</code></p>\n<p>Returns: <p>the length of the list <code>xs</code></p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_List", "name": "size", "type": "let size: t('a) => int", "docs": "<p><strong>See</strong> length</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_List", "name": "head", "type": "let head: t('a) => option('a)", "docs": "<p><code>head xs</code> returns <code>None</code> if <code>xs</code> is the empty list, otherwise it returns <code>Some value</code> where <code>value</code> is the first element in the list.</p>\n<pre class='ml'><code class='ml'>head [] = None ;;\nhead [1;2;3] = Some 1 ;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_List", "name": "headExn", "type": "let headExn: t('a) => 'a", "docs": "<p><code>head xs</code> returns <code>None</code> if <code>xs</code> is the empty list, otherwise it returns <code>Some value</code> where <code>value</code> is the first element in the list.</p>\n<pre class='ml'><code class='ml'>head [] = None ;;\nhead [1;2;3] = Some 1 ;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_List", "name": "tail", "type": "let tail: t('a) => option(t('a))", "docs": "<p><code>tail xs</code> returns <code>None</code> if <code>xs</code> is empty; otherwise it returns <code>Some xs2</code> where <code>xs2</code> is everything except the first element of <code>xs</code>;</p>\n<pre class='ml'><code class='ml'>\ntail [] = None;;\ntail [1;2;3;4] = Some [2;3;4];;\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_List", "name": "tailExn", "type": "let tailExn: t('a) => t('a)", "docs": "<p><code>tailExn xs</code></p>\n<p><strong>See</strong> tail</p>\n<p><strong>raise</strong> an exception if <code>xs</code> is empty</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_List", "name": "add", "type": "let add: (t('a), 'a) => t('a)", "docs": "<p><code>add xs y</code> adds <code>y</code> to the end of list <code>xs</code></p>\n<pre class='ml'><code class='ml'>add [1] 3 = [3;1];;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a"]]}, {"path": "Belt_List", "name": "get", "type": "let get: (t('a), int) => option('a)", "docs": "<p><code>add xs y</code> adds <code>y</code> to the end of list <code>xs</code></p>\n<pre class='ml'><code class='ml'>add [1] 3 = [3;1];;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt_List", "name": "getExn", "type": "let getExn: (t('a), int) => 'a", "docs": "<p><code>getExn xs n</code></p>\n<p><strong>See</strong> get</p>\n<p><strong>raise</strong> an exception if <code>n</code> is larger than the length</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt_List", "name": "make", "type": "let make: (int, 'a) => t('a)", "docs": "<p><code>make n v</code></p>\n<ul><li><p>return a list of length <code>n</code> with each element filled with value <code>v</code></p>\n</li><li><p>return the empty list if <code>n</code> is negative</p>\n</li></ul><pre class='ml'><code class='ml'>make 3 1 =  [1;1;1]\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Belt_List", "name": "makeByU", "type": "let makeByU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_List", "name": "makeBy", "type": "let makeBy: (int, int => 'a) => t('a)", "docs": "<p><code>makeBy n f</code></p>\n<p><code>n</code> with element <code>i</code> initialized with <code>f i</code> f <code>n</code> is negative</p>\n<p><code>0;1;2;3;4</code>;; i) = <code>0;1;4;9;16</code>;;</p>\n", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_List", "name": "shuffle", "type": "let shuffle: t('a) => t('a)", "docs": "<p><code>shuffle xs</code></p>\n<p>Returns: <p>a new list in random order</p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_List", "name": "drop", "type": "let drop: (t('a), int) => option(t('a))", "docs": "<p><code>drop xs n</code></p>\n<p>return the list obtained by dropping the first <code>n</code> elements, or <code>None</code> if <code>xs</code> has fewer than <code>n</code> elements</p>\n<pre class='ml'><code class='ml'>drop [1;2;3] 2 = Some [3];;\ndrop [1;2;3] 3 = Some [];;\ndrop [1;2;3] 4 = None;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt_List", "name": "take", "type": "let take: (t('a), int) => option(t('a))", "docs": "<p><code>take xs n</code></p>\n<p>return a list with the first <code>n</code> elements from <code>xs</code>, or <code>None</code> if <code>xs</code> has fewer than <code>n</code> elements</p>\n<pre class='ml'><code class='ml'>take [1;2;3] 1 = Some [1];;\ntake [1;2;3] 2 = Some [1;2];;\ntake [1;2;3] 4 = None;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt_List", "name": "splitAt", "type": "let splitAt: (t('a), int) => option((list('a), list('a)))", "docs": "<p><code>splitAt xs n</code> split the list <code>xs</code> at position <code>n</code> return None when the length of <code>xs</code> is less than <code>n</code></p>\n<pre class='ml'><code class='ml'>splitAt [0;1;2;3;4] 2 = Some ([0;1], [2;3;4])\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt_List", "name": "concat", "type": "let concat: (t('a), t('a)) => t('a)", "docs": "<p><code>concat xs ys</code></p>\n<p>Returns: <p>the list obtained by adding <code>ys</code> after <code>xs</code></p>\n<pre class='ml'><code class='ml'>concat [1;2;3] [4;5] = [1;2;3;4;5]\n</code></pre></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt_List", "name": "concatMany", "type": "let concatMany: array(t('a)) => t('a)", "docs": "<p><code>concatMany a</code> return the list obtained by concatenating in order all the lists in array <code>a</code></p>\n<pre class='ml'><code class='ml'>concatMany [| [1;2;3] ; []; [3]; [4] |] = [1;2;3;3;4]\n</code></pre>", "kind": "value", "args": [["", "array(t('a))"]]}, {"path": "Belt_List", "name": "reverseConcat", "type": "let reverseConcat: (t('a), t('a)) => t('a)", "docs": "<p><code>reverseConcat xs ys</code> is equivalent to <code>concat (reverse xs) ys</code></p>\n<pre class='ml'><code class='ml'>reverseConcat [1;2] [3;4] = [2;1;3;4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt_List", "name": "flatten", "type": "let flatten: t(t('a)) => t('a)", "docs": "<p><code>flatten ls</code> return the list obtained by concatenating in order all the lists in list <code>ls</code></p>\n<pre class='ml'><code class='ml'>flatten [ [1;2;3] ; []; [3]; [4] ] = [1;2;3;3;4]\n</code></pre>", "kind": "value", "args": [["", "t(t('a))"]]}, {"path": "Belt_List", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a106 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a106 ], 'b)"]]}, {"path": "Belt_List", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>map xs f</code></p>\n<p>return the list obtained by applying <code>f</code> to each element of <code>xs</code></p>\n<pre class='ml'><code class='ml'>map [1;2] (fun x-&gt; x + 1) = [3;4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt_List", "name": "zip", "type": "let zip: (t('a), t('b)) => t(('a, 'b))", "docs": "<p><code>zip xs ys</code></p>\n<p>Returns: <p>a list of pairs from the two lists with the length of the shorter list</p>\n<pre class='ml'><code class='ml'>zip [1;2] [3;4;5] = [(1,3); (2,4)]\n</code></pre></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"]]}, {"path": "Belt_List", "name": "zipByU", "type": "let zipByU: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a105 * 'b29 ], 'c)) => t('c)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a105 * 'b29 ], 'c)"]]}, {"path": "Belt_List", "name": "zipBy", "type": "let zipBy: (t('a), t('b), ('a, 'b) => 'c) => t('c)", "docs": "failed to parse: File &quot;&quot;, line 4, characters 19-20:\nunpaired &#39;]&#39; (end of code)", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_List", "name": "mapWithIndexU", "type": "let mapWithIndexU: (t('a), Js.Internal.fn([ `Arity_2 of int * 'a104 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a104 ], 'b)"]]}, {"path": "Belt_List", "name": "mapWithIndex", "type": "let mapWithIndex: (t('a), (int, 'a) => 'b) => t('b)", "docs": "<p><code>mapWithIndex xs f</code> applies <code>f</code> to each element of <code>xs</code>. Function <code>f</code> takes two arguments: the index starting from 0 and the element from <code>xs</code>.</p>\n<pre class='ml'><code class='ml'>mapWithIndex [1;2;3] (fun i x -&gt; i + x) =\n[0 + 1; 1 + 2; 2 + 3 ]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt_List", "name": "ofArray", "type": "let ofArray: array('a) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_List", "name": "fromArray", "type": "let fromArray: array('a) => t('a)", "docs": "<p><code>fromArray arr</code> converts the given array to a list</p>\n<pre class='ml'><code class='ml'>fromArray [|1;2;3|]  = [1;2;3]\n</code></pre>", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_List", "name": "toArray", "type": "let toArray: t('a) => array('a)", "docs": "<p><code>toArray xs</code> converts the given list to an array</p>\n<pre class='ml'><code class='ml'>toArray [1;2;3] = [|1;2;3|]\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_List", "name": "reverse", "type": "let reverse: t('a) => t('a)", "docs": "<p><code>reverse xs</code> returns a new list whose elements are those of <code>xs</code> in reverse order.</p>\n<pre class='ml'><code class='ml'>reverse [1;2;3] = [3;2;1]\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_List", "name": "mapReverseU", "type": "let mapReverseU: (t('a), Js.Internal.fn([ `Arity_1 of 'a103 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a103 ], 'b)"]]}, {"path": "Belt_List", "name": "mapReverse", "type": "let mapReverse: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>mapReverse xs f</code></p>\n<p>x) = <code>25;16;9</code>;;</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt_List", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_1 of 'a102 ], 'b)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a102 ], 'b)"]]}, {"path": "Belt_List", "name": "forEach", "type": "let forEach: (t('a), 'a => 'b) => unit", "docs": "failed to parse: File &quot;&quot;, line 16, characters 0-0:\nend of text is not allowed in &#39;{[...]}&#39; (code block)", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt_List", "name": "forEachWithIndexU", "type": "let forEachWithIndexU: (t('a), Js.Internal.fn([ `Arity_2 of int * 'a101 ], 'b)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a101 ], 'b)"]]}, {"path": "Belt_List", "name": "forEachWithIndex", "type": "let forEachWithIndex: (t('a), (int, 'a) => 'b) => unit", "docs": "failed to parse: File &quot;&quot;, line 14, characters 0-0:\nend of text is not allowed in &#39;{[...]}&#39; (code block)", "kind": "value", "args": [["", "t('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt_List", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'b28 * 'a100 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b28 * 'a100 ], 'b)"]]}, {"path": "Belt_List", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b", "docs": "<p><code>reduce xs f</code></p>\n<p>Applies <code>f</code> to each element of <code>xs</code> from beginning to end. Function <code>f</code> has two parameters: the item from the list and an \226\128\156accumulator\226\128\157, which starts with a value of <code>init</code>. <code>reduce</code> returns the final value of the accumulator.</p>\n<pre class='ml'><code class='ml'>reduce [1;2;3;4] 0 (+) = 10;;\nreduce [1;2;3;4] 10 (-) = 0;;\nreduce [1;2;3;4] [] add = [4;3;2;1];\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt_List", "name": "reduceReverseU", "type": "let reduceReverseU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'b27 * 'a99 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b27 * 'a99 ], 'b)"]]}, {"path": "Belt_List", "name": "reduceReverse", "type": "let reduceReverse: (t('a), 'b, ('b, 'a) => 'b) => 'b", "docs": "<p><code>reduceReverse xs f</code></p>\n<p>Works like reduce, except that function <code>f</code> is applied to each item of <code>xs</code> from the last back to the first.</p>\n<pre class='ml'><code class='ml'>reduceReverse [1;2;3;4] 0 (+) = 10;;\nreduceReverse [1;2;3;4] 10 (-) = 0;;\nreduceReverse [1;2;3;4] [] add = [1;2;3;4];;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt_List", "name": "mapReverse2U", "type": "let mapReverse2U: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a98 * 'b26 ], 'c)) => t('c)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a98 * 'b26 ], 'c)"]]}, {"path": "Belt_List", "name": "mapReverse2", "type": "let mapReverse2: (t('a), t('b), ('a, 'b) => 'c) => t('c)", "docs": "<p><code>mapReverse2 xs ys f</code></p>\n<p>equivalent to <code>reverse (zipBy xs ys f)</code></p>\n<pre class='ml'><code class='ml'>mapReverse2 [1;2;3] [1;2] (+) = [4;2]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_List", "name": "forEach2U", "type": "let forEach2U: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a97 * 'b25 ], 'c)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a97 * 'b25 ], 'c)"]]}, {"path": "Belt_List", "name": "forEach2", "type": "let forEach2: (t('a), t('b), ('a, 'b) => 'c) => unit", "docs": "<p><code>forEach2 xs ys f</code> stop with the shorter list</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_List", "name": "reduce2U", "type": "let reduce2U: (t('b), t('c), 'a, Js.Internal.fn([ `Arity_3 of 'a96 * 'b24 * 'c8 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "t('c)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_3 of 'a96 * 'b24 * 'c8 ], 'a)"]]}, {"path": "Belt_List", "name": "reduce2", "type": "let reduce2: (t('b), t('c), 'a, ('a, 'b, 'c) => 'a) => 'a", "docs": "<p><code>reduce2 xs ys init f </code></p>\n<p>ginning to end. Stops with the shorter list. \226\128\157 which starts with a value of <code>init</code>, returns the final value of the accumulator.</p>\n<p>x + y) = 0 + (1 * 1 + 4) + (2 * 2 + 5);; x + y) = <code>2 +5;1 + 4 </code>;; (*add appends at end *)</p>\n", "kind": "value", "args": [["", "t('b)"], ["", "t('c)"], ["", "'a"], ["", "('a, 'b, 'c) => 'a"]]}, {"path": "Belt_List", "name": "reduceReverse2U", "type": "let reduceReverse2U: (t('a), t('b), 'c, Js.Internal.fn([ `Arity_3 of 'c7 * 'a95 * 'b23 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c7 * 'a95 * 'b23 ], 'c)"]]}, {"path": "Belt_List", "name": "reduceReverse2", "type": "let reduceReverse2: (t('a), t('b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": "<p><code>reduceReverse2 xs ys init f </code></p>\n<p>ginning. Stops with the shorter list. ch starts with a value of <code>init</code>, the final value of the accumulator.</p>\n<p>x + y) = 0 + (1 * 1 + 4) + (2 * 2 + 5);; x + y) = <code>1 + 4;2 + 5</code>;; (*add appends at end *)</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_List", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a94 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a94 ], bool)"]]}, {"path": "Belt_List", "name": "every", "type": "let every: (t('a), 'a => bool) => bool", "docs": "<p><code>every xs p</code></p>\n<p>Returns: <p>true if all elements satisfy <code>p</code>, where <code>p</code> is a <em>predicate</em>: a function taking an element and returning a <code>bool</code>.</p>\n<pre class='ml'><code class='ml'>every [] (fun x -&gt; x mod 2 = 0) = true;;\nevery [2;4;6] (fun x -&gt; x mod 2 = 0 ) = true;;\nevery [1;-3;5] (fun x -&gt; x &gt; 0) = false;;\n</code></pre></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_List", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_1 of 'a93 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a93 ], bool)"]]}, {"path": "Belt_List", "name": "some", "type": "let some: (t('a), 'a => bool) => bool", "docs": "<p><code>some xs p</code></p>\n<p>Returns: <p>true if at least one of the elements in <code>xs</code> satifies <code>p</code>, where <code>p</code> is a <em>predicate</em>: a function taking an element and returning a <code>bool</code>.</p>\n<pre class='ml'><code class='ml'>some [] (fun x -&gt; x mod 2 = 0) = false ;;\nsome [1;2;4] (fun x -&gt; x mod 2 = 0) = true;;\nsome [-1;-3;-5] (fun x -&gt; x &gt; 0) = false;;\n</code></pre></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_List", "name": "every2U", "type": "let every2U: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a92 * 'b22 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a92 * 'b22 ], bool)"]]}, {"path": "Belt_List", "name": "every2", "type": "let every2: (t('a), t('b), ('a, 'b) => bool) => bool", "docs": "<p><code>every2 xs ys p</code> returns true if predicate <code>p xi yi</code> is true for all pairs of elements up to the shorter length (i.e. <code>min (length xs) (length ys)</code>)</p>\n<pre class='ml'><code class='ml'>every2 [1;2;3] [0;1] (&gt;) = true;;\nevery2 [] [1] (fun  x y -&gt; x &gt; y) = true;;\nevery2 [2;3] [1] (fun  x y -&gt; x &gt; y) = true;;\nevery2 [0;1] [5;0] (fun x y -&gt; x &gt; y) = false;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_List", "name": "some2U", "type": "let some2U: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a91 * 'b21 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a91 * 'b21 ], bool)"]]}, {"path": "Belt_List", "name": "some2", "type": "let some2: (t('a), t('b), ('a, 'b) => bool) => bool", "docs": "<p><code>some2 xs ys p</code> returns true if <code>p xi yi</code> is true for any pair of elements up to the shorter length (i.e. <code>min (length xs) (length ys)</code>)</p>\n<pre class='ml'><code class='ml'>some2 [0;2] [1;0;3] (&gt;) = true ;;\nsome2 [] [1] (fun  x y -&gt; x &gt; y) =  false;;\nsome2 [2;3] [1;4] (fun  x y -&gt; x &gt; y) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_List", "name": "cmpByLength", "type": "let cmpByLength: (t('a), t('a)) => int", "docs": "<p><code>cmpByLength l1 l2</code></p>\n<p>Compare two lists solely by length. Returns -1 if <code>length l1</code> is less than <code>length l2</code>, 0 if <code>length l1</code> equals <code>length l2</code>, and 1 if <code>length l1</code> is greater than <code>length l2</code>.</p>\n<pre class='ml'><code class='ml'>cmpByLength [1;2] [3;4;5;6] = -1;;\ncmpByLength [1;2;3] [4;5;6] = 0;;\ncmpByLength [1;2;3;4] [5;6] = 1;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt_List", "name": "cmpU", "type": "let cmpU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a90 * 'a90 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a90 * 'a90 ], int)"]]}, {"path": "Belt_List", "name": "cmp", "type": "let cmp: (t('a), t('a), ('a, 'a) => int) => int", "docs": "<p>Compare elements one by one <code>f x y</code>. <code>f</code> returns</p>\n<ul><li><p>a negative number if <code>x</code> is \226\128\156less than\226\128\157 <code>y</code></p>\n</li><li><p>zero if <code>x</code> is \226\128\156equal to\226\128\157 <code>y</code></p>\n</li><li><p>a positive number if <code>x</code> is \226\128\156greater than\226\128\157 <code>y</code> The comparison returns the first non-zero result of <code>f</code>, or zero if <code>f</code> returns zero for all <code>x</code> and <code>y</code>. If all items have compared equal, but <code>xs</code> is exhausted first, return -1. (<code>xs</code> is shorter) If all items have compared equal, but <code>ys</code> is exhausted first, return 1 (<code>xs</code> is longer)</p>\n</li></ul><pre class='ml'><code class='ml'>cmp [3] [3;7] (fun a b -&gt; compare a b) = -1\ncmp [5;3] [5] (fun a b -&gt; compare a b)  = 1\ncmp [|1; 3; 5|] [|1; 4; 2|] (fun a b -&gt; compare a b) = -1;;\ncmp [|1; 3; 5|] [|1; 2; 3|] (fun a b -&gt; compare a b) = 1;;\ncmp [|1; 3; 5|] [|1; 3; 5|] (fun a b -&gt; compare a b) = 0;;\n</code></pre><p><strong>Attention</strong>: The total ordering of List is different from Array, for Array, we compare the length first and, only if the lengths are equal, elements one by one. For lists, we just compare elements one by one</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_List", "name": "eqU", "type": "let eqU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a89 * 'a89 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a89 * 'a89 ], bool)"]]}, {"path": "Belt_List", "name": "eq", "type": "let eq: (t('a), t('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq xs ys eqElem</code> check equality of <code>xs</code> and <code>ys</code> using <code>eqElem</code> for equality on elements, where <code>eqElem</code> is a function that returns true if items <code>x</code> and <code>y</code> meet some criterion for equality, false otherwise. <code>eq</code> false if length of <code>xs</code> and <code>ys</code> are not the same.</p>\n<pre class='ml'><code class='ml'>eq [1;2;3] [1;2] (=) = false ;;\neq [1;2] [1;2] (=) = true;;\neq [1; 2; 3] [-1; -2; -3] (fun a b -&gt; abs a = abs b) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_List", "name": "hasU", "type": "let hasU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'a88 * 'b20 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'a88 * 'b20 ], bool)"]]}, {"path": "Belt_List", "name": "has", "type": "let has: (t('a), 'b, ('a, 'b) => bool) => bool", "docs": "<p><code>has xs eqFcn</code> returns true if the list contains at least one element for which <code>eqFcn x</code> returns true</p>\n<pre class='ml'><code class='ml'>has [1;2;3] 2 (=) = true;;\nhas [1;2;3] 4 (=) = false;;\nhas [-1;-2;-3] 2 (fun a b -&gt; abs a = abs b) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_List", "name": "getByU", "type": "let getByU: (t('a), Js.Internal.fn([ `Arity_1 of 'a87 ], bool)) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a87 ], bool)"]]}, {"path": "Belt_List", "name": "getBy", "type": "let getBy: (t('a), 'a => bool) => option('a)", "docs": "<p><code>getBy xs p</code> returns <code>Some value</code> for the first value in <code>xs</code> that satisifies the predicate function <code>p</code>; returns <code>None</code> if no element satisifies the function.</p>\n<pre class='ml'><code class='ml'>getBy [1;4;3;2] (fun x -&gt; x mod 2 = 0) = Some 4\ngetBy [15;13;11] (fun x -&gt; x mod 2 = 0) = None\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_List", "name": "keepU", "type": "let keepU: (t('a), Js.Internal.fn([ `Arity_1 of 'a86 ], bool)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a86 ], bool)"]]}, {"path": "Belt_List", "name": "keep", "type": "let keep: (t('a), 'a => bool) => t('a)", "docs": "<p><code>keep  xs p</code> returns a list of all elements in <code>xs</code> which satisfy the predicate function <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [1;2;3;4] (fun x -&gt; x mod 2 = 0) =\n[2;4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_List", "name": "keepMapU", "type": "let keepMapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a85 ], option('b))) => t('b)", "docs": "<p><code>keep  xs p</code> returns a list of all elements in <code>xs</code> which satisfy the predicate function <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [1;2;3;4] (fun x -&gt; x mod 2 = 0) =\n[2;4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a85 ], option('b))"]]}, {"path": "Belt_List", "name": "keepMap", "type": "let keepMap: (t('a), 'a => option('b)) => t('b)", "docs": "<p><code>keepMap xs f</code> applies <code>f</code> to each element of <code>xs</code>. If <code>f xi</code> returns <code>Some value</code>, then <code>value</code> is kept in the resulting list; if <code>f xi</code> returns <code>None</code>, the element is not retained in the result.</p>\n<pre class='ml'><code class='ml'>keepMap [1;2;3;4] (fun x -&gt; if x mod 2 = 0 then Some (-x ) else None)\n=\n[-2;-4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => option('b)"]]}, {"path": "Belt_List", "name": "partitionU", "type": "let partitionU: (t('a), Js.Internal.fn([ `Arity_1 of 'a84 ], bool)) => (t('a), t('a))", "docs": "<p><code>keepMap xs f</code> applies <code>f</code> to each element of <code>xs</code>. If <code>f xi</code> returns <code>Some value</code>, then <code>value</code> is kept in the resulting list; if <code>f xi</code> returns <code>None</code>, the element is not retained in the result.</p>\n<pre class='ml'><code class='ml'>keepMap [1;2;3;4] (fun x -&gt; if x mod 2 = 0 then Some (-x ) else None)\n=\n[-2;-4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a84 ], bool)"]]}, {"path": "Belt_List", "name": "partition", "type": "let partition: (t('a), 'a => bool) => (t('a), t('a))", "docs": "<p><code>partition xs p</code> creates a pair of lists; the first list consists of all elements of <code>xs</code> that satisfy the predicate function <code>p</code>; the second list consists of all elements of <code>xs</code> that do not satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>partition [1;2;3;4] (fun x -&gt; x mod 2 = 0) =\n([2;4], [1;3])\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_List", "name": "unzip", "type": "let unzip: t(('a, 'b)) => (t('a), t('b))", "docs": "<p><code>partition xs p</code> creates a pair of lists; the first list consists of all elements of <code>xs</code> that satisfy the predicate function <code>p</code>; the second list consists of all elements of <code>xs</code> that do not satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>partition [1;2;3;4] (fun x -&gt; x mod 2 = 0) =\n([2;4], [1;3])\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'b))"]]}, {"path": "Belt_List", "name": "getAssocU", "type": "let getAssocU: (t(('a, 'c)), 'b, Js.Internal.fn([ `Arity_2 of 'a83 * 'b19 ], bool)) => option('c)", "docs": "<p><code>unzip xs</code> takes a list of pairs and creates a pair of lists. The first list contains all the first items of the pairs; the second list contains all the second items.</p>\n<pre class='ml'><code class='ml'>unzip [(1,2) ; (3,4)] = ([1;3], [2;4]);;\nunzip [(1,2) ; (3,4) ; (5,6) ; (7,8)] = ([1;3;5;7], [2;4;6;8]);;\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'a83 * 'b19 ], bool)"]]}, {"path": "Belt_List", "name": "getAssoc", "type": "let getAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => option('c)", "docs": "<p><code>getAssoc xs k eq</code></p>\n<p>return the second element of a pair in <code>xs</code> where the first element equals <code>x</code> as per the predicate function <code>eq</code>, or <code>None</code> if not found</p>\n<pre class='ml'><code class='ml'>getAssoc [ 1, &quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot;] 2 (=) = Some &quot;b&quot;\ngetAssoc [9, &quot;morning&quot;; 15, &quot;afternoon&quot;; 22, &quot;night&quot;] 3 (fun a b -&gt; a mod 12 = b mod 12) = Some &quot;afternoon&quot;\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_List", "name": "hasAssocU", "type": "let hasAssocU: (t(('a, 'c)), 'b, Js.Internal.fn([ `Arity_2 of 'a82 * 'b18 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'a82 * 'b18 ], bool)"]]}, {"path": "Belt_List", "name": "hasAssoc", "type": "let hasAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => bool", "docs": "<p><code>hasAssoc xs k eq</code> return true if there is a pair in <code>xs</code> where the first element equals <code>k</code> as per the predicate funtion <code>eq</code></p>\n<pre class='ml'><code class='ml'>hasAssoc [1, &quot;a&quot;; 2, &quot;b&quot;; 3,&quot;c&quot;] 1 (=) = true;;\nhasAssoc [9, &quot;morning&quot;; 15, &quot;afternoon&quot;; 22, &quot;night&quot;] 3 (fun a b -&gt; a mod 12 = b mod 12) = true;;\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_List", "name": "removeAssocU", "type": "let removeAssocU: (t(('a, 'c)), 'b, Js.Internal.fn([ `Arity_2 of 'a81 * 'b17 ], bool)) => t(\n  ('a, 'c)\n)", "docs": null, "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'a81 * 'b17 ], bool)"]]}, {"path": "Belt_List", "name": "removeAssoc", "type": "let removeAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => t(('a, 'c))", "docs": "<p><code>removeAssoc xs k eq</code> Return a list after removing the first pair whose first value is <code>k</code> per the equality predicate <code>eq</code>; if not found, return a new list identical to <code>xs</code>.</p>\n<pre class='ml'><code class='ml'>removeAssoc [1,&quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot; ] 1 (=) =\n  [2, &quot;b&quot;; 3, &quot;c&quot;]\nremoveAssoc [1,&quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot; ] 99 (=) =\n  [1, &quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot;]\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_List", "name": "setAssocU", "type": "let setAssocU: (t(('a, 'c)), 'a, 'c, Js.Internal.fn([ `Arity_2 of 'a80 * 'a80 ], bool)) => t(\n  ('a, 'c)\n)", "docs": null, "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'a"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'a80 * 'a80 ], bool)"]]}, {"path": "Belt_List", "name": "setAssoc", "type": "let setAssoc: (t(('a, 'c)), 'a, 'c, ('a, 'a) => bool) => t(('a, 'c))", "docs": "<p><code>setAssoc xs k v eq</code> if <code>k</code> exists in <code>xs</code> by satisfying the <code>eq</code> predicate, return a new list with the key and value replaced by the new <code>k</code> and <code>v</code>; otherwise, return a new list with the pair <code>k, v</code> added to the head of <code>xs</code>.</p>\n<pre class='ml'><code class='ml'>setAssoc [1,&quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot;] 2 &quot;x&quot; (=) =\n[1,&quot;a&quot;; 2, &quot;x&quot;; 3,&quot;c&quot;] ;; \n\nsetAssoc [1,&quot;a&quot;; 3, &quot;c&quot;] 2 &quot;b&quot; (=) = \n[2,&quot;b&quot;; 1,&quot;a&quot;; 3, &quot;c&quot;]\n\nsetAssoc [9, &quot;morning&quot;; 3, &quot;morning?!&quot;; 22, &quot;night&quot;] 15 &quot;afternoon&quot;\n  (fun a b -&gt; a mod 12 = b mod 12) = [9, &quot;morning&quot;; 15, &quot;afternoon&quot;; 22, &quot;night&quot;]\n</code></pre><p>Note carefully the last example! Since <code>15 mod 12</code> equals <code>3 mod 12</code>, <em>both</em> the key and value are replaced in the list.</p>\n", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'a"], ["", "'c"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_List", "name": "sortU", "type": "let sortU: (t('a), Js.Internal.fn([ `Arity_2 of 'a79 * 'a79 ], int)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a79 * 'a79 ], int)"]]}, {"path": "Belt_List", "name": "sort", "type": "let sort: (t('a), ('a, 'a) => int) => t('a)", "docs": "<p><code>sort xs</code> Returns a sorted list.</p>\n<pre class='ml'><code class='ml'>sort [5; 4; 9; 3; 7] (fun a b -&gt; a - b) = [3; 4; 5; 7; 9]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "", "name": "Belt_List", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpByLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>drop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatten\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getAssoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getAssocU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hasAssoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hasAssocU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hasU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>head\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>headExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeAssoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeAssocU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseConcat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setAssoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setAssocU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sortU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitAt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tail\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tailExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>take\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unzip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipByU\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_internalSetString", "name": "value", "type": "type value = string", "docs": null, "kind": "type"}, {"path": "Belt_internalSetString.S", "name": "element", "type": "type element = string", "docs": null, "kind": "type"}, {"path": "Belt_internalSetString.S", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalSetString.S", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalSetString.S", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalSetString.S", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalSetString.S", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_internalSetString.S", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalSetString.S", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalSetString.S", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalSetString", "name": "S", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": null, "kind": "module"}, {"path": "Belt_internalSetString.N", "name": "t", "type": "type t('value) = Js.null(node('value))", "docs": null, "kind": "type"}, {"path": "Belt_internalSetString.N", "name": "node", "type": "type node('value)", "docs": null, "kind": "type"}, {"path": "Belt_internalSetString.N", "name": "value", "type": "let value: node('value) => 'value", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalSetString.N", "name": "height", "type": "let height: node('value) => int", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalSetString.N", "name": "leftSet", "type": "let leftSet: (node('value), t('value)) => unit", "docs": null, "kind": "value", "args": [["", "node('value)"], ["", "t('value)"]]}, {"path": "Belt_internalSetString.N", "name": "left", "type": "let left: node('value) => t('value)", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalSetString.N", "name": "rightSet", "type": "let rightSet: (node('value), t('value)) => unit", "docs": null, "kind": "value", "args": [["", "node('value)"], ["", "t('value)"]]}, {"path": "Belt_internalSetString.N", "name": "right", "type": "let right: node('value) => t('value)", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalSetString.N", "name": "cmp", "type": "type cmp('a, 'b) = Belt_Id.cmp('a, 'b)", "docs": null, "kind": "type"}, {"path": "Belt_internalSetString.N", "name": "toOpt", "type": "let toOpt: Js.null('a) => option('a)", "docs": null, "kind": "value", "args": [["", "Js.null('a)"]]}, {"path": "Belt_internalSetString.N", "name": "return", "type": "let return: 'a => Js.null('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalSetString.N", "name": "empty", "type": "let empty: Js.null('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalSetString.N", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "create", "type": "let create: (t('a), 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "bal", "type": "let bal: (t('a), 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "singleton", "type": "let singleton: 'a => t('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalSetString.N", "name": "minimum", "type": "let minimum: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "minUndefined", "type": "let minUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "maximum", "type": "let maximum: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "maxUndefined", "type": "let maxUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "removeMinAuxWithRef", "type": "let removeMinAuxWithRef: (node('a), Pervasives.ref('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "node('a)"], ["", "Pervasives.ref('a)"]]}, {"path": "Belt_internalSetString.N", "name": "empty", "type": "let empty: t('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalSetString.N", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "stackAllLeft", "type": "let stackAllLeft: (t('a), list(node('a))) => list(node('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "list(node('a))"]]}, {"path": "Belt_internalSetString.N", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_1 of 'a150 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a150 ], unit)"]]}, {"path": "Belt_internalSetString.N", "name": "forEach", "type": "let forEach: (t('a), 'a => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => unit"]]}, {"path": "Belt_internalSetString.N", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'b37 * 'a149 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b37 * 'a149 ], 'b)"]]}, {"path": "Belt_internalSetString.N", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt_internalSetString.N", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a148 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a148 ], bool)"]]}, {"path": "Belt_internalSetString.N", "name": "every", "type": "let every: (t('a), 'a => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetString.N", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_1 of 'a147 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a147 ], bool)"]]}, {"path": "Belt_internalSetString.N", "name": "some", "type": "let some: (t('a), 'a => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetString.N", "name": "joinShared", "type": "let joinShared: (t('a), 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "concatShared", "type": "let concatShared: (t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "keepSharedU", "type": "let keepSharedU: (t('a), Js.Internal.fn([ `Arity_1 of 'a146 ], bool)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a146 ], bool)"]]}, {"path": "Belt_internalSetString.N", "name": "keepShared", "type": "let keepShared: (t('a), 'a => bool) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetString.N", "name": "keepCopyU", "type": "let keepCopyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a145 ], bool)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a145 ], bool)"]]}, {"path": "Belt_internalSetString.N", "name": "keepCopy", "type": "let keepCopy: (t('a), 'a => bool) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetString.N", "name": "partitionSharedU", "type": "let partitionSharedU: (t('a), Js.Internal.fn([ `Arity_1 of 'a144 ], bool)) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a144 ], bool)"]]}, {"path": "Belt_internalSetString.N", "name": "partitionShared", "type": "let partitionShared: (t('a), 'a => bool) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetString.N", "name": "partitionCopyU", "type": "let partitionCopyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a143 ], bool)) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a143 ], bool)"]]}, {"path": "Belt_internalSetString.N", "name": "partitionCopy", "type": "let partitionCopy: (t('a), 'a => bool) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetString.N", "name": "lengthNode", "type": "let lengthNode: node('a) => int", "docs": null, "kind": "value", "args": [["", "node('a)"]]}, {"path": "Belt_internalSetString.N", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "toList", "type": "let toList: t('a) => list('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "fillArray", "type": "let fillArray: (node('a), int, array('a)) => int", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "node('a)"], ["", "int"], ["", "array('a)"]]}, {"path": "Belt_internalSetString.N", "name": "toArray", "type": "let toArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetString.N", "name": "fromSortedArrayAux", "type": "let fromSortedArrayAux: (array('a), int, int) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalSetString.N", "name": "fromSortedArrayRevAux", "type": "let fromSortedArrayRevAux: (array('a), int, int) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalSetString.N", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array('a) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetString.N", "name": "has", "type": "let has: (t('a), 'a, ~cmp: cmp('a, 'b)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetString.N", "name": "cmp", "type": "let cmp: (t('a), t('a), ~cmp: cmp('a, 'b)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetString.N", "name": "eq", "type": "let eq: (t('a), t('a), ~cmp: cmp('a, 'b)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetString.N", "name": "subset", "type": "let subset: (t('a), t('a), ~cmp: cmp('a, 'b)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetString.N", "name": "get", "type": "let get: (t('a), 'a, ~cmp: cmp('a, 'b)) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetString.N", "name": "getUndefined", "type": "let getUndefined: (t('a), 'a, ~cmp: cmp('a, 'b)) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetString.N", "name": "getExn", "type": "let getExn: (t('a), 'a, ~cmp: cmp('a, 'b)) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetString.N", "name": "fromArray", "type": "let fromArray: (array('a), ~cmp: cmp('a, 'b)) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetString.N", "name": "addMutate", "type": "let addMutate: (~cmp: cmp('a, 'b), t('a), 'a) => t('a)", "docs": null, "kind": "value", "args": [["cmp", "cmp('a, 'b)"], ["", "t('a)"], ["", "'a"]]}, {"path": "Belt_internalSetString.N", "name": "balMutate", "type": "let balMutate: node('a) => node('a)", "docs": null, "kind": "value", "args": [["", "node('a)"]]}, {"path": "Belt_internalSetString.N", "name": "removeMinAuxWithRootMutate", "type": "let removeMinAuxWithRootMutate: (node('a), node('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "node('a)"], ["", "node('a)"]]}, {"path": "Belt_internalSetString", "name": "N", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>balMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayRevAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>joinShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepCopy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepCopyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lengthNode\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionCopy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionCopyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRef\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRootMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>singleton\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stackAllLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOpt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp", "docs": null, "kind": "module"}, {"path": "Belt_internalSetString.A", "name": "length", "type": "let length: array('a) => int", "docs": "<p><code>length xs</code> return the size of the array</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetString.A", "name": "size", "type": "let size: array('a) => int", "docs": "<p><strong>See</strong> length</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetString.A", "name": "get", "type": "let get: (array('a), int) => option('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetString.A", "name": "getExn", "type": "let getExn: (array('a), int) => 'a", "docs": "<p><code>getExn arr i</code></p>\n<p><strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetString.A", "name": "getUnsafe", "type": "let getUnsafe: (array('a), int) => 'a", "docs": "<p><code>getUnasfe arr i</code></p>\n<p><strong>Unsafe</strong></p>\n<p>no bounds checking, this would cause type error if <code>i</code> does not stay within range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetString.A", "name": "getUndefined", "type": "let getUndefined: (array('a), int) => Js.undefined('a)", "docs": "<p><code>getUndefined arr i</code></p>\n<p>It does the samething in the runtime as getUnsafe, it is <em>type safe</em> since the return type still track whether it is in range or not</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetString.A", "name": "set", "type": "let set: (array('a), int, 'a) => bool", "docs": "<p><code>set arr n x</code> modifies <code>arr</code> in place, it replaces the nth element of <code>arr</code> with <code>x</code></p>\n<p>Returns: <p>false means not updated due to out of range</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalSetString.A", "name": "setExn", "type": "let setExn: (array('a), int, 'a) => unit", "docs": "<p><code>setExn arr i x</code> <strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalSetString.A", "name": "setUnsafe", "type": "let setUnsafe: (array('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalSetString.A", "name": "shuffleInPlace", "type": "let shuffleInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetString.A", "name": "shuffle", "type": "let shuffle: array('a) => array('a)", "docs": "<p><code>shuffle xs</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetString.A", "name": "reverseInPlace", "type": "let reverseInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetString.A", "name": "reverse", "type": "let reverse: array('a) => array('a)", "docs": "<p><code>reverse x</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetString.A", "name": "makeUninitialized", "type": "let makeUninitialized: int => array(Js.undefined('a))", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Belt_internalSetString.A", "name": "makeUninitializedUnsafe", "type": "let makeUninitializedUnsafe: int => array('a)", "docs": "<p><code>makeUninitializedUnsafe n</code></p>\n<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Belt_internalSetString.A", "name": "make", "type": "let make: (int, 'a) => array('a)", "docs": "<p><code>make n e</code> return an array of size <code>n</code> filled with value <code>e</code></p>\n<p>Returns: <p>an empty array when <code>n</code> is negative.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Belt_internalSetString.A", "name": "range", "type": "let range: (int, int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Belt_internalSetString.A", "name": "rangeBy", "type": "let rangeBy: (int, int, ~step: int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"]]}, {"path": "Belt_internalSetString.A", "name": "makeByU", "type": "let makeByU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_internalSetString.A", "name": "makeBy", "type": "let makeBy: (int, int => 'a) => array('a)", "docs": "<p><code>makeBy n f</code></p>\n<p>return an empty array when <code>n</code> is negative return an array of size <code>n</code> populated by <code>f i</code> start from <code>0</code> to <code>n - 1</code></p>\n<pre class='ml'><code class='ml'>makeBy 5 (fun i -&gt; i) = [|0;1;2;3;4|]\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_internalSetString.A", "name": "makeByAndShuffleU", "type": "let makeByAndShuffleU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_internalSetString.A", "name": "makeByAndShuffle", "type": "let makeByAndShuffle: (int, int => 'a) => array('a)", "docs": "<p><code>makeByAndShuffle n f</code></p>\n<p>Equivalent to <code>shuffle (makeBy n f)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_internalSetString.A", "name": "zip", "type": "let zip: (array('a), array('b)) => array(('a, 'b))", "docs": "<p><code>zip a b</code></p>\n<p>Stop with the shorter array</p>\n<pre class='ml'><code class='ml'>zip [|1;2] [|1;2;3|] = [| (1,2); (2;2)|]\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"]]}, {"path": "Belt_internalSetString.A", "name": "zipByU", "type": "let zipByU: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)) => array('c)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)"]]}, {"path": "Belt_internalSetString.A", "name": "zipBy", "type": "let zipBy: (array('a), array('b), ('a, 'b) => 'c) => array('c)", "docs": "<p><code>zipBy xs ys f</code></p>\n<p>Stops with shorter array</p>\n<p>Equivalent to <code>map (zip xs ys) (fun (a,b) -&gt; f a b) </code></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_internalSetString.A", "name": "concat", "type": "let concat: (array('a), array('a)) => array('a)", "docs": "<p><code>concat xs ys</code></p>\n<p>Returns: <p>a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>, so even if <code>v1</code> or <code>v2</code> is empty, it can not be shared</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"]]}, {"path": "Belt_internalSetString.A", "name": "concatMany", "type": "let concatMany: array(array('a)) => array('a)", "docs": "<p><code>concatMany xss</code></p>\n<p>Returns: <p>a fresh array as the concatenation of <code>xss</code></p></p>\n", "kind": "value", "args": [["", "array(array('a))"]]}, {"path": "Belt_internalSetString.A", "name": "slice", "type": "let slice: (array('a), ~offset: int, ~len: int) => array('a)", "docs": "<p><code>slice arr offset len</code></p>\n<p><code>offset</code> can be negative, <code>slice arr -1 1</code> means get the last element as a singleton array</p>\n<p><code>slice arr -(very_large_index) len</code> will do a copy of the array</p>\n<p>if the array does not have enough data, <code>slice</code> extracts through the end of sequence</p>\n", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"]]}, {"path": "Belt_internalSetString.A", "name": "copy", "type": "let copy: array('a) => array('a)", "docs": "<p><code>copy a</code></p>\n<p>Returns: <p>a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetString.A", "name": "fill", "type": "let fill: (array('a), ~offset: int, ~len: int, 'a) => unit", "docs": "<p><code>fill arr ~offset ~len x</code></p>\n<p>Modifies <code>arr</code> in place, storing <code>x</code> in elements number <code>offset</code> to <code>offset + len - 1</code>.</p>\n<p><code>offset</code> can be negative</p>\n<p><code>fill arr offset:(-1) len:1 </code> means fill the last element, if the array does not have enough data, <code>fill</code> will ignore it</p>\n<pre class='ml'><code class='ml'>\nlet arr = makeBy 5 (fun i -&gt; i) ;;\nfill arr ~offset:2 ~len:2 0 ;;\narr = [|0;1;0;0;4|];;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"], ["", "'a"]]}, {"path": "Belt_internalSetString.A", "name": "blit", "type": "let blit: (~src: array('a), ~srcOffset: int, ~dst: array('a), ~dstOffset: int, ~len: int) => unit", "docs": "<p><code>blit ~src:v1 ~srcOffset:o1 ~dst:v2 ~dstOffset:o2 ~len</code></p>\n<p>copies <code>len</code> elements from array <code>v1</code>, starting at element number <code>o1</code>, to array <code>v2</code>, starting at element number <code>o2</code>.</p>\n<p>It works correctly even if <code>v1</code> and <code>v2</code> are the same array, and the source and destination chunks overlap.</p>\n<p><code>offset</code> can be negative, <code>-1</code> means <code>len - 1</code>, if <code>len + offset</code> is still negative, it will be set as 0</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_internalSetString.A", "name": "blitUnsafe", "type": "let blitUnsafe: (\n  ~src: array('a),\n  ~srcOffset: int,\n  ~dst: array('a),\n  ~dstOffset: int,\n  ~len: int\n) => unit", "docs": "<p><strong>Unsafe</strong> blit without bounds checking</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_internalSetString.A", "name": "forEachU", "type": "let forEachU: (array('a), Js.Internal.fn([ `Arity_1 of 'a134 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a134 ], unit)"]]}, {"path": "Belt_internalSetString.A", "name": "forEach", "type": "let forEach: (array('a), 'a => unit) => unit", "docs": "<p><code>forEach xs f</code></p>\n<p>Call f on each element of <code>xs</code> from the beginning to end</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => unit"]]}, {"path": "Belt_internalSetString.A", "name": "mapU", "type": "let mapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)"]]}, {"path": "Belt_internalSetString.A", "name": "map", "type": "let map: (array('a), 'a => 'b) => array('b)", "docs": "<p><code>map xs f </code></p>\n<p>Returns: <p>a new array by calling <code>f</code> to element of <code>xs</code> from the beginning to end</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => 'b"]]}, {"path": "Belt_internalSetString.A", "name": "keepU", "type": "let keepU: (array('a), Js.Internal.fn([ `Arity_1 of 'a132 ], bool)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a132 ], bool)"]]}, {"path": "Belt_internalSetString.A", "name": "keep", "type": "let keep: (array('a), 'a => bool) => array('a)", "docs": "<p><code>keep xs p </code></p>\n<p>Returns: <p>a new array that keep all elements satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [|1;2;3|] (fun x -&gt; x mod  2 = 0) = [|2|]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetString.A", "name": "keepMapU", "type": "let keepMapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))"]]}, {"path": "Belt_internalSetString.A", "name": "keepMap", "type": "let keepMap: (array('a), 'a => option('b)) => array('b)", "docs": "<p><code>keepMap xs p</code></p>\n<p>Returns: <p>a new array that keep all elements that return a non-None applied <code>p</code></p>\n<pre class='ml'><code class='ml'>keepMap [|1;2;3|] (fun x -&gt; if x mod 2 then Some x else None)\n= [| 2 |]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => option('b)"]]}, {"path": "Belt_internalSetString.A", "name": "forEachWithIndexU", "type": "let forEachWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)"]]}, {"path": "Belt_internalSetString.A", "name": "forEachWithIndex", "type": "let forEachWithIndex: (array('a), (int, 'a) => unit) => unit", "docs": "<p><code>forEachWithIndex xs f</code></p>\n<p>The same with forEach, except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => unit"]]}, {"path": "Belt_internalSetString.A", "name": "mapWithIndexU", "type": "let mapWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)"]]}, {"path": "Belt_internalSetString.A", "name": "mapWithIndex", "type": "let mapWithIndex: (array('a), (int, 'a) => 'b) => array('b)", "docs": "<p><code>mapWithIndex xs f </code></p>\n<p>The same with map except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt_internalSetString.A", "name": "reduceU", "type": "let reduceU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)"]]}, {"path": "Belt_internalSetString.A", "name": "reduce", "type": "let reduce: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduce xs init f</code></p>\n<pre class='ml'><code class='ml'>reduce [|2;3;4|] 1 (+) = 10\n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_internalSetString.A", "name": "reduceReverseU", "type": "let reduceReverseU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)"]]}, {"path": "Belt_internalSetString.A", "name": "reduceReverse", "type": "let reduceReverse: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduceReverse xs init f</code></p>\n<pre class='ml'><code class='ml'>reduceReverse [|1;2;3;4|] 100 (-) = 90 \n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_internalSetString.A", "name": "reduceReverse2U", "type": "let reduceReverse2U: (\n  array('a),\n  array('b),\n  'c,\n  Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)\n) => 'c", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)"]]}, {"path": "Belt_internalSetString.A", "name": "reduceReverse2", "type": "let reduceReverse2: (array('a), array('b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": "<pre class='ml'><code class='ml'>reduceReverse2 [|1;2;3|] [|1;2|] 0 (fun acc x y -&gt; acc + x + y) = 6\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_internalSetString.A", "name": "someU", "type": "let someU: (array('a), Js.Internal.fn([ `Arity_1 of 'a125 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a125 ], bool)"]]}, {"path": "Belt_internalSetString.A", "name": "some", "type": "let some: (array('a), 'a => bool) => bool", "docs": "<p><code>some xs p</code></p>\n<p>Returns: <p>true if one of element satifies <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetString.A", "name": "everyU", "type": "let everyU: (array('a), Js.Internal.fn([ `Arity_1 of 'a124 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a124 ], bool)"]]}, {"path": "Belt_internalSetString.A", "name": "every", "type": "let every: (array('a), 'a => bool) => bool", "docs": "<p><code>every xs p</code></p>\n<p>Returns: <p>true if all elements satisfy <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetString.A", "name": "every2U", "type": "let every2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)"]]}, {"path": "Belt_internalSetString.A", "name": "every2", "type": "let every2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>every2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>every2 [|1;2;3|] [|0;1|] (&gt;) = true;;\n(every2 [||] [|1|] (fun   x y -&gt; x &gt; y)) = true;;\n(every2 [|2;3|] [|1|] (fun   x y -&gt; x &gt; y)) = true;; \n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalSetString.A", "name": "some2U", "type": "let some2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)"]]}, {"path": "Belt_internalSetString.A", "name": "some2", "type": "let some2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>some2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>some2 [|0;2|] [|1;0;3|] (&gt;) = true ;;\n(some2 [||] [|1|] (fun   x y -&gt; x &gt; y)) =  false;;\n(some2 [|2;3|] [|1;4|] (fun   x y -&gt; x &gt; y)) = true;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalSetString.A", "name": "cmpU", "type": "let cmpU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)"]]}, {"path": "Belt_internalSetString.A", "name": "cmp", "type": "let cmp: (array('a), array('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp a b</code></p>\n<ul><li><p>Compared by length if <code>length a &lt;&gt; length b</code></p>\n</li><li><p>Otherwise compare one by one <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalSetString.A", "name": "eqU", "type": "let eqU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)"]]}, {"path": "Belt_internalSetString.A", "name": "eq", "type": "let eq: (array('a), array('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq a b</code></p>\n<ul><li><p>return false if length is not the same</p>\n</li><li><p>equal one by one using <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_internalSetString.A", "name": "truncateToLengthUnsafe", "type": "let truncateToLengthUnsafe: (array('a), int) => unit", "docs": "<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetString", "name": "A", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blitUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffleU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitialized\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitializedUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>range\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rangeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffleInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncateToLengthUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipByU", "docs": null, "kind": "module"}, {"path": "Belt_internalSetString", "name": "t", "type": "type t = N.t(value)", "docs": null, "kind": "type"}, {"path": "Belt_internalSetString", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_internalSetString", "name": "compareAux", "type": "let compareAux: (list(N.node(value)), list(N.node(value))) => int", "docs": null, "kind": "value", "args": [["", "list(N.node(value))"], ["", "list(N.node(value))"]]}, {"path": "Belt_internalSetString", "name": "cmp", "type": "let cmp: (N.t(value), N.t(value)) => int", "docs": null, "kind": "value", "args": [["", "N.t(value)"], ["", "N.t(value)"]]}, {"path": "Belt_internalSetString", "name": "eq", "type": "let eq: (t, N.t(value)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "N.t(value)"]]}, {"path": "Belt_internalSetString", "name": "subset", "type": "let subset: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_internalSetString", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_internalSetString", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.Undefined.t(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_internalSetString", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_internalSetString", "name": "addMutate", "type": "let addMutate: (N.t(value), value) => N.t(value)", "docs": null, "kind": "value", "args": [["", "N.t(value)"], ["", "value"]]}, {"path": "Belt_internalSetString", "name": "fromArray", "type": "let fromArray: array(value) => N.t(value)", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "", "name": "Belt_internalSetString", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compareAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>A\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>N\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>S", "docs": null, "kind": "module"}, {"path": "Belt_internalSetInt", "name": "value", "type": "type value = int", "docs": null, "kind": "type"}, {"path": "Belt_internalSetInt.S", "name": "element", "type": "type element = int", "docs": null, "kind": "type"}, {"path": "Belt_internalSetInt.S", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalSetInt.S", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalSetInt.S", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalSetInt.S", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalSetInt.S", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_internalSetInt.S", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalSetInt.S", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalSetInt.S", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalSetInt", "name": "S", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": null, "kind": "module"}, {"path": "Belt_internalSetInt.N", "name": "t", "type": "type t('value) = Js.null(node('value))", "docs": null, "kind": "type"}, {"path": "Belt_internalSetInt.N", "name": "node", "type": "type node('value)", "docs": null, "kind": "type"}, {"path": "Belt_internalSetInt.N", "name": "value", "type": "let value: node('value) => 'value", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalSetInt.N", "name": "height", "type": "let height: node('value) => int", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalSetInt.N", "name": "leftSet", "type": "let leftSet: (node('value), t('value)) => unit", "docs": null, "kind": "value", "args": [["", "node('value)"], ["", "t('value)"]]}, {"path": "Belt_internalSetInt.N", "name": "left", "type": "let left: node('value) => t('value)", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalSetInt.N", "name": "rightSet", "type": "let rightSet: (node('value), t('value)) => unit", "docs": null, "kind": "value", "args": [["", "node('value)"], ["", "t('value)"]]}, {"path": "Belt_internalSetInt.N", "name": "right", "type": "let right: node('value) => t('value)", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalSetInt.N", "name": "cmp", "type": "type cmp('a, 'b) = Belt_Id.cmp('a, 'b)", "docs": null, "kind": "type"}, {"path": "Belt_internalSetInt.N", "name": "toOpt", "type": "let toOpt: Js.null('a) => option('a)", "docs": null, "kind": "value", "args": [["", "Js.null('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "return", "type": "let return: 'a => Js.null('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalSetInt.N", "name": "empty", "type": "let empty: Js.null('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalSetInt.N", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "create", "type": "let create: (t('a), 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "bal", "type": "let bal: (t('a), 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "singleton", "type": "let singleton: 'a => t('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalSetInt.N", "name": "minimum", "type": "let minimum: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "minUndefined", "type": "let minUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "maximum", "type": "let maximum: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "maxUndefined", "type": "let maxUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "removeMinAuxWithRef", "type": "let removeMinAuxWithRef: (node('a), Pervasives.ref('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "node('a)"], ["", "Pervasives.ref('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "empty", "type": "let empty: t('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalSetInt.N", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "stackAllLeft", "type": "let stackAllLeft: (t('a), list(node('a))) => list(node('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "list(node('a))"]]}, {"path": "Belt_internalSetInt.N", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_1 of 'a150 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a150 ], unit)"]]}, {"path": "Belt_internalSetInt.N", "name": "forEach", "type": "let forEach: (t('a), 'a => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => unit"]]}, {"path": "Belt_internalSetInt.N", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'b37 * 'a149 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b37 * 'a149 ], 'b)"]]}, {"path": "Belt_internalSetInt.N", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt_internalSetInt.N", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a148 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a148 ], bool)"]]}, {"path": "Belt_internalSetInt.N", "name": "every", "type": "let every: (t('a), 'a => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetInt.N", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_1 of 'a147 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a147 ], bool)"]]}, {"path": "Belt_internalSetInt.N", "name": "some", "type": "let some: (t('a), 'a => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetInt.N", "name": "joinShared", "type": "let joinShared: (t('a), 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "concatShared", "type": "let concatShared: (t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "keepSharedU", "type": "let keepSharedU: (t('a), Js.Internal.fn([ `Arity_1 of 'a146 ], bool)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a146 ], bool)"]]}, {"path": "Belt_internalSetInt.N", "name": "keepShared", "type": "let keepShared: (t('a), 'a => bool) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetInt.N", "name": "keepCopyU", "type": "let keepCopyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a145 ], bool)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a145 ], bool)"]]}, {"path": "Belt_internalSetInt.N", "name": "keepCopy", "type": "let keepCopy: (t('a), 'a => bool) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetInt.N", "name": "partitionSharedU", "type": "let partitionSharedU: (t('a), Js.Internal.fn([ `Arity_1 of 'a144 ], bool)) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a144 ], bool)"]]}, {"path": "Belt_internalSetInt.N", "name": "partitionShared", "type": "let partitionShared: (t('a), 'a => bool) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetInt.N", "name": "partitionCopyU", "type": "let partitionCopyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a143 ], bool)) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a143 ], bool)"]]}, {"path": "Belt_internalSetInt.N", "name": "partitionCopy", "type": "let partitionCopy: (t('a), 'a => bool) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetInt.N", "name": "lengthNode", "type": "let lengthNode: node('a) => int", "docs": null, "kind": "value", "args": [["", "node('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "toList", "type": "let toList: t('a) => list('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "fillArray", "type": "let fillArray: (node('a), int, array('a)) => int", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "node('a)"], ["", "int"], ["", "array('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "toArray", "type": "let toArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "fromSortedArrayAux", "type": "let fromSortedArrayAux: (array('a), int, int) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalSetInt.N", "name": "fromSortedArrayRevAux", "type": "let fromSortedArrayRevAux: (array('a), int, int) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalSetInt.N", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array('a) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "has", "type": "let has: (t('a), 'a, ~cmp: cmp('a, 'b)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetInt.N", "name": "cmp", "type": "let cmp: (t('a), t('a), ~cmp: cmp('a, 'b)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetInt.N", "name": "eq", "type": "let eq: (t('a), t('a), ~cmp: cmp('a, 'b)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetInt.N", "name": "subset", "type": "let subset: (t('a), t('a), ~cmp: cmp('a, 'b)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetInt.N", "name": "get", "type": "let get: (t('a), 'a, ~cmp: cmp('a, 'b)) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetInt.N", "name": "getUndefined", "type": "let getUndefined: (t('a), 'a, ~cmp: cmp('a, 'b)) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetInt.N", "name": "getExn", "type": "let getExn: (t('a), 'a, ~cmp: cmp('a, 'b)) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetInt.N", "name": "fromArray", "type": "let fromArray: (array('a), ~cmp: cmp('a, 'b)) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalSetInt.N", "name": "addMutate", "type": "let addMutate: (~cmp: cmp('a, 'b), t('a), 'a) => t('a)", "docs": null, "kind": "value", "args": [["cmp", "cmp('a, 'b)"], ["", "t('a)"], ["", "'a"]]}, {"path": "Belt_internalSetInt.N", "name": "balMutate", "type": "let balMutate: node('a) => node('a)", "docs": null, "kind": "value", "args": [["", "node('a)"]]}, {"path": "Belt_internalSetInt.N", "name": "removeMinAuxWithRootMutate", "type": "let removeMinAuxWithRootMutate: (node('a), node('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "node('a)"], ["", "node('a)"]]}, {"path": "Belt_internalSetInt", "name": "N", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>balMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayRevAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>joinShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepCopy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepCopyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lengthNode\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionCopy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionCopyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRef\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRootMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>singleton\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stackAllLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOpt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp", "docs": null, "kind": "module"}, {"path": "Belt_internalSetInt.A", "name": "length", "type": "let length: array('a) => int", "docs": "<p><code>length xs</code> return the size of the array</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetInt.A", "name": "size", "type": "let size: array('a) => int", "docs": "<p><strong>See</strong> length</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetInt.A", "name": "get", "type": "let get: (array('a), int) => option('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "getExn", "type": "let getExn: (array('a), int) => 'a", "docs": "<p><code>getExn arr i</code></p>\n<p><strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "getUnsafe", "type": "let getUnsafe: (array('a), int) => 'a", "docs": "<p><code>getUnasfe arr i</code></p>\n<p><strong>Unsafe</strong></p>\n<p>no bounds checking, this would cause type error if <code>i</code> does not stay within range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "getUndefined", "type": "let getUndefined: (array('a), int) => Js.undefined('a)", "docs": "<p><code>getUndefined arr i</code></p>\n<p>It does the samething in the runtime as getUnsafe, it is <em>type safe</em> since the return type still track whether it is in range or not</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "set", "type": "let set: (array('a), int, 'a) => bool", "docs": "<p><code>set arr n x</code> modifies <code>arr</code> in place, it replaces the nth element of <code>arr</code> with <code>x</code></p>\n<p>Returns: <p>false means not updated due to out of range</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalSetInt.A", "name": "setExn", "type": "let setExn: (array('a), int, 'a) => unit", "docs": "<p><code>setExn arr i x</code> <strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalSetInt.A", "name": "setUnsafe", "type": "let setUnsafe: (array('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalSetInt.A", "name": "shuffleInPlace", "type": "let shuffleInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetInt.A", "name": "shuffle", "type": "let shuffle: array('a) => array('a)", "docs": "<p><code>shuffle xs</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetInt.A", "name": "reverseInPlace", "type": "let reverseInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetInt.A", "name": "reverse", "type": "let reverse: array('a) => array('a)", "docs": "<p><code>reverse x</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetInt.A", "name": "makeUninitialized", "type": "let makeUninitialized: int => array(Js.undefined('a))", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "makeUninitializedUnsafe", "type": "let makeUninitializedUnsafe: int => array('a)", "docs": "<p><code>makeUninitializedUnsafe n</code></p>\n<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "make", "type": "let make: (int, 'a) => array('a)", "docs": "<p><code>make n e</code> return an array of size <code>n</code> filled with value <code>e</code></p>\n<p>Returns: <p>an empty array when <code>n</code> is negative.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Belt_internalSetInt.A", "name": "range", "type": "let range: (int, int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "rangeBy", "type": "let rangeBy: (int, int, ~step: int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "makeByU", "type": "let makeByU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_internalSetInt.A", "name": "makeBy", "type": "let makeBy: (int, int => 'a) => array('a)", "docs": "<p><code>makeBy n f</code></p>\n<p>return an empty array when <code>n</code> is negative return an array of size <code>n</code> populated by <code>f i</code> start from <code>0</code> to <code>n - 1</code></p>\n<pre class='ml'><code class='ml'>makeBy 5 (fun i -&gt; i) = [|0;1;2;3;4|]\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_internalSetInt.A", "name": "makeByAndShuffleU", "type": "let makeByAndShuffleU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_internalSetInt.A", "name": "makeByAndShuffle", "type": "let makeByAndShuffle: (int, int => 'a) => array('a)", "docs": "<p><code>makeByAndShuffle n f</code></p>\n<p>Equivalent to <code>shuffle (makeBy n f)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_internalSetInt.A", "name": "zip", "type": "let zip: (array('a), array('b)) => array(('a, 'b))", "docs": "<p><code>zip a b</code></p>\n<p>Stop with the shorter array</p>\n<pre class='ml'><code class='ml'>zip [|1;2] [|1;2;3|] = [| (1,2); (2;2)|]\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"]]}, {"path": "Belt_internalSetInt.A", "name": "zipByU", "type": "let zipByU: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)) => array('c)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)"]]}, {"path": "Belt_internalSetInt.A", "name": "zipBy", "type": "let zipBy: (array('a), array('b), ('a, 'b) => 'c) => array('c)", "docs": "<p><code>zipBy xs ys f</code></p>\n<p>Stops with shorter array</p>\n<p>Equivalent to <code>map (zip xs ys) (fun (a,b) -&gt; f a b) </code></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_internalSetInt.A", "name": "concat", "type": "let concat: (array('a), array('a)) => array('a)", "docs": "<p><code>concat xs ys</code></p>\n<p>Returns: <p>a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>, so even if <code>v1</code> or <code>v2</code> is empty, it can not be shared</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"]]}, {"path": "Belt_internalSetInt.A", "name": "concatMany", "type": "let concatMany: array(array('a)) => array('a)", "docs": "<p><code>concatMany xss</code></p>\n<p>Returns: <p>a fresh array as the concatenation of <code>xss</code></p></p>\n", "kind": "value", "args": [["", "array(array('a))"]]}, {"path": "Belt_internalSetInt.A", "name": "slice", "type": "let slice: (array('a), ~offset: int, ~len: int) => array('a)", "docs": "<p><code>slice arr offset len</code></p>\n<p><code>offset</code> can be negative, <code>slice arr -1 1</code> means get the last element as a singleton array</p>\n<p><code>slice arr -(very_large_index) len</code> will do a copy of the array</p>\n<p>if the array does not have enough data, <code>slice</code> extracts through the end of sequence</p>\n", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "copy", "type": "let copy: array('a) => array('a)", "docs": "<p><code>copy a</code></p>\n<p>Returns: <p>a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalSetInt.A", "name": "fill", "type": "let fill: (array('a), ~offset: int, ~len: int, 'a) => unit", "docs": "<p><code>fill arr ~offset ~len x</code></p>\n<p>Modifies <code>arr</code> in place, storing <code>x</code> in elements number <code>offset</code> to <code>offset + len - 1</code>.</p>\n<p><code>offset</code> can be negative</p>\n<p><code>fill arr offset:(-1) len:1 </code> means fill the last element, if the array does not have enough data, <code>fill</code> will ignore it</p>\n<pre class='ml'><code class='ml'>\nlet arr = makeBy 5 (fun i -&gt; i) ;;\nfill arr ~offset:2 ~len:2 0 ;;\narr = [|0;1;0;0;4|];;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"], ["", "'a"]]}, {"path": "Belt_internalSetInt.A", "name": "blit", "type": "let blit: (~src: array('a), ~srcOffset: int, ~dst: array('a), ~dstOffset: int, ~len: int) => unit", "docs": "<p><code>blit ~src:v1 ~srcOffset:o1 ~dst:v2 ~dstOffset:o2 ~len</code></p>\n<p>copies <code>len</code> elements from array <code>v1</code>, starting at element number <code>o1</code>, to array <code>v2</code>, starting at element number <code>o2</code>.</p>\n<p>It works correctly even if <code>v1</code> and <code>v2</code> are the same array, and the source and destination chunks overlap.</p>\n<p><code>offset</code> can be negative, <code>-1</code> means <code>len - 1</code>, if <code>len + offset</code> is still negative, it will be set as 0</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "blitUnsafe", "type": "let blitUnsafe: (\n  ~src: array('a),\n  ~srcOffset: int,\n  ~dst: array('a),\n  ~dstOffset: int,\n  ~len: int\n) => unit", "docs": "<p><strong>Unsafe</strong> blit without bounds checking</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_internalSetInt.A", "name": "forEachU", "type": "let forEachU: (array('a), Js.Internal.fn([ `Arity_1 of 'a134 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a134 ], unit)"]]}, {"path": "Belt_internalSetInt.A", "name": "forEach", "type": "let forEach: (array('a), 'a => unit) => unit", "docs": "<p><code>forEach xs f</code></p>\n<p>Call f on each element of <code>xs</code> from the beginning to end</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => unit"]]}, {"path": "Belt_internalSetInt.A", "name": "mapU", "type": "let mapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)"]]}, {"path": "Belt_internalSetInt.A", "name": "map", "type": "let map: (array('a), 'a => 'b) => array('b)", "docs": "<p><code>map xs f </code></p>\n<p>Returns: <p>a new array by calling <code>f</code> to element of <code>xs</code> from the beginning to end</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => 'b"]]}, {"path": "Belt_internalSetInt.A", "name": "keepU", "type": "let keepU: (array('a), Js.Internal.fn([ `Arity_1 of 'a132 ], bool)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a132 ], bool)"]]}, {"path": "Belt_internalSetInt.A", "name": "keep", "type": "let keep: (array('a), 'a => bool) => array('a)", "docs": "<p><code>keep xs p </code></p>\n<p>Returns: <p>a new array that keep all elements satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [|1;2;3|] (fun x -&gt; x mod  2 = 0) = [|2|]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetInt.A", "name": "keepMapU", "type": "let keepMapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))"]]}, {"path": "Belt_internalSetInt.A", "name": "keepMap", "type": "let keepMap: (array('a), 'a => option('b)) => array('b)", "docs": "<p><code>keepMap xs p</code></p>\n<p>Returns: <p>a new array that keep all elements that return a non-None applied <code>p</code></p>\n<pre class='ml'><code class='ml'>keepMap [|1;2;3|] (fun x -&gt; if x mod 2 then Some x else None)\n= [| 2 |]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => option('b)"]]}, {"path": "Belt_internalSetInt.A", "name": "forEachWithIndexU", "type": "let forEachWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)"]]}, {"path": "Belt_internalSetInt.A", "name": "forEachWithIndex", "type": "let forEachWithIndex: (array('a), (int, 'a) => unit) => unit", "docs": "<p><code>forEachWithIndex xs f</code></p>\n<p>The same with forEach, except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => unit"]]}, {"path": "Belt_internalSetInt.A", "name": "mapWithIndexU", "type": "let mapWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)"]]}, {"path": "Belt_internalSetInt.A", "name": "mapWithIndex", "type": "let mapWithIndex: (array('a), (int, 'a) => 'b) => array('b)", "docs": "<p><code>mapWithIndex xs f </code></p>\n<p>The same with map except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt_internalSetInt.A", "name": "reduceU", "type": "let reduceU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)"]]}, {"path": "Belt_internalSetInt.A", "name": "reduce", "type": "let reduce: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduce xs init f</code></p>\n<pre class='ml'><code class='ml'>reduce [|2;3;4|] 1 (+) = 10\n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_internalSetInt.A", "name": "reduceReverseU", "type": "let reduceReverseU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)"]]}, {"path": "Belt_internalSetInt.A", "name": "reduceReverse", "type": "let reduceReverse: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduceReverse xs init f</code></p>\n<pre class='ml'><code class='ml'>reduceReverse [|1;2;3;4|] 100 (-) = 90 \n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_internalSetInt.A", "name": "reduceReverse2U", "type": "let reduceReverse2U: (\n  array('a),\n  array('b),\n  'c,\n  Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)\n) => 'c", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)"]]}, {"path": "Belt_internalSetInt.A", "name": "reduceReverse2", "type": "let reduceReverse2: (array('a), array('b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": "<pre class='ml'><code class='ml'>reduceReverse2 [|1;2;3|] [|1;2|] 0 (fun acc x y -&gt; acc + x + y) = 6\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_internalSetInt.A", "name": "someU", "type": "let someU: (array('a), Js.Internal.fn([ `Arity_1 of 'a125 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a125 ], bool)"]]}, {"path": "Belt_internalSetInt.A", "name": "some", "type": "let some: (array('a), 'a => bool) => bool", "docs": "<p><code>some xs p</code></p>\n<p>Returns: <p>true if one of element satifies <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetInt.A", "name": "everyU", "type": "let everyU: (array('a), Js.Internal.fn([ `Arity_1 of 'a124 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a124 ], bool)"]]}, {"path": "Belt_internalSetInt.A", "name": "every", "type": "let every: (array('a), 'a => bool) => bool", "docs": "<p><code>every xs p</code></p>\n<p>Returns: <p>true if all elements satisfy <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalSetInt.A", "name": "every2U", "type": "let every2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)"]]}, {"path": "Belt_internalSetInt.A", "name": "every2", "type": "let every2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>every2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>every2 [|1;2;3|] [|0;1|] (&gt;) = true;;\n(every2 [||] [|1|] (fun   x y -&gt; x &gt; y)) = true;;\n(every2 [|2;3|] [|1|] (fun   x y -&gt; x &gt; y)) = true;; \n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalSetInt.A", "name": "some2U", "type": "let some2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)"]]}, {"path": "Belt_internalSetInt.A", "name": "some2", "type": "let some2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>some2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>some2 [|0;2|] [|1;0;3|] (&gt;) = true ;;\n(some2 [||] [|1|] (fun   x y -&gt; x &gt; y)) =  false;;\n(some2 [|2;3|] [|1;4|] (fun   x y -&gt; x &gt; y)) = true;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalSetInt.A", "name": "cmpU", "type": "let cmpU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)"]]}, {"path": "Belt_internalSetInt.A", "name": "cmp", "type": "let cmp: (array('a), array('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp a b</code></p>\n<ul><li><p>Compared by length if <code>length a &lt;&gt; length b</code></p>\n</li><li><p>Otherwise compare one by one <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalSetInt.A", "name": "eqU", "type": "let eqU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)"]]}, {"path": "Belt_internalSetInt.A", "name": "eq", "type": "let eq: (array('a), array('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq a b</code></p>\n<ul><li><p>return false if length is not the same</p>\n</li><li><p>equal one by one using <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_internalSetInt.A", "name": "truncateToLengthUnsafe", "type": "let truncateToLengthUnsafe: (array('a), int) => unit", "docs": "<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalSetInt", "name": "A", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blitUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffleU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitialized\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitializedUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>range\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rangeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffleInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncateToLengthUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipByU", "docs": null, "kind": "module"}, {"path": "Belt_internalSetInt", "name": "t", "type": "type t = N.t(value)", "docs": null, "kind": "type"}, {"path": "Belt_internalSetInt", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_internalSetInt", "name": "compareAux", "type": "let compareAux: (list(N.node(value)), list(N.node(value))) => int", "docs": null, "kind": "value", "args": [["", "list(N.node(value))"], ["", "list(N.node(value))"]]}, {"path": "Belt_internalSetInt", "name": "cmp", "type": "let cmp: (N.t(value), N.t(value)) => int", "docs": null, "kind": "value", "args": [["", "N.t(value)"], ["", "N.t(value)"]]}, {"path": "Belt_internalSetInt", "name": "eq", "type": "let eq: (t, N.t(value)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "N.t(value)"]]}, {"path": "Belt_internalSetInt", "name": "subset", "type": "let subset: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt_internalSetInt", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_internalSetInt", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.Undefined.t(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_internalSetInt", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt_internalSetInt", "name": "addMutate", "type": "let addMutate: (N.t(value), value) => N.t(value)", "docs": null, "kind": "value", "args": [["", "N.t(value)"], ["", "value"]]}, {"path": "Belt_internalSetInt", "name": "fromArray", "type": "let fromArray: array(value) => N.t(value)", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "", "name": "Belt_internalSetInt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compareAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>A\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>N\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>S", "docs": null, "kind": "module"}, {"path": "Belt_internalSetBuckets.C", "name": "opt", "type": "type opt('a) = Js.undefined('a)", "docs": null, "kind": "type"}, {"path": "Belt_internalSetBuckets.C", "name": "container", "type": "type container('hash, 'eq, 'c)", "docs": null, "kind": "type"}, {"path": "Belt_internalSetBuckets.C", "name": "container", "type": "let container: (~size: int, ~buckets: array(opt('c)), ~hash: 'hash, ~eq: 'eq) => container(\n  'hash,\n  'eq,\n  'c\n)", "docs": null, "kind": "value", "args": [["size", "int"], ["buckets", "array(opt('c))"], ["hash", "'hash"], ["eq", "'eq"]]}, {"path": "Belt_internalSetBuckets.C", "name": "sizeSet", "type": "let sizeSet: (container('hash, 'eq, 'c), int) => unit", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"], ["", "int"]]}, {"path": "Belt_internalSetBuckets.C", "name": "size", "type": "let size: container('hash, 'eq, 'c) => int", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalSetBuckets.C", "name": "bucketsSet", "type": "let bucketsSet: (container('hash, 'eq, 'c), array(opt('c))) => unit", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"], ["", "array(opt('c))"]]}, {"path": "Belt_internalSetBuckets.C", "name": "buckets", "type": "let buckets: container('hash, 'eq, 'c) => array(opt('c))", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalSetBuckets.C", "name": "hash", "type": "let hash: container('hash, 'eq, 'c) => 'hash", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalSetBuckets.C", "name": "eq", "type": "let eq: container('hash, 'eq, 'c) => 'eq", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalSetBuckets.C", "name": "toOpt", "type": "let toOpt: opt('a) => option('a)", "docs": null, "kind": "value", "args": [["", "opt('a)"]]}, {"path": "Belt_internalSetBuckets.C", "name": "return", "type": "let return: 'a => opt('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalSetBuckets.C", "name": "emptyOpt", "type": "let emptyOpt: Js.undefined('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalSetBuckets.C", "name": "make", "type": "let make: (~hash: 'hash, ~eq: 'eq, ~hintSize: int) => container('hash, 'eq, 'a)", "docs": null, "kind": "value", "args": [["hash", "'hash"], ["eq", "'eq"], ["hintSize", "int"]]}, {"path": "Belt_internalSetBuckets.C", "name": "clear", "type": "let clear: container('a, 'a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "container('a, 'a, 'a)"]]}, {"path": "Belt_internalSetBuckets.C", "name": "isEmpty", "type": "let isEmpty: container('a, 'a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "container('a, 'a, 'a)"]]}, {"path": "Belt_internalSetBuckets", "name": "C", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>emptyOpt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOpt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>opt", "docs": null, "kind": "module"}, {"path": "Belt_internalSetBuckets", "name": "bucket", "type": "type bucket('a)", "docs": null, "kind": "type"}, {"path": "Belt_internalSetBuckets", "name": "t", "type": "type t('hash, 'eq, 'a) = C.container('hash, 'eq, bucket('a))", "docs": null, "kind": "type"}, {"path": "Belt_internalSetBuckets", "name": "bucket", "type": "let bucket: (~key: 'a, ~next: C.opt(bucket('a))) => bucket('a)", "docs": null, "kind": "value", "args": [["key", "'a"], ["next", "C.opt(bucket('a))"]]}, {"path": "Belt_internalSetBuckets", "name": "keySet", "type": "let keySet: (bucket('a), 'a) => unit", "docs": null, "kind": "value", "args": [["", "bucket('a)"], ["", "'a"]]}, {"path": "Belt_internalSetBuckets", "name": "key", "type": "let key: bucket('a) => 'a", "docs": null, "kind": "value", "args": [["", "bucket('a)"]]}, {"path": "Belt_internalSetBuckets", "name": "nextSet", "type": "let nextSet: (bucket('a), C.opt(bucket('a))) => unit", "docs": null, "kind": "value", "args": [["", "bucket('a)"], ["", "C.opt(bucket('a))"]]}, {"path": "Belt_internalSetBuckets", "name": "next", "type": "let next: bucket('a) => C.opt(bucket('a))", "docs": null, "kind": "value", "args": [["", "bucket('a)"]]}, {"path": "Belt_internalSetBuckets", "name": "copy", "type": "let copy: t('hash, 'eq, 'a) => t('hash, 'eq, 'a)", "docs": null, "kind": "value", "args": [["", "t('hash, 'eq, 'a)"]]}, {"path": "Belt_internalSetBuckets", "name": "forEachU", "type": "let forEachU: (t('hash, 'eq, 'a), Js.Internal.fn([ `Arity_1 of 'a164 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('hash, 'eq, 'a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a164 ], unit)"]]}, {"path": "Belt_internalSetBuckets", "name": "forEach", "type": "let forEach: (t('hash, 'eq, 'a), 'a => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('hash, 'eq, 'a)"], ["", "'a => unit"]]}, {"path": "Belt_internalSetBuckets", "name": "fillArray", "type": "let fillArray: (int, array('a), bucket('a)) => int", "docs": null, "kind": "value", "args": [["", "int"], ["", "array('a)"], ["", "bucket('a)"]]}, {"path": "Belt_internalSetBuckets", "name": "toArray", "type": "let toArray: t('a, 'a, 'a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_internalSetBuckets", "name": "reduceU", "type": "let reduceU: (t('a, 'a, 'a), 'b, Js.Internal.fn([ `Arity_2 of 'b51 * 'a163 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b51 * 'a163 ], 'b)"]]}, {"path": "Belt_internalSetBuckets", "name": "reduce", "type": "let reduce: (t('a, 'a, 'a), 'b, ('b, 'a) => 'b) => 'b", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt_internalSetBuckets", "name": "logStats", "type": "let logStats: t('a, 'a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_internalSetBuckets", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a, 'a, 'a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "", "name": "Belt_internalSetBuckets", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>C", "docs": null, "kind": "module"}, {"path": "Belt_internalMapString", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt_internalMapString.N", "name": "t", "type": "type t('key, 'a) = Js.null(node('key, 'a))", "docs": null, "kind": "type"}, {"path": "Belt_internalMapString.N", "name": "node", "type": "type node('k, 'v)", "docs": null, "kind": "type"}, {"path": "Belt_internalMapString.N", "name": "keySet", "type": "let keySet: (node('k, 'v), 'k) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "'k"]]}, {"path": "Belt_internalMapString.N", "name": "key", "type": "let key: node('k, 'v) => 'k", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapString.N", "name": "valueSet", "type": "let valueSet: (node('k, 'v), 'v) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "'v"]]}, {"path": "Belt_internalMapString.N", "name": "value", "type": "let value: node('k, 'v) => 'v", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapString.N", "name": "height", "type": "let height: node('k, 'v) => int", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapString.N", "name": "leftSet", "type": "let leftSet: (node('k, 'v), t('k, 'v)) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "t('k, 'v)"]]}, {"path": "Belt_internalMapString.N", "name": "left", "type": "let left: node('k, 'v) => t('k, 'v)", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapString.N", "name": "rightSet", "type": "let rightSet: (node('k, 'v), t('k, 'v)) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "t('k, 'v)"]]}, {"path": "Belt_internalMapString.N", "name": "right", "type": "let right: node('k, 'v) => t('k, 'v)", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapString.N", "name": "toOpt", "type": "let toOpt: Js.null('a) => option('a)", "docs": null, "kind": "value", "args": [["", "Js.null('a)"]]}, {"path": "Belt_internalMapString.N", "name": "return", "type": "let return: 'a => Js.null('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalMapString.N", "name": "empty", "type": "let empty: Js.null('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalMapString.N", "name": "cmp", "type": "type cmp('k, 'id) = Belt_Id.cmp('k, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_internalMapString.N", "name": "copy", "type": "let copy: t('k, 'v) => t('k, 'v)", "docs": null, "kind": "value", "args": [["", "t('k, 'v)"]]}, {"path": "Belt_internalMapString.N", "name": "create", "type": "let create: (t('a, 'b), 'a, 'b, t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "bal", "type": "let bal: (t('a, 'b), 'a, 'b, t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "singleton", "type": "let singleton: ('a, 'b) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "'a"], ["", "'b"]]}, {"path": "Belt_internalMapString.N", "name": "updateValue", "type": "let updateValue: (node('k, 'v), 'v) => node('k, 'v)", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "'v"]]}, {"path": "Belt_internalMapString.N", "name": "minKey", "type": "let minKey: t('a, 'b) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a, 'b) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "maxKey", "type": "let maxKey: t('a, 'b) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a, 'b) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "minimum", "type": "let minimum: t('a, 'b) => option(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "minUndefined", "type": "let minUndefined: t('a, 'b) => Js.undefined(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "maximum", "type": "let maximum: t('a, 'b) => option(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "maxUndefined", "type": "let maxUndefined: t('a, 'b) => Js.undefined(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "removeMinAuxWithRef", "type": "let removeMinAuxWithRef: (node('a, 'b), Pervasives.ref('a), Pervasives.ref('b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"], ["", "Pervasives.ref('a)"], ["", "Pervasives.ref('b)"]]}, {"path": "Belt_internalMapString.N", "name": "empty", "type": "let empty: t('a, 'a)", "docs": null, "kind": "value"}, {"path": "Belt_internalMapString.N", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_internalMapString.N", "name": "stackAllLeft", "type": "let stackAllLeft: (t('a, 'b), list(node('a, 'b))) => list(node('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "list(node('a, 'b))"]]}, {"path": "Belt_internalMapString.N", "name": "forEachU", "type": "let forEachU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a159 * 'b47 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a159 * 'b47 ], unit)"]]}, {"path": "Belt_internalMapString.N", "name": "forEach", "type": "let forEach: (t('a, 'b), ('a, 'b) => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => unit"]]}, {"path": "Belt_internalMapString.N", "name": "mapU", "type": "let mapU: (t('c, 'a), Js.Internal.fn([ `Arity_1 of 'a158 ], 'b)) => t('c, 'b)", "docs": null, "kind": "value", "args": [["", "t('c, 'a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a158 ], 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "map", "type": "let map: (t('c, 'a), 'a => 'b) => t('c, 'b)", "docs": null, "kind": "value", "args": [["", "t('c, 'a)"], ["", "'a => 'b"]]}, {"path": "Belt_internalMapString.N", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a157 * 'b46 ], 'c)) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a157 * 'b46 ], 'c)"]]}, {"path": "Belt_internalMapString.N", "name": "mapWithKey", "type": "let mapWithKey: (t('a, 'b), ('a, 'b) => 'c) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_internalMapString.N", "name": "reduceU", "type": "let reduceU: (t('a, 'b), 'c, Js.Internal.fn([ `Arity_3 of 'c12 * 'a156 * 'b45 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c12 * 'a156 * 'b45 ], 'c)"]]}, {"path": "Belt_internalMapString.N", "name": "reduce", "type": "let reduce: (t('a, 'b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_internalMapString.N", "name": "everyU", "type": "let everyU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a155 * 'b44 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a155 * 'b44 ], bool)"]]}, {"path": "Belt_internalMapString.N", "name": "every", "type": "let every: (t('a, 'b), ('a, 'b) => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapString.N", "name": "someU", "type": "let someU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a154 * 'b43 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a154 * 'b43 ], bool)"]]}, {"path": "Belt_internalMapString.N", "name": "some", "type": "let some: (t('a, 'b), ('a, 'b) => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapString.N", "name": "join", "type": "let join: (t('a, 'b), 'a, 'b, t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "concat", "type": "let concat: (t('a, 'b), t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "concatOrJoin", "type": "let concatOrJoin: (t('a, 'b), 'a, option('b), t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "option('b)"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "keepSharedU", "type": "let keepSharedU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a153 * 'b42 ], bool)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a153 * 'b42 ], bool)"]]}, {"path": "Belt_internalMapString.N", "name": "keepShared", "type": "let keepShared: (t('a, 'b), ('a, 'b) => bool) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapString.N", "name": "keepMapU", "type": "let keepMapU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a152 * 'b41 ], option('c))) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a152 * 'b41 ], option('c))"]]}, {"path": "Belt_internalMapString.N", "name": "keepMap", "type": "let keepMap: (t('a, 'b), ('a, 'b) => option('c)) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => option('c)"]]}, {"path": "Belt_internalMapString.N", "name": "partitionSharedU", "type": "let partitionSharedU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a151 * 'b40 ], bool)) => (\n  t('a, 'b),\n  t('a, 'b)\n)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a151 * 'b40 ], bool)"]]}, {"path": "Belt_internalMapString.N", "name": "partitionShared", "type": "let partitionShared: (t('a, 'b), ('a, 'b) => bool) => (t('a, 'b), t('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapString.N", "name": "lengthNode", "type": "let lengthNode: node('a, 'b) => int", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "size", "type": "let size: t('a, 'b) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "toList", "type": "let toList: t('a, 'b) => list(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'b) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "fillArray", "type": "let fillArray: (node('a, 'b), int, array(('a, 'b))) => int", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"], ["", "int"], ["", "array(('a, 'b))"]]}, {"path": "Belt_internalMapString.N", "name": "toArray", "type": "let toArray: t('a, 'b) => array(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "keysToArray", "type": "let keysToArray: t('a, 'b) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "valuesToArray", "type": "let valuesToArray: t('a, 'b) => array('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "fromSortedArrayAux", "type": "let fromSortedArrayAux: (array(('a, 'b)), int, int) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalMapString.N", "name": "fromSortedArrayRevAux", "type": "let fromSortedArrayRevAux: (array(('a, 'b)), int, int) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalMapString.N", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"]]}, {"path": "Belt_internalMapString.N", "name": "cmpU", "type": "let cmpU: (\n  t('a, 'b),\n  t('a, 'c),\n  ~kcmp: cmp('a, 'a),\n  ~vcmp: Js.Internal.fn([ `Arity_2 of 'b39 * 'c11 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["vcmp", "Js.Internal.fn([ `Arity_2 of 'b39 * 'c11 ], int)"]]}, {"path": "Belt_internalMapString.N", "name": "cmp", "type": "let cmp: (t('a, 'b), t('a, 'c), ~kcmp: cmp('a, 'a), ~vcmp: ('b, 'c) => int) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["vcmp", "('b, 'c) => int"]]}, {"path": "Belt_internalMapString.N", "name": "eqU", "type": "let eqU: (\n  t('a, 'b),\n  t('a, 'c),\n  ~kcmp: cmp('a, 'a),\n  ~veq: Js.Internal.fn([ `Arity_2 of 'b38 * 'c10 ], bool)\n) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["veq", "Js.Internal.fn([ `Arity_2 of 'b38 * 'c10 ], bool)"]]}, {"path": "Belt_internalMapString.N", "name": "eq", "type": "let eq: (t('a, 'b), t('a, 'c), ~kcmp: cmp('a, 'a), ~veq: ('b, 'c) => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["veq", "('b, 'c) => bool"]]}, {"path": "Belt_internalMapString.N", "name": "get", "type": "let get: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => option('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapString.N", "name": "getUndefined", "type": "let getUndefined: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => Js.undefined('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapString.N", "name": "getWithDefault", "type": "let getWithDefault: (t('a, 'b), 'a, 'b, ~cmp: cmp('a, 'a)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapString.N", "name": "getExn", "type": "let getExn: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapString.N", "name": "has", "type": "let has: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapString.N", "name": "fromArray", "type": "let fromArray: (array(('a, 'b)), ~cmp: cmp('a, 'id)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_internalMapString.N", "name": "updateMutate", "type": "let updateMutate: (t('a, 'b), 'a, 'b, ~cmp: cmp('a, 'id)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_internalMapString.N", "name": "balMutate", "type": "let balMutate: node('a, 'b) => node('a, 'b)", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"]]}, {"path": "Belt_internalMapString.N", "name": "removeMinAuxWithRootMutate", "type": "let removeMinAuxWithRootMutate: (node('a, 'b), node('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"], ["", "node('a, 'b)"]]}, {"path": "Belt_internalMapString", "name": "N", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>balMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatOrJoin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayRevAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>join\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lengthNode\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRef\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRootMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>singleton\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stackAllLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOpt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateValue\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp", "docs": null, "kind": "module"}, {"path": "Belt_internalMapString.A", "name": "length", "type": "let length: array('a) => int", "docs": "<p><code>length xs</code> return the size of the array</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapString.A", "name": "size", "type": "let size: array('a) => int", "docs": "<p><strong>See</strong> length</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapString.A", "name": "get", "type": "let get: (array('a), int) => option('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapString.A", "name": "getExn", "type": "let getExn: (array('a), int) => 'a", "docs": "<p><code>getExn arr i</code></p>\n<p><strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapString.A", "name": "getUnsafe", "type": "let getUnsafe: (array('a), int) => 'a", "docs": "<p><code>getUnasfe arr i</code></p>\n<p><strong>Unsafe</strong></p>\n<p>no bounds checking, this would cause type error if <code>i</code> does not stay within range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapString.A", "name": "getUndefined", "type": "let getUndefined: (array('a), int) => Js.undefined('a)", "docs": "<p><code>getUndefined arr i</code></p>\n<p>It does the samething in the runtime as getUnsafe, it is <em>type safe</em> since the return type still track whether it is in range or not</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapString.A", "name": "set", "type": "let set: (array('a), int, 'a) => bool", "docs": "<p><code>set arr n x</code> modifies <code>arr</code> in place, it replaces the nth element of <code>arr</code> with <code>x</code></p>\n<p>Returns: <p>false means not updated due to out of range</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalMapString.A", "name": "setExn", "type": "let setExn: (array('a), int, 'a) => unit", "docs": "<p><code>setExn arr i x</code> <strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalMapString.A", "name": "setUnsafe", "type": "let setUnsafe: (array('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalMapString.A", "name": "shuffleInPlace", "type": "let shuffleInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapString.A", "name": "shuffle", "type": "let shuffle: array('a) => array('a)", "docs": "<p><code>shuffle xs</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapString.A", "name": "reverseInPlace", "type": "let reverseInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapString.A", "name": "reverse", "type": "let reverse: array('a) => array('a)", "docs": "<p><code>reverse x</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapString.A", "name": "makeUninitialized", "type": "let makeUninitialized: int => array(Js.undefined('a))", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Belt_internalMapString.A", "name": "makeUninitializedUnsafe", "type": "let makeUninitializedUnsafe: int => array('a)", "docs": "<p><code>makeUninitializedUnsafe n</code></p>\n<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Belt_internalMapString.A", "name": "make", "type": "let make: (int, 'a) => array('a)", "docs": "<p><code>make n e</code> return an array of size <code>n</code> filled with value <code>e</code></p>\n<p>Returns: <p>an empty array when <code>n</code> is negative.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Belt_internalMapString.A", "name": "range", "type": "let range: (int, int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Belt_internalMapString.A", "name": "rangeBy", "type": "let rangeBy: (int, int, ~step: int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"]]}, {"path": "Belt_internalMapString.A", "name": "makeByU", "type": "let makeByU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_internalMapString.A", "name": "makeBy", "type": "let makeBy: (int, int => 'a) => array('a)", "docs": "<p><code>makeBy n f</code></p>\n<p>return an empty array when <code>n</code> is negative return an array of size <code>n</code> populated by <code>f i</code> start from <code>0</code> to <code>n - 1</code></p>\n<pre class='ml'><code class='ml'>makeBy 5 (fun i -&gt; i) = [|0;1;2;3;4|]\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_internalMapString.A", "name": "makeByAndShuffleU", "type": "let makeByAndShuffleU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_internalMapString.A", "name": "makeByAndShuffle", "type": "let makeByAndShuffle: (int, int => 'a) => array('a)", "docs": "<p><code>makeByAndShuffle n f</code></p>\n<p>Equivalent to <code>shuffle (makeBy n f)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_internalMapString.A", "name": "zip", "type": "let zip: (array('a), array('b)) => array(('a, 'b))", "docs": "<p><code>zip a b</code></p>\n<p>Stop with the shorter array</p>\n<pre class='ml'><code class='ml'>zip [|1;2] [|1;2;3|] = [| (1,2); (2;2)|]\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"]]}, {"path": "Belt_internalMapString.A", "name": "zipByU", "type": "let zipByU: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)) => array('c)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)"]]}, {"path": "Belt_internalMapString.A", "name": "zipBy", "type": "let zipBy: (array('a), array('b), ('a, 'b) => 'c) => array('c)", "docs": "<p><code>zipBy xs ys f</code></p>\n<p>Stops with shorter array</p>\n<p>Equivalent to <code>map (zip xs ys) (fun (a,b) -&gt; f a b) </code></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_internalMapString.A", "name": "concat", "type": "let concat: (array('a), array('a)) => array('a)", "docs": "<p><code>concat xs ys</code></p>\n<p>Returns: <p>a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>, so even if <code>v1</code> or <code>v2</code> is empty, it can not be shared</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"]]}, {"path": "Belt_internalMapString.A", "name": "concatMany", "type": "let concatMany: array(array('a)) => array('a)", "docs": "<p><code>concatMany xss</code></p>\n<p>Returns: <p>a fresh array as the concatenation of <code>xss</code></p></p>\n", "kind": "value", "args": [["", "array(array('a))"]]}, {"path": "Belt_internalMapString.A", "name": "slice", "type": "let slice: (array('a), ~offset: int, ~len: int) => array('a)", "docs": "<p><code>slice arr offset len</code></p>\n<p><code>offset</code> can be negative, <code>slice arr -1 1</code> means get the last element as a singleton array</p>\n<p><code>slice arr -(very_large_index) len</code> will do a copy of the array</p>\n<p>if the array does not have enough data, <code>slice</code> extracts through the end of sequence</p>\n", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"]]}, {"path": "Belt_internalMapString.A", "name": "copy", "type": "let copy: array('a) => array('a)", "docs": "<p><code>copy a</code></p>\n<p>Returns: <p>a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapString.A", "name": "fill", "type": "let fill: (array('a), ~offset: int, ~len: int, 'a) => unit", "docs": "<p><code>fill arr ~offset ~len x</code></p>\n<p>Modifies <code>arr</code> in place, storing <code>x</code> in elements number <code>offset</code> to <code>offset + len - 1</code>.</p>\n<p><code>offset</code> can be negative</p>\n<p><code>fill arr offset:(-1) len:1 </code> means fill the last element, if the array does not have enough data, <code>fill</code> will ignore it</p>\n<pre class='ml'><code class='ml'>\nlet arr = makeBy 5 (fun i -&gt; i) ;;\nfill arr ~offset:2 ~len:2 0 ;;\narr = [|0;1;0;0;4|];;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"], ["", "'a"]]}, {"path": "Belt_internalMapString.A", "name": "blit", "type": "let blit: (~src: array('a), ~srcOffset: int, ~dst: array('a), ~dstOffset: int, ~len: int) => unit", "docs": "<p><code>blit ~src:v1 ~srcOffset:o1 ~dst:v2 ~dstOffset:o2 ~len</code></p>\n<p>copies <code>len</code> elements from array <code>v1</code>, starting at element number <code>o1</code>, to array <code>v2</code>, starting at element number <code>o2</code>.</p>\n<p>It works correctly even if <code>v1</code> and <code>v2</code> are the same array, and the source and destination chunks overlap.</p>\n<p><code>offset</code> can be negative, <code>-1</code> means <code>len - 1</code>, if <code>len + offset</code> is still negative, it will be set as 0</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_internalMapString.A", "name": "blitUnsafe", "type": "let blitUnsafe: (\n  ~src: array('a),\n  ~srcOffset: int,\n  ~dst: array('a),\n  ~dstOffset: int,\n  ~len: int\n) => unit", "docs": "<p><strong>Unsafe</strong> blit without bounds checking</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_internalMapString.A", "name": "forEachU", "type": "let forEachU: (array('a), Js.Internal.fn([ `Arity_1 of 'a134 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a134 ], unit)"]]}, {"path": "Belt_internalMapString.A", "name": "forEach", "type": "let forEach: (array('a), 'a => unit) => unit", "docs": "<p><code>forEach xs f</code></p>\n<p>Call f on each element of <code>xs</code> from the beginning to end</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => unit"]]}, {"path": "Belt_internalMapString.A", "name": "mapU", "type": "let mapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)"]]}, {"path": "Belt_internalMapString.A", "name": "map", "type": "let map: (array('a), 'a => 'b) => array('b)", "docs": "<p><code>map xs f </code></p>\n<p>Returns: <p>a new array by calling <code>f</code> to element of <code>xs</code> from the beginning to end</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => 'b"]]}, {"path": "Belt_internalMapString.A", "name": "keepU", "type": "let keepU: (array('a), Js.Internal.fn([ `Arity_1 of 'a132 ], bool)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a132 ], bool)"]]}, {"path": "Belt_internalMapString.A", "name": "keep", "type": "let keep: (array('a), 'a => bool) => array('a)", "docs": "<p><code>keep xs p </code></p>\n<p>Returns: <p>a new array that keep all elements satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [|1;2;3|] (fun x -&gt; x mod  2 = 0) = [|2|]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalMapString.A", "name": "keepMapU", "type": "let keepMapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))"]]}, {"path": "Belt_internalMapString.A", "name": "keepMap", "type": "let keepMap: (array('a), 'a => option('b)) => array('b)", "docs": "<p><code>keepMap xs p</code></p>\n<p>Returns: <p>a new array that keep all elements that return a non-None applied <code>p</code></p>\n<pre class='ml'><code class='ml'>keepMap [|1;2;3|] (fun x -&gt; if x mod 2 then Some x else None)\n= [| 2 |]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => option('b)"]]}, {"path": "Belt_internalMapString.A", "name": "forEachWithIndexU", "type": "let forEachWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)"]]}, {"path": "Belt_internalMapString.A", "name": "forEachWithIndex", "type": "let forEachWithIndex: (array('a), (int, 'a) => unit) => unit", "docs": "<p><code>forEachWithIndex xs f</code></p>\n<p>The same with forEach, except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => unit"]]}, {"path": "Belt_internalMapString.A", "name": "mapWithIndexU", "type": "let mapWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)"]]}, {"path": "Belt_internalMapString.A", "name": "mapWithIndex", "type": "let mapWithIndex: (array('a), (int, 'a) => 'b) => array('b)", "docs": "<p><code>mapWithIndex xs f </code></p>\n<p>The same with map except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt_internalMapString.A", "name": "reduceU", "type": "let reduceU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)"]]}, {"path": "Belt_internalMapString.A", "name": "reduce", "type": "let reduce: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduce xs init f</code></p>\n<pre class='ml'><code class='ml'>reduce [|2;3;4|] 1 (+) = 10\n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_internalMapString.A", "name": "reduceReverseU", "type": "let reduceReverseU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)"]]}, {"path": "Belt_internalMapString.A", "name": "reduceReverse", "type": "let reduceReverse: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduceReverse xs init f</code></p>\n<pre class='ml'><code class='ml'>reduceReverse [|1;2;3;4|] 100 (-) = 90 \n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_internalMapString.A", "name": "reduceReverse2U", "type": "let reduceReverse2U: (\n  array('a),\n  array('b),\n  'c,\n  Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)\n) => 'c", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)"]]}, {"path": "Belt_internalMapString.A", "name": "reduceReverse2", "type": "let reduceReverse2: (array('a), array('b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": "<pre class='ml'><code class='ml'>reduceReverse2 [|1;2;3|] [|1;2|] 0 (fun acc x y -&gt; acc + x + y) = 6\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_internalMapString.A", "name": "someU", "type": "let someU: (array('a), Js.Internal.fn([ `Arity_1 of 'a125 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a125 ], bool)"]]}, {"path": "Belt_internalMapString.A", "name": "some", "type": "let some: (array('a), 'a => bool) => bool", "docs": "<p><code>some xs p</code></p>\n<p>Returns: <p>true if one of element satifies <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalMapString.A", "name": "everyU", "type": "let everyU: (array('a), Js.Internal.fn([ `Arity_1 of 'a124 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a124 ], bool)"]]}, {"path": "Belt_internalMapString.A", "name": "every", "type": "let every: (array('a), 'a => bool) => bool", "docs": "<p><code>every xs p</code></p>\n<p>Returns: <p>true if all elements satisfy <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalMapString.A", "name": "every2U", "type": "let every2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)"]]}, {"path": "Belt_internalMapString.A", "name": "every2", "type": "let every2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>every2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>every2 [|1;2;3|] [|0;1|] (&gt;) = true;;\n(every2 [||] [|1|] (fun   x y -&gt; x &gt; y)) = true;;\n(every2 [|2;3|] [|1|] (fun   x y -&gt; x &gt; y)) = true;; \n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapString.A", "name": "some2U", "type": "let some2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)"]]}, {"path": "Belt_internalMapString.A", "name": "some2", "type": "let some2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>some2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>some2 [|0;2|] [|1;0;3|] (&gt;) = true ;;\n(some2 [||] [|1|] (fun   x y -&gt; x &gt; y)) =  false;;\n(some2 [|2;3|] [|1;4|] (fun   x y -&gt; x &gt; y)) = true;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapString.A", "name": "cmpU", "type": "let cmpU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)"]]}, {"path": "Belt_internalMapString.A", "name": "cmp", "type": "let cmp: (array('a), array('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp a b</code></p>\n<ul><li><p>Compared by length if <code>length a &lt;&gt; length b</code></p>\n</li><li><p>Otherwise compare one by one <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapString.A", "name": "eqU", "type": "let eqU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)"]]}, {"path": "Belt_internalMapString.A", "name": "eq", "type": "let eq: (array('a), array('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq a b</code></p>\n<ul><li><p>return false if length is not the same</p>\n</li><li><p>equal one by one using <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_internalMapString.A", "name": "truncateToLengthUnsafe", "type": "let truncateToLengthUnsafe: (array('a), int) => unit", "docs": "<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapString", "name": "A", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blitUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffleU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitialized\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitializedUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>range\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rangeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffleInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncateToLengthUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipByU", "docs": null, "kind": "module"}, {"path": "Belt_internalMapString.S.Int", "name": "element", "type": "type element = int", "docs": null, "kind": "type"}, {"path": "Belt_internalMapString.S.Int", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapString.S.Int", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapString.S.Int", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapString.S.Int", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapString.S.Int", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_internalMapString.S.Int", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapString.S.Int", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapString.S.Int", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapString.S", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_internalMapString.S.String", "name": "element", "type": "type element = string", "docs": null, "kind": "type"}, {"path": "Belt_internalMapString.S.String", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapString.S.String", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapString.S.String", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapString.S.String", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapString.S.String", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_internalMapString.S.String", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapString.S.String", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapString.S.String", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapString.S", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_internalMapString.S", "name": "strictlySortedLengthU", "type": "let strictlySortedLengthU: (array('a), Js.Internal.fn([ `Arity_2 of 'a119 * 'a119 ], bool)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a119 * 'a119 ], bool)"]]}, {"path": "Belt_internalMapString.S", "name": "strictlySortedLength", "type": "let strictlySortedLength: (array('a), ('a, 'a) => bool) => int", "docs": "<p><code>strictlySortedLenght xs cmp</code> return <code>+n</code> means increasing order <code>-n</code> means negative order</p>\n<pre class='ml'><code class='ml'>strictlySortedLength [|1;2;3;4;3|] (fun x y -&gt; x &lt; y) = 4;;\nstrictlySortedLength [||] (fun x y -&gt; x &lt; y) = 0;;\nstrictlySortedLength [|1|] (fun x y -&gt; x &lt; y) = 1;;\nstrictlySortedLength [|4;3;2;1|] (fun x y -&gt; x &lt; y) = -4;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_internalMapString.S", "name": "isSortedU", "type": "let isSortedU: (array('a), Js.Internal.fn([ `Arity_2 of 'a118 * 'a118 ], int)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a118 * 'a118 ], int)"]]}, {"path": "Belt_internalMapString.S", "name": "isSorted", "type": "let isSorted: (array('a), ('a, 'a) => int) => bool", "docs": "<p><code>isSorted arr cmp</code></p>\n<p>Returns: <p>true if array is increasingly sorted (equal is okay )</p>\n<pre class='ml'><code class='ml'>isSorted [|1;1;2;3;4|] (fun x y -&gt; compare x y)) = true\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapString.S", "name": "stableSortInPlaceByU", "type": "let stableSortInPlaceByU: (array('a), Js.Internal.fn([ `Arity_2 of 'a117 * 'a117 ], int)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a117 * 'a117 ], int)"]]}, {"path": "Belt_internalMapString.S", "name": "stableSortInPlaceBy", "type": "let stableSortInPlaceBy: (array('a), ('a, 'a) => int) => unit", "docs": "<p><code>stableSortBy xs cmp</code></p>\n<p>Sort xs in place using comparator <code>cmp</code>, the stable means if the elements are equal, their order will be preserved</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapString.S", "name": "stableSortByU", "type": "let stableSortByU: (array('a), Js.Internal.fn([ `Arity_2 of 'a116 * 'a116 ], int)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a116 * 'a116 ], int)"]]}, {"path": "Belt_internalMapString.S", "name": "stableSortBy", "type": "let stableSortBy: (array('a), ('a, 'a) => int) => array('a)", "docs": "<p><code>stableSort xs cmp</code></p>\n<p>Returns: <p>a fresh array</p>\n<p>The same as stableSortInPlaceBy except that <code>xs</code> is not modified</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapString.S", "name": "binarySearchByU", "type": "let binarySearchByU: (array('a), 'a, Js.Internal.fn([ `Arity_2 of 'a115 * 'a115 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a115 * 'a115 ], int)"]]}, {"path": "Belt_internalMapString.S", "name": "binarySearchBy", "type": "let binarySearchBy: (array('a), 'a, ('a, 'a) => int) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n<pre class='ml'><code class='ml'>binarySearchBy [|1;2;3;4;33;35;36|] 33 = 4;;\nlnot (binarySearchBy [|1;3;5;7|] 4) = 2;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "'a"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapString.S", "name": "unionU", "type": "let unionU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a114 * 'a114 ], int)\n) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a114 * 'a114 ], int)"]]}, {"path": "Belt_internalMapString.S", "name": "union", "type": "let union: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p><code>union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp</code> assume <code>src</code> and <code>src2</code> is strictly sorted. for equivalent elements, it is picked from <code>src</code> also assume that <code>dst</code> is large enough to store all elements</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapString.S", "name": "intersectU", "type": "let intersectU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a113 * 'a113 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a113 * 'a113 ], int)"]]}, {"path": "Belt_internalMapString.S", "name": "intersect", "type": "let intersect: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p><code>union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp</code> return the <code>offset</code> in the output array</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapString.S", "name": "diffU", "type": "let diffU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a112 * 'a112 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a112 * 'a112 ], int)"]]}, {"path": "Belt_internalMapString.S", "name": "diff", "type": "let diff: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapString", "name": "S", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearchBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearchByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diffU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersectU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSortedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlaceBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlaceByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLengthU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unionU\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt_internalMapString", "name": "t", "type": "type t('a) = N.t(key, 'a)", "docs": null, "kind": "type"}, {"path": "Belt_internalMapString", "name": "add", "type": "let add: (N.t(key, 'a), key, 'a) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_internalMapString", "name": "get", "type": "let get: (N.t(key, 'a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapString", "name": "getUndefined", "type": "let getUndefined: (N.t(key, 'a), key) => Js.Undefined.t('a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapString", "name": "getExn", "type": "let getExn: (N.t(key, 'a), key) => 'a", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapString", "name": "getWithDefault", "type": "let getWithDefault: (N.t(key, 'a), key, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_internalMapString", "name": "has", "type": "let has: (N.t(key, 'a), key) => bool", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapString", "name": "remove", "type": "let remove: (N.t(key, 'a), key) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapString", "name": "splitAux", "type": "let splitAux: (key, N.node(key, 'a)) => (t('a), option('a), t('a))", "docs": null, "kind": "value", "args": [["", "key"], ["", "N.node(key, 'a)"]]}, {"path": "Belt_internalMapString", "name": "split", "type": "let split: (key, Js.null(N.node(key, 'a))) => (N.t(key, 'a), option('a), N.t(key, 'a))", "docs": null, "kind": "value", "args": [["", "key"], ["", "Js.null(N.node(key, 'a))"]]}, {"path": "Belt_internalMapString", "name": "mergeU", "type": "let mergeU: (\n  N.t(key, 'a),\n  N.t(key, 'a),\n  Js.Internal.fn([ `Arity_3 of key * 'p1 option * 'q1 option ], option('a))\n) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "Js.Internal.fn([ `Arity_3 of key * 'p1 option * 'q1 option ], option('a))"]]}, {"path": "Belt_internalMapString", "name": "merge", "type": "let merge: (N.t(key, 'a), N.t(key, 'a), (key, option('a), option('a)) => option('a)) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "(key, option('a), option('a)) => option('a)"]]}, {"path": "Belt_internalMapString", "name": "compareAux", "type": "let compareAux: (\n  list(N.node(key, 'a)),\n  list(N.node(key, 'a)),\n  Js.Internal.fn([ `Arity_2 of 'n1 * 'o1 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "list(N.node(key, 'a))"], ["", "list(N.node(key, 'a))"], ["", "Js.Internal.fn([ `Arity_2 of 'n1 * 'o1 ], int)"]]}, {"path": "Belt_internalMapString", "name": "cmpU", "type": "let cmpU: (N.t(key, 'a), N.t(key, 'a), Js.Internal.fn([ `Arity_2 of 'l1 * 'm1 ], int)) => int", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "Js.Internal.fn([ `Arity_2 of 'l1 * 'm1 ], int)"]]}, {"path": "Belt_internalMapString", "name": "cmp", "type": "let cmp: (N.t(key, 'a), N.t(key, 'a), ('a, 'a) => int) => int", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapString", "name": "eqAux", "type": "let eqAux: (\n  list(N.node(key, 'a)),\n  list(N.node(key, 'a)),\n  Js.Internal.fn([ `Arity_2 of 'i1 * 'j1 ], bool)\n) => bool", "docs": null, "kind": "value", "args": [["", "list(N.node(key, 'a))"], ["", "list(N.node(key, 'a))"], ["", "Js.Internal.fn([ `Arity_2 of 'i1 * 'j1 ], bool)"]]}, {"path": "Belt_internalMapString", "name": "eqU", "type": "let eqU: (N.t(key, 'a), N.t(key, 'a), Js.Internal.fn([ `Arity_2 of 'g1 * 'h1 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "Js.Internal.fn([ `Arity_2 of 'g1 * 'h1 ], bool)"]]}, {"path": "Belt_internalMapString", "name": "eq", "type": "let eq: (N.t(key, 'a), N.t(key, 'a), ('a, 'a) => bool) => bool", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_internalMapString", "name": "addMutate", "type": "let addMutate: (t('a), key, 'a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_internalMapString", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "", "name": "Belt_internalMapString", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compareAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitAux\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>A\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>N\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>S", "docs": null, "kind": "module"}, {"path": "Belt_internalMapInt", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt_internalMapInt.N", "name": "t", "type": "type t('key, 'a) = Js.null(node('key, 'a))", "docs": null, "kind": "type"}, {"path": "Belt_internalMapInt.N", "name": "node", "type": "type node('k, 'v)", "docs": null, "kind": "type"}, {"path": "Belt_internalMapInt.N", "name": "keySet", "type": "let keySet: (node('k, 'v), 'k) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "'k"]]}, {"path": "Belt_internalMapInt.N", "name": "key", "type": "let key: node('k, 'v) => 'k", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapInt.N", "name": "valueSet", "type": "let valueSet: (node('k, 'v), 'v) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "'v"]]}, {"path": "Belt_internalMapInt.N", "name": "value", "type": "let value: node('k, 'v) => 'v", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapInt.N", "name": "height", "type": "let height: node('k, 'v) => int", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapInt.N", "name": "leftSet", "type": "let leftSet: (node('k, 'v), t('k, 'v)) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "t('k, 'v)"]]}, {"path": "Belt_internalMapInt.N", "name": "left", "type": "let left: node('k, 'v) => t('k, 'v)", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapInt.N", "name": "rightSet", "type": "let rightSet: (node('k, 'v), t('k, 'v)) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "t('k, 'v)"]]}, {"path": "Belt_internalMapInt.N", "name": "right", "type": "let right: node('k, 'v) => t('k, 'v)", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalMapInt.N", "name": "toOpt", "type": "let toOpt: Js.null('a) => option('a)", "docs": null, "kind": "value", "args": [["", "Js.null('a)"]]}, {"path": "Belt_internalMapInt.N", "name": "return", "type": "let return: 'a => Js.null('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalMapInt.N", "name": "empty", "type": "let empty: Js.null('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalMapInt.N", "name": "cmp", "type": "type cmp('k, 'id) = Belt_Id.cmp('k, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_internalMapInt.N", "name": "copy", "type": "let copy: t('k, 'v) => t('k, 'v)", "docs": null, "kind": "value", "args": [["", "t('k, 'v)"]]}, {"path": "Belt_internalMapInt.N", "name": "create", "type": "let create: (t('a, 'b), 'a, 'b, t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "bal", "type": "let bal: (t('a, 'b), 'a, 'b, t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "singleton", "type": "let singleton: ('a, 'b) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "'a"], ["", "'b"]]}, {"path": "Belt_internalMapInt.N", "name": "updateValue", "type": "let updateValue: (node('k, 'v), 'v) => node('k, 'v)", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "'v"]]}, {"path": "Belt_internalMapInt.N", "name": "minKey", "type": "let minKey: t('a, 'b) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a, 'b) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "maxKey", "type": "let maxKey: t('a, 'b) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a, 'b) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "minimum", "type": "let minimum: t('a, 'b) => option(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "minUndefined", "type": "let minUndefined: t('a, 'b) => Js.undefined(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "maximum", "type": "let maximum: t('a, 'b) => option(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "maxUndefined", "type": "let maxUndefined: t('a, 'b) => Js.undefined(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "removeMinAuxWithRef", "type": "let removeMinAuxWithRef: (node('a, 'b), Pervasives.ref('a), Pervasives.ref('b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"], ["", "Pervasives.ref('a)"], ["", "Pervasives.ref('b)"]]}, {"path": "Belt_internalMapInt.N", "name": "empty", "type": "let empty: t('a, 'a)", "docs": null, "kind": "value"}, {"path": "Belt_internalMapInt.N", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_internalMapInt.N", "name": "stackAllLeft", "type": "let stackAllLeft: (t('a, 'b), list(node('a, 'b))) => list(node('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "list(node('a, 'b))"]]}, {"path": "Belt_internalMapInt.N", "name": "forEachU", "type": "let forEachU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a159 * 'b47 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a159 * 'b47 ], unit)"]]}, {"path": "Belt_internalMapInt.N", "name": "forEach", "type": "let forEach: (t('a, 'b), ('a, 'b) => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => unit"]]}, {"path": "Belt_internalMapInt.N", "name": "mapU", "type": "let mapU: (t('c, 'a), Js.Internal.fn([ `Arity_1 of 'a158 ], 'b)) => t('c, 'b)", "docs": null, "kind": "value", "args": [["", "t('c, 'a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a158 ], 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "map", "type": "let map: (t('c, 'a), 'a => 'b) => t('c, 'b)", "docs": null, "kind": "value", "args": [["", "t('c, 'a)"], ["", "'a => 'b"]]}, {"path": "Belt_internalMapInt.N", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a157 * 'b46 ], 'c)) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a157 * 'b46 ], 'c)"]]}, {"path": "Belt_internalMapInt.N", "name": "mapWithKey", "type": "let mapWithKey: (t('a, 'b), ('a, 'b) => 'c) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_internalMapInt.N", "name": "reduceU", "type": "let reduceU: (t('a, 'b), 'c, Js.Internal.fn([ `Arity_3 of 'c12 * 'a156 * 'b45 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c12 * 'a156 * 'b45 ], 'c)"]]}, {"path": "Belt_internalMapInt.N", "name": "reduce", "type": "let reduce: (t('a, 'b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_internalMapInt.N", "name": "everyU", "type": "let everyU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a155 * 'b44 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a155 * 'b44 ], bool)"]]}, {"path": "Belt_internalMapInt.N", "name": "every", "type": "let every: (t('a, 'b), ('a, 'b) => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapInt.N", "name": "someU", "type": "let someU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a154 * 'b43 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a154 * 'b43 ], bool)"]]}, {"path": "Belt_internalMapInt.N", "name": "some", "type": "let some: (t('a, 'b), ('a, 'b) => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapInt.N", "name": "join", "type": "let join: (t('a, 'b), 'a, 'b, t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "concat", "type": "let concat: (t('a, 'b), t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "concatOrJoin", "type": "let concatOrJoin: (t('a, 'b), 'a, option('b), t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "option('b)"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "keepSharedU", "type": "let keepSharedU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a153 * 'b42 ], bool)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a153 * 'b42 ], bool)"]]}, {"path": "Belt_internalMapInt.N", "name": "keepShared", "type": "let keepShared: (t('a, 'b), ('a, 'b) => bool) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapInt.N", "name": "keepMapU", "type": "let keepMapU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a152 * 'b41 ], option('c))) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a152 * 'b41 ], option('c))"]]}, {"path": "Belt_internalMapInt.N", "name": "keepMap", "type": "let keepMap: (t('a, 'b), ('a, 'b) => option('c)) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => option('c)"]]}, {"path": "Belt_internalMapInt.N", "name": "partitionSharedU", "type": "let partitionSharedU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a151 * 'b40 ], bool)) => (\n  t('a, 'b),\n  t('a, 'b)\n)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a151 * 'b40 ], bool)"]]}, {"path": "Belt_internalMapInt.N", "name": "partitionShared", "type": "let partitionShared: (t('a, 'b), ('a, 'b) => bool) => (t('a, 'b), t('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapInt.N", "name": "lengthNode", "type": "let lengthNode: node('a, 'b) => int", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "size", "type": "let size: t('a, 'b) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "toList", "type": "let toList: t('a, 'b) => list(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'b) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "fillArray", "type": "let fillArray: (node('a, 'b), int, array(('a, 'b))) => int", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"], ["", "int"], ["", "array(('a, 'b))"]]}, {"path": "Belt_internalMapInt.N", "name": "toArray", "type": "let toArray: t('a, 'b) => array(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "keysToArray", "type": "let keysToArray: t('a, 'b) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "valuesToArray", "type": "let valuesToArray: t('a, 'b) => array('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "fromSortedArrayAux", "type": "let fromSortedArrayAux: (array(('a, 'b)), int, int) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalMapInt.N", "name": "fromSortedArrayRevAux", "type": "let fromSortedArrayRevAux: (array(('a, 'b)), int, int) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalMapInt.N", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"]]}, {"path": "Belt_internalMapInt.N", "name": "cmpU", "type": "let cmpU: (\n  t('a, 'b),\n  t('a, 'c),\n  ~kcmp: cmp('a, 'a),\n  ~vcmp: Js.Internal.fn([ `Arity_2 of 'b39 * 'c11 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["vcmp", "Js.Internal.fn([ `Arity_2 of 'b39 * 'c11 ], int)"]]}, {"path": "Belt_internalMapInt.N", "name": "cmp", "type": "let cmp: (t('a, 'b), t('a, 'c), ~kcmp: cmp('a, 'a), ~vcmp: ('b, 'c) => int) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["vcmp", "('b, 'c) => int"]]}, {"path": "Belt_internalMapInt.N", "name": "eqU", "type": "let eqU: (\n  t('a, 'b),\n  t('a, 'c),\n  ~kcmp: cmp('a, 'a),\n  ~veq: Js.Internal.fn([ `Arity_2 of 'b38 * 'c10 ], bool)\n) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["veq", "Js.Internal.fn([ `Arity_2 of 'b38 * 'c10 ], bool)"]]}, {"path": "Belt_internalMapInt.N", "name": "eq", "type": "let eq: (t('a, 'b), t('a, 'c), ~kcmp: cmp('a, 'a), ~veq: ('b, 'c) => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["veq", "('b, 'c) => bool"]]}, {"path": "Belt_internalMapInt.N", "name": "get", "type": "let get: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => option('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapInt.N", "name": "getUndefined", "type": "let getUndefined: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => Js.undefined('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapInt.N", "name": "getWithDefault", "type": "let getWithDefault: (t('a, 'b), 'a, 'b, ~cmp: cmp('a, 'a)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapInt.N", "name": "getExn", "type": "let getExn: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapInt.N", "name": "has", "type": "let has: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalMapInt.N", "name": "fromArray", "type": "let fromArray: (array(('a, 'b)), ~cmp: cmp('a, 'id)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_internalMapInt.N", "name": "updateMutate", "type": "let updateMutate: (t('a, 'b), 'a, 'b, ~cmp: cmp('a, 'id)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_internalMapInt.N", "name": "balMutate", "type": "let balMutate: node('a, 'b) => node('a, 'b)", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"]]}, {"path": "Belt_internalMapInt.N", "name": "removeMinAuxWithRootMutate", "type": "let removeMinAuxWithRootMutate: (node('a, 'b), node('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"], ["", "node('a, 'b)"]]}, {"path": "Belt_internalMapInt", "name": "N", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>balMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatOrJoin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayRevAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>join\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lengthNode\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRef\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRootMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>singleton\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stackAllLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOpt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateValue\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp", "docs": null, "kind": "module"}, {"path": "Belt_internalMapInt.A", "name": "length", "type": "let length: array('a) => int", "docs": "<p><code>length xs</code> return the size of the array</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapInt.A", "name": "size", "type": "let size: array('a) => int", "docs": "<p><strong>See</strong> length</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapInt.A", "name": "get", "type": "let get: (array('a), int) => option('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "getExn", "type": "let getExn: (array('a), int) => 'a", "docs": "<p><code>getExn arr i</code></p>\n<p><strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "getUnsafe", "type": "let getUnsafe: (array('a), int) => 'a", "docs": "<p><code>getUnasfe arr i</code></p>\n<p><strong>Unsafe</strong></p>\n<p>no bounds checking, this would cause type error if <code>i</code> does not stay within range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "getUndefined", "type": "let getUndefined: (array('a), int) => Js.undefined('a)", "docs": "<p><code>getUndefined arr i</code></p>\n<p>It does the samething in the runtime as getUnsafe, it is <em>type safe</em> since the return type still track whether it is in range or not</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "set", "type": "let set: (array('a), int, 'a) => bool", "docs": "<p><code>set arr n x</code> modifies <code>arr</code> in place, it replaces the nth element of <code>arr</code> with <code>x</code></p>\n<p>Returns: <p>false means not updated due to out of range</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalMapInt.A", "name": "setExn", "type": "let setExn: (array('a), int, 'a) => unit", "docs": "<p><code>setExn arr i x</code> <strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalMapInt.A", "name": "setUnsafe", "type": "let setUnsafe: (array('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_internalMapInt.A", "name": "shuffleInPlace", "type": "let shuffleInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapInt.A", "name": "shuffle", "type": "let shuffle: array('a) => array('a)", "docs": "<p><code>shuffle xs</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapInt.A", "name": "reverseInPlace", "type": "let reverseInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapInt.A", "name": "reverse", "type": "let reverse: array('a) => array('a)", "docs": "<p><code>reverse x</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapInt.A", "name": "makeUninitialized", "type": "let makeUninitialized: int => array(Js.undefined('a))", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "makeUninitializedUnsafe", "type": "let makeUninitializedUnsafe: int => array('a)", "docs": "<p><code>makeUninitializedUnsafe n</code></p>\n<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "make", "type": "let make: (int, 'a) => array('a)", "docs": "<p><code>make n e</code> return an array of size <code>n</code> filled with value <code>e</code></p>\n<p>Returns: <p>an empty array when <code>n</code> is negative.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Belt_internalMapInt.A", "name": "range", "type": "let range: (int, int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "rangeBy", "type": "let rangeBy: (int, int, ~step: int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "makeByU", "type": "let makeByU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_internalMapInt.A", "name": "makeBy", "type": "let makeBy: (int, int => 'a) => array('a)", "docs": "<p><code>makeBy n f</code></p>\n<p>return an empty array when <code>n</code> is negative return an array of size <code>n</code> populated by <code>f i</code> start from <code>0</code> to <code>n - 1</code></p>\n<pre class='ml'><code class='ml'>makeBy 5 (fun i -&gt; i) = [|0;1;2;3;4|]\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_internalMapInt.A", "name": "makeByAndShuffleU", "type": "let makeByAndShuffleU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_internalMapInt.A", "name": "makeByAndShuffle", "type": "let makeByAndShuffle: (int, int => 'a) => array('a)", "docs": "<p><code>makeByAndShuffle n f</code></p>\n<p>Equivalent to <code>shuffle (makeBy n f)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_internalMapInt.A", "name": "zip", "type": "let zip: (array('a), array('b)) => array(('a, 'b))", "docs": "<p><code>zip a b</code></p>\n<p>Stop with the shorter array</p>\n<pre class='ml'><code class='ml'>zip [|1;2] [|1;2;3|] = [| (1,2); (2;2)|]\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"]]}, {"path": "Belt_internalMapInt.A", "name": "zipByU", "type": "let zipByU: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)) => array('c)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)"]]}, {"path": "Belt_internalMapInt.A", "name": "zipBy", "type": "let zipBy: (array('a), array('b), ('a, 'b) => 'c) => array('c)", "docs": "<p><code>zipBy xs ys f</code></p>\n<p>Stops with shorter array</p>\n<p>Equivalent to <code>map (zip xs ys) (fun (a,b) -&gt; f a b) </code></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_internalMapInt.A", "name": "concat", "type": "let concat: (array('a), array('a)) => array('a)", "docs": "<p><code>concat xs ys</code></p>\n<p>Returns: <p>a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>, so even if <code>v1</code> or <code>v2</code> is empty, it can not be shared</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"]]}, {"path": "Belt_internalMapInt.A", "name": "concatMany", "type": "let concatMany: array(array('a)) => array('a)", "docs": "<p><code>concatMany xss</code></p>\n<p>Returns: <p>a fresh array as the concatenation of <code>xss</code></p></p>\n", "kind": "value", "args": [["", "array(array('a))"]]}, {"path": "Belt_internalMapInt.A", "name": "slice", "type": "let slice: (array('a), ~offset: int, ~len: int) => array('a)", "docs": "<p><code>slice arr offset len</code></p>\n<p><code>offset</code> can be negative, <code>slice arr -1 1</code> means get the last element as a singleton array</p>\n<p><code>slice arr -(very_large_index) len</code> will do a copy of the array</p>\n<p>if the array does not have enough data, <code>slice</code> extracts through the end of sequence</p>\n", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "copy", "type": "let copy: array('a) => array('a)", "docs": "<p><code>copy a</code></p>\n<p>Returns: <p>a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalMapInt.A", "name": "fill", "type": "let fill: (array('a), ~offset: int, ~len: int, 'a) => unit", "docs": "<p><code>fill arr ~offset ~len x</code></p>\n<p>Modifies <code>arr</code> in place, storing <code>x</code> in elements number <code>offset</code> to <code>offset + len - 1</code>.</p>\n<p><code>offset</code> can be negative</p>\n<p><code>fill arr offset:(-1) len:1 </code> means fill the last element, if the array does not have enough data, <code>fill</code> will ignore it</p>\n<pre class='ml'><code class='ml'>\nlet arr = makeBy 5 (fun i -&gt; i) ;;\nfill arr ~offset:2 ~len:2 0 ;;\narr = [|0;1;0;0;4|];;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"], ["", "'a"]]}, {"path": "Belt_internalMapInt.A", "name": "blit", "type": "let blit: (~src: array('a), ~srcOffset: int, ~dst: array('a), ~dstOffset: int, ~len: int) => unit", "docs": "<p><code>blit ~src:v1 ~srcOffset:o1 ~dst:v2 ~dstOffset:o2 ~len</code></p>\n<p>copies <code>len</code> elements from array <code>v1</code>, starting at element number <code>o1</code>, to array <code>v2</code>, starting at element number <code>o2</code>.</p>\n<p>It works correctly even if <code>v1</code> and <code>v2</code> are the same array, and the source and destination chunks overlap.</p>\n<p><code>offset</code> can be negative, <code>-1</code> means <code>len - 1</code>, if <code>len + offset</code> is still negative, it will be set as 0</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "blitUnsafe", "type": "let blitUnsafe: (\n  ~src: array('a),\n  ~srcOffset: int,\n  ~dst: array('a),\n  ~dstOffset: int,\n  ~len: int\n) => unit", "docs": "<p><strong>Unsafe</strong> blit without bounds checking</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_internalMapInt.A", "name": "forEachU", "type": "let forEachU: (array('a), Js.Internal.fn([ `Arity_1 of 'a134 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a134 ], unit)"]]}, {"path": "Belt_internalMapInt.A", "name": "forEach", "type": "let forEach: (array('a), 'a => unit) => unit", "docs": "<p><code>forEach xs f</code></p>\n<p>Call f on each element of <code>xs</code> from the beginning to end</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => unit"]]}, {"path": "Belt_internalMapInt.A", "name": "mapU", "type": "let mapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)"]]}, {"path": "Belt_internalMapInt.A", "name": "map", "type": "let map: (array('a), 'a => 'b) => array('b)", "docs": "<p><code>map xs f </code></p>\n<p>Returns: <p>a new array by calling <code>f</code> to element of <code>xs</code> from the beginning to end</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => 'b"]]}, {"path": "Belt_internalMapInt.A", "name": "keepU", "type": "let keepU: (array('a), Js.Internal.fn([ `Arity_1 of 'a132 ], bool)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a132 ], bool)"]]}, {"path": "Belt_internalMapInt.A", "name": "keep", "type": "let keep: (array('a), 'a => bool) => array('a)", "docs": "<p><code>keep xs p </code></p>\n<p>Returns: <p>a new array that keep all elements satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [|1;2;3|] (fun x -&gt; x mod  2 = 0) = [|2|]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalMapInt.A", "name": "keepMapU", "type": "let keepMapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))"]]}, {"path": "Belt_internalMapInt.A", "name": "keepMap", "type": "let keepMap: (array('a), 'a => option('b)) => array('b)", "docs": "<p><code>keepMap xs p</code></p>\n<p>Returns: <p>a new array that keep all elements that return a non-None applied <code>p</code></p>\n<pre class='ml'><code class='ml'>keepMap [|1;2;3|] (fun x -&gt; if x mod 2 then Some x else None)\n= [| 2 |]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => option('b)"]]}, {"path": "Belt_internalMapInt.A", "name": "forEachWithIndexU", "type": "let forEachWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)"]]}, {"path": "Belt_internalMapInt.A", "name": "forEachWithIndex", "type": "let forEachWithIndex: (array('a), (int, 'a) => unit) => unit", "docs": "<p><code>forEachWithIndex xs f</code></p>\n<p>The same with forEach, except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => unit"]]}, {"path": "Belt_internalMapInt.A", "name": "mapWithIndexU", "type": "let mapWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)"]]}, {"path": "Belt_internalMapInt.A", "name": "mapWithIndex", "type": "let mapWithIndex: (array('a), (int, 'a) => 'b) => array('b)", "docs": "<p><code>mapWithIndex xs f </code></p>\n<p>The same with map except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt_internalMapInt.A", "name": "reduceU", "type": "let reduceU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)"]]}, {"path": "Belt_internalMapInt.A", "name": "reduce", "type": "let reduce: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduce xs init f</code></p>\n<pre class='ml'><code class='ml'>reduce [|2;3;4|] 1 (+) = 10\n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_internalMapInt.A", "name": "reduceReverseU", "type": "let reduceReverseU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)"]]}, {"path": "Belt_internalMapInt.A", "name": "reduceReverse", "type": "let reduceReverse: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduceReverse xs init f</code></p>\n<pre class='ml'><code class='ml'>reduceReverse [|1;2;3;4|] 100 (-) = 90 \n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_internalMapInt.A", "name": "reduceReverse2U", "type": "let reduceReverse2U: (\n  array('a),\n  array('b),\n  'c,\n  Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)\n) => 'c", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)"]]}, {"path": "Belt_internalMapInt.A", "name": "reduceReverse2", "type": "let reduceReverse2: (array('a), array('b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": "<pre class='ml'><code class='ml'>reduceReverse2 [|1;2;3|] [|1;2|] 0 (fun acc x y -&gt; acc + x + y) = 6\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_internalMapInt.A", "name": "someU", "type": "let someU: (array('a), Js.Internal.fn([ `Arity_1 of 'a125 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a125 ], bool)"]]}, {"path": "Belt_internalMapInt.A", "name": "some", "type": "let some: (array('a), 'a => bool) => bool", "docs": "<p><code>some xs p</code></p>\n<p>Returns: <p>true if one of element satifies <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalMapInt.A", "name": "everyU", "type": "let everyU: (array('a), Js.Internal.fn([ `Arity_1 of 'a124 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a124 ], bool)"]]}, {"path": "Belt_internalMapInt.A", "name": "every", "type": "let every: (array('a), 'a => bool) => bool", "docs": "<p><code>every xs p</code></p>\n<p>Returns: <p>true if all elements satisfy <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalMapInt.A", "name": "every2U", "type": "let every2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)"]]}, {"path": "Belt_internalMapInt.A", "name": "every2", "type": "let every2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>every2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>every2 [|1;2;3|] [|0;1|] (&gt;) = true;;\n(every2 [||] [|1|] (fun   x y -&gt; x &gt; y)) = true;;\n(every2 [|2;3|] [|1|] (fun   x y -&gt; x &gt; y)) = true;; \n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapInt.A", "name": "some2U", "type": "let some2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)"]]}, {"path": "Belt_internalMapInt.A", "name": "some2", "type": "let some2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>some2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>some2 [|0;2|] [|1;0;3|] (&gt;) = true ;;\n(some2 [||] [|1|] (fun   x y -&gt; x &gt; y)) =  false;;\n(some2 [|2;3|] [|1;4|] (fun   x y -&gt; x &gt; y)) = true;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalMapInt.A", "name": "cmpU", "type": "let cmpU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)"]]}, {"path": "Belt_internalMapInt.A", "name": "cmp", "type": "let cmp: (array('a), array('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp a b</code></p>\n<ul><li><p>Compared by length if <code>length a &lt;&gt; length b</code></p>\n</li><li><p>Otherwise compare one by one <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapInt.A", "name": "eqU", "type": "let eqU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)"]]}, {"path": "Belt_internalMapInt.A", "name": "eq", "type": "let eq: (array('a), array('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq a b</code></p>\n<ul><li><p>return false if length is not the same</p>\n</li><li><p>equal one by one using <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_internalMapInt.A", "name": "truncateToLengthUnsafe", "type": "let truncateToLengthUnsafe: (array('a), int) => unit", "docs": "<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_internalMapInt", "name": "A", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blitUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffleU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitialized\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitializedUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>range\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rangeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffleInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncateToLengthUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipByU", "docs": null, "kind": "module"}, {"path": "Belt_internalMapInt.S.Int", "name": "element", "type": "type element = int", "docs": null, "kind": "type"}, {"path": "Belt_internalMapInt.S.Int", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapInt.S.Int", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapInt.S.Int", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapInt.S.Int", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapInt.S.Int", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_internalMapInt.S.Int", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapInt.S.Int", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapInt.S.Int", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapInt.S", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_internalMapInt.S.String", "name": "element", "type": "type element = string", "docs": null, "kind": "type"}, {"path": "Belt_internalMapInt.S.String", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapInt.S.String", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapInt.S.String", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapInt.S.String", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt_internalMapInt.S.String", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt_internalMapInt.S.String", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapInt.S.String", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapInt.S.String", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt_internalMapInt.S", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_internalMapInt.S", "name": "strictlySortedLengthU", "type": "let strictlySortedLengthU: (array('a), Js.Internal.fn([ `Arity_2 of 'a119 * 'a119 ], bool)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a119 * 'a119 ], bool)"]]}, {"path": "Belt_internalMapInt.S", "name": "strictlySortedLength", "type": "let strictlySortedLength: (array('a), ('a, 'a) => bool) => int", "docs": "<p><code>strictlySortedLenght xs cmp</code> return <code>+n</code> means increasing order <code>-n</code> means negative order</p>\n<pre class='ml'><code class='ml'>strictlySortedLength [|1;2;3;4;3|] (fun x y -&gt; x &lt; y) = 4;;\nstrictlySortedLength [||] (fun x y -&gt; x &lt; y) = 0;;\nstrictlySortedLength [|1|] (fun x y -&gt; x &lt; y) = 1;;\nstrictlySortedLength [|4;3;2;1|] (fun x y -&gt; x &lt; y) = -4;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_internalMapInt.S", "name": "isSortedU", "type": "let isSortedU: (array('a), Js.Internal.fn([ `Arity_2 of 'a118 * 'a118 ], int)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a118 * 'a118 ], int)"]]}, {"path": "Belt_internalMapInt.S", "name": "isSorted", "type": "let isSorted: (array('a), ('a, 'a) => int) => bool", "docs": "<p><code>isSorted arr cmp</code></p>\n<p>Returns: <p>true if array is increasingly sorted (equal is okay )</p>\n<pre class='ml'><code class='ml'>isSorted [|1;1;2;3;4|] (fun x y -&gt; compare x y)) = true\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapInt.S", "name": "stableSortInPlaceByU", "type": "let stableSortInPlaceByU: (array('a), Js.Internal.fn([ `Arity_2 of 'a117 * 'a117 ], int)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a117 * 'a117 ], int)"]]}, {"path": "Belt_internalMapInt.S", "name": "stableSortInPlaceBy", "type": "let stableSortInPlaceBy: (array('a), ('a, 'a) => int) => unit", "docs": "<p><code>stableSortBy xs cmp</code></p>\n<p>Sort xs in place using comparator <code>cmp</code>, the stable means if the elements are equal, their order will be preserved</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapInt.S", "name": "stableSortByU", "type": "let stableSortByU: (array('a), Js.Internal.fn([ `Arity_2 of 'a116 * 'a116 ], int)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a116 * 'a116 ], int)"]]}, {"path": "Belt_internalMapInt.S", "name": "stableSortBy", "type": "let stableSortBy: (array('a), ('a, 'a) => int) => array('a)", "docs": "<p><code>stableSort xs cmp</code></p>\n<p>Returns: <p>a fresh array</p>\n<p>The same as stableSortInPlaceBy except that <code>xs</code> is not modified</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapInt.S", "name": "binarySearchByU", "type": "let binarySearchByU: (array('a), 'a, Js.Internal.fn([ `Arity_2 of 'a115 * 'a115 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a115 * 'a115 ], int)"]]}, {"path": "Belt_internalMapInt.S", "name": "binarySearchBy", "type": "let binarySearchBy: (array('a), 'a, ('a, 'a) => int) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n<pre class='ml'><code class='ml'>binarySearchBy [|1;2;3;4;33;35;36|] 33 = 4;;\nlnot (binarySearchBy [|1;3;5;7|] 4) = 2;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "'a"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapInt.S", "name": "unionU", "type": "let unionU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a114 * 'a114 ], int)\n) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a114 * 'a114 ], int)"]]}, {"path": "Belt_internalMapInt.S", "name": "union", "type": "let union: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p><code>union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp</code> assume <code>src</code> and <code>src2</code> is strictly sorted. for equivalent elements, it is picked from <code>src</code> also assume that <code>dst</code> is large enough to store all elements</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapInt.S", "name": "intersectU", "type": "let intersectU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a113 * 'a113 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a113 * 'a113 ], int)"]]}, {"path": "Belt_internalMapInt.S", "name": "intersect", "type": "let intersect: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p><code>union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp</code> return the <code>offset</code> in the output array</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapInt.S", "name": "diffU", "type": "let diffU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a112 * 'a112 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a112 * 'a112 ], int)"]]}, {"path": "Belt_internalMapInt.S", "name": "diff", "type": "let diff: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapInt", "name": "S", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearchBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearchByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diffU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersectU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSortedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlaceBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlaceByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLengthU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unionU\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt_internalMapInt", "name": "t", "type": "type t('a) = N.t(key, 'a)", "docs": null, "kind": "type"}, {"path": "Belt_internalMapInt", "name": "add", "type": "let add: (N.t(key, 'a), key, 'a) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_internalMapInt", "name": "get", "type": "let get: (N.t(key, 'a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapInt", "name": "getUndefined", "type": "let getUndefined: (N.t(key, 'a), key) => Js.Undefined.t('a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapInt", "name": "getExn", "type": "let getExn: (N.t(key, 'a), key) => 'a", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapInt", "name": "getWithDefault", "type": "let getWithDefault: (N.t(key, 'a), key, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_internalMapInt", "name": "has", "type": "let has: (N.t(key, 'a), key) => bool", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapInt", "name": "remove", "type": "let remove: (N.t(key, 'a), key) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "key"]]}, {"path": "Belt_internalMapInt", "name": "splitAux", "type": "let splitAux: (key, N.node(key, 'a)) => (t('a), option('a), t('a))", "docs": null, "kind": "value", "args": [["", "key"], ["", "N.node(key, 'a)"]]}, {"path": "Belt_internalMapInt", "name": "split", "type": "let split: (key, Js.null(N.node(key, 'a))) => (N.t(key, 'a), option('a), N.t(key, 'a))", "docs": null, "kind": "value", "args": [["", "key"], ["", "Js.null(N.node(key, 'a))"]]}, {"path": "Belt_internalMapInt", "name": "mergeU", "type": "let mergeU: (\n  N.t(key, 'a),\n  N.t(key, 'a),\n  Js.Internal.fn([ `Arity_3 of key * 'e1 option * 'f1 option ], option('a))\n) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "Js.Internal.fn([ `Arity_3 of key * 'e1 option * 'f1 option ], option('a))"]]}, {"path": "Belt_internalMapInt", "name": "merge", "type": "let merge: (N.t(key, 'a), N.t(key, 'a), (key, option('a), option('a)) => option('a)) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "(key, option('a), option('a)) => option('a)"]]}, {"path": "Belt_internalMapInt", "name": "compareAux", "type": "let compareAux: (\n  list(N.node(key, 'a)),\n  list(N.node(key, 'a)),\n  Js.Internal.fn([ `Arity_2 of 'z * 'd1 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "list(N.node(key, 'a))"], ["", "list(N.node(key, 'a))"], ["", "Js.Internal.fn([ `Arity_2 of 'z * 'd1 ], int)"]]}, {"path": "Belt_internalMapInt", "name": "cmpU", "type": "let cmpU: (N.t(key, 'a), N.t(key, 'a), Js.Internal.fn([ `Arity_2 of 'x * 'y ], int)) => int", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "Js.Internal.fn([ `Arity_2 of 'x * 'y ], int)"]]}, {"path": "Belt_internalMapInt", "name": "cmp", "type": "let cmp: (N.t(key, 'a), N.t(key, 'a), ('a, 'a) => int) => int", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_internalMapInt", "name": "eqAux", "type": "let eqAux: (\n  list(N.node(key, 'a)),\n  list(N.node(key, 'a)),\n  Js.Internal.fn([ `Arity_2 of 'u * 'w ], bool)\n) => bool", "docs": null, "kind": "value", "args": [["", "list(N.node(key, 'a))"], ["", "list(N.node(key, 'a))"], ["", "Js.Internal.fn([ `Arity_2 of 'u * 'w ], bool)"]]}, {"path": "Belt_internalMapInt", "name": "eqU", "type": "let eqU: (N.t(key, 'a), N.t(key, 'a), Js.Internal.fn([ `Arity_2 of 's * 't ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "Js.Internal.fn([ `Arity_2 of 's * 't ], bool)"]]}, {"path": "Belt_internalMapInt", "name": "eq", "type": "let eq: (N.t(key, 'a), N.t(key, 'a), ('a, 'a) => bool) => bool", "docs": null, "kind": "value", "args": [["", "N.t(key, 'a)"], ["", "N.t(key, 'a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_internalMapInt", "name": "addMutate", "type": "let addMutate: (t('a), key, 'a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_internalMapInt", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => N.t(key, 'a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "", "name": "Belt_internalMapInt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compareAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitAux\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>A\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>N\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>S", "docs": null, "kind": "module"}, {"path": "Belt_internalBucketsType", "name": "opt", "type": "type opt('a) = Js.undefined('a)", "docs": null, "kind": "type"}, {"path": "Belt_internalBucketsType", "name": "container", "type": "type container('hash, 'eq, 'c)", "docs": null, "kind": "type"}, {"path": "Belt_internalBucketsType", "name": "container", "type": "let container: (~size: int, ~buckets: array(opt('c)), ~hash: 'hash, ~eq: 'eq) => container(\n  'hash,\n  'eq,\n  'c\n)", "docs": null, "kind": "value", "args": [["size", "int"], ["buckets", "array(opt('c))"], ["hash", "'hash"], ["eq", "'eq"]]}, {"path": "Belt_internalBucketsType", "name": "sizeSet", "type": "let sizeSet: (container('hash, 'eq, 'c), int) => unit", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"], ["", "int"]]}, {"path": "Belt_internalBucketsType", "name": "size", "type": "let size: container('hash, 'eq, 'c) => int", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalBucketsType", "name": "bucketsSet", "type": "let bucketsSet: (container('hash, 'eq, 'c), array(opt('c))) => unit", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"], ["", "array(opt('c))"]]}, {"path": "Belt_internalBucketsType", "name": "buckets", "type": "let buckets: container('hash, 'eq, 'c) => array(opt('c))", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalBucketsType", "name": "hash", "type": "let hash: container('hash, 'eq, 'c) => 'hash", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalBucketsType", "name": "eq", "type": "let eq: container('hash, 'eq, 'c) => 'eq", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalBucketsType", "name": "toOpt", "type": "let toOpt: opt('a) => option('a)", "docs": null, "kind": "value", "args": [["", "opt('a)"]]}, {"path": "Belt_internalBucketsType", "name": "return", "type": "let return: 'a => opt('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalBucketsType", "name": "emptyOpt", "type": "let emptyOpt: Js.undefined('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalBucketsType", "name": "make", "type": "let make: (~hash: 'hash, ~eq: 'eq, ~hintSize: int) => container('hash, 'eq, 'a)", "docs": null, "kind": "value", "args": [["hash", "'hash"], ["eq", "'eq"], ["hintSize", "int"]]}, {"path": "Belt_internalBucketsType", "name": "clear", "type": "let clear: container('a, 'a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "container('a, 'a, 'a)"]]}, {"path": "Belt_internalBucketsType", "name": "isEmpty", "type": "let isEmpty: container('a, 'a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "container('a, 'a, 'a)"]]}, {"path": "", "name": "Belt_internalBucketsType", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>emptyOpt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOpt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>opt", "docs": null, "kind": "module"}, {"path": "Belt_internalBuckets.C", "name": "opt", "type": "type opt('a) = Js.undefined('a)", "docs": null, "kind": "type"}, {"path": "Belt_internalBuckets.C", "name": "container", "type": "type container('hash, 'eq, 'c)", "docs": null, "kind": "type"}, {"path": "Belt_internalBuckets.C", "name": "container", "type": "let container: (~size: int, ~buckets: array(opt('c)), ~hash: 'hash, ~eq: 'eq) => container(\n  'hash,\n  'eq,\n  'c\n)", "docs": null, "kind": "value", "args": [["size", "int"], ["buckets", "array(opt('c))"], ["hash", "'hash"], ["eq", "'eq"]]}, {"path": "Belt_internalBuckets.C", "name": "sizeSet", "type": "let sizeSet: (container('hash, 'eq, 'c), int) => unit", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"], ["", "int"]]}, {"path": "Belt_internalBuckets.C", "name": "size", "type": "let size: container('hash, 'eq, 'c) => int", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalBuckets.C", "name": "bucketsSet", "type": "let bucketsSet: (container('hash, 'eq, 'c), array(opt('c))) => unit", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"], ["", "array(opt('c))"]]}, {"path": "Belt_internalBuckets.C", "name": "buckets", "type": "let buckets: container('hash, 'eq, 'c) => array(opt('c))", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalBuckets.C", "name": "hash", "type": "let hash: container('hash, 'eq, 'c) => 'hash", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalBuckets.C", "name": "eq", "type": "let eq: container('hash, 'eq, 'c) => 'eq", "docs": null, "kind": "value", "args": [["", "container('hash, 'eq, 'c)"]]}, {"path": "Belt_internalBuckets.C", "name": "toOpt", "type": "let toOpt: opt('a) => option('a)", "docs": null, "kind": "value", "args": [["", "opt('a)"]]}, {"path": "Belt_internalBuckets.C", "name": "return", "type": "let return: 'a => opt('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalBuckets.C", "name": "emptyOpt", "type": "let emptyOpt: Js.undefined('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalBuckets.C", "name": "make", "type": "let make: (~hash: 'hash, ~eq: 'eq, ~hintSize: int) => container('hash, 'eq, 'a)", "docs": null, "kind": "value", "args": [["hash", "'hash"], ["eq", "'eq"], ["hintSize", "int"]]}, {"path": "Belt_internalBuckets.C", "name": "clear", "type": "let clear: container('a, 'a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "container('a, 'a, 'a)"]]}, {"path": "Belt_internalBuckets.C", "name": "isEmpty", "type": "let isEmpty: container('a, 'a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "container('a, 'a, 'a)"]]}, {"path": "Belt_internalBuckets", "name": "C", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>emptyOpt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOpt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>opt", "docs": null, "kind": "module"}, {"path": "Belt_internalBuckets", "name": "bucket", "type": "type bucket('a, 'b)", "docs": null, "kind": "type"}, {"path": "Belt_internalBuckets", "name": "t", "type": "type t('hash, 'eq, 'a, 'b) = C.container('hash, 'eq, bucket('a, 'b))", "docs": null, "kind": "type"}, {"path": "Belt_internalBuckets", "name": "bucket", "type": "let bucket: (~key: 'a, ~value: 'b, ~next: C.opt(bucket('a, 'b))) => bucket('a, 'b)", "docs": null, "kind": "value", "args": [["key", "'a"], ["value", "'b"], ["next", "C.opt(bucket('a, 'b))"]]}, {"path": "Belt_internalBuckets", "name": "keySet", "type": "let keySet: (bucket('a, 'b), 'a) => unit", "docs": null, "kind": "value", "args": [["", "bucket('a, 'b)"], ["", "'a"]]}, {"path": "Belt_internalBuckets", "name": "key", "type": "let key: bucket('a, 'b) => 'a", "docs": null, "kind": "value", "args": [["", "bucket('a, 'b)"]]}, {"path": "Belt_internalBuckets", "name": "valueSet", "type": "let valueSet: (bucket('a, 'b), 'b) => unit", "docs": null, "kind": "value", "args": [["", "bucket('a, 'b)"], ["", "'b"]]}, {"path": "Belt_internalBuckets", "name": "value", "type": "let value: bucket('a, 'b) => 'b", "docs": null, "kind": "value", "args": [["", "bucket('a, 'b)"]]}, {"path": "Belt_internalBuckets", "name": "nextSet", "type": "let nextSet: (bucket('a, 'b), C.opt(bucket('a, 'b))) => unit", "docs": null, "kind": "value", "args": [["", "bucket('a, 'b)"], ["", "C.opt(bucket('a, 'b))"]]}, {"path": "Belt_internalBuckets", "name": "next", "type": "let next: bucket('a, 'b) => C.opt(bucket('a, 'b))", "docs": null, "kind": "value", "args": [["", "bucket('a, 'b)"]]}, {"path": "Belt_internalBuckets", "name": "copy", "type": "let copy: t('hash, 'eq, 'a, 'b) => t('hash, 'eq, 'a, 'b)", "docs": null, "kind": "value", "args": [["", "t('hash, 'eq, 'a, 'b)"]]}, {"path": "Belt_internalBuckets", "name": "forEachU", "type": "let forEachU: (t('a, 'a, 'a, 'b), Js.Internal.fn([ `Arity_2 of 'a162 * 'b50 ], 'c)) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a162 * 'b50 ], 'c)"]]}, {"path": "Belt_internalBuckets", "name": "forEach", "type": "let forEach: (t('a, 'a, 'a, 'b), ('a, 'b) => 'c) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_internalBuckets", "name": "reduceU", "type": "let reduceU: (t('a, 'a, 'a, 'b), 'c, Js.Internal.fn([ `Arity_3 of 'c13 * 'a161 * 'b49 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c13 * 'a161 * 'b49 ], 'c)"]]}, {"path": "Belt_internalBuckets", "name": "reduce", "type": "let reduce: (t('a, 'a, 'a, 'b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_internalBuckets", "name": "logStats", "type": "let logStats: t('a, 'a, 'a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'a)"]]}, {"path": "Belt_internalBuckets", "name": "keepMapInPlaceU", "type": "let keepMapInPlaceU: (\n  t('a, 'a, 'a, 'b),\n  Js.Internal.fn([ `Arity_2 of 'a160 * 'b48 ], option('b))\n) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a160 * 'b48 ], option('b))"]]}, {"path": "Belt_internalBuckets", "name": "keepMapInPlace", "type": "let keepMapInPlace: (t('a, 'a, 'a, 'b), ('a, 'b) => option('b)) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'b)"], ["", "('a, 'b) => option('b)"]]}, {"path": "Belt_internalBuckets", "name": "fillArray", "type": "let fillArray: (int, array(('a, 'b)), bucket('a, 'b)) => int", "docs": null, "kind": "value", "args": [["", "int"], ["", "array(('a, 'b))"], ["", "bucket('a, 'b)"]]}, {"path": "Belt_internalBuckets", "name": "keysToArray", "type": "let keysToArray: t('a, 'a, 'a, 'a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'a)"]]}, {"path": "Belt_internalBuckets", "name": "valuesToArray", "type": "let valuesToArray: t('a, 'a, 'a, 'b) => array('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'b)"]]}, {"path": "Belt_internalBuckets", "name": "toArray", "type": "let toArray: t('a, 'a, 'a, 'b) => array(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'b)"]]}, {"path": "Belt_internalBuckets", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a, 'a, 'a, 'a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a, 'a)"]]}, {"path": "", "name": "Belt_internalBuckets", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlaceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>C", "docs": null, "kind": "module"}, {"path": "Belt_internalAVLtree", "name": "t", "type": "type t('key, 'a) = Js.null(node('key, 'a))", "docs": null, "kind": "type"}, {"path": "Belt_internalAVLtree", "name": "node", "type": "type node('k, 'v)", "docs": null, "kind": "type"}, {"path": "Belt_internalAVLtree", "name": "keySet", "type": "let keySet: (node('k, 'v), 'k) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "'k"]]}, {"path": "Belt_internalAVLtree", "name": "key", "type": "let key: node('k, 'v) => 'k", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalAVLtree", "name": "valueSet", "type": "let valueSet: (node('k, 'v), 'v) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "'v"]]}, {"path": "Belt_internalAVLtree", "name": "value", "type": "let value: node('k, 'v) => 'v", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalAVLtree", "name": "height", "type": "let height: node('k, 'v) => int", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalAVLtree", "name": "leftSet", "type": "let leftSet: (node('k, 'v), t('k, 'v)) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "t('k, 'v)"]]}, {"path": "Belt_internalAVLtree", "name": "left", "type": "let left: node('k, 'v) => t('k, 'v)", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalAVLtree", "name": "rightSet", "type": "let rightSet: (node('k, 'v), t('k, 'v)) => unit", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "t('k, 'v)"]]}, {"path": "Belt_internalAVLtree", "name": "right", "type": "let right: node('k, 'v) => t('k, 'v)", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"]]}, {"path": "Belt_internalAVLtree", "name": "toOpt", "type": "let toOpt: Js.null('a) => option('a)", "docs": null, "kind": "value", "args": [["", "Js.null('a)"]]}, {"path": "Belt_internalAVLtree", "name": "return", "type": "let return: 'a => Js.null('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalAVLtree", "name": "empty", "type": "let empty: Js.null('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalAVLtree", "name": "cmp", "type": "type cmp('k, 'id) = Belt_Id.cmp('k, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_internalAVLtree", "name": "copy", "type": "let copy: t('k, 'v) => t('k, 'v)", "docs": null, "kind": "value", "args": [["", "t('k, 'v)"]]}, {"path": "Belt_internalAVLtree", "name": "create", "type": "let create: (t('a, 'b), 'a, 'b, t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "bal", "type": "let bal: (t('a, 'b), 'a, 'b, t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "singleton", "type": "let singleton: ('a, 'b) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "'a"], ["", "'b"]]}, {"path": "Belt_internalAVLtree", "name": "updateValue", "type": "let updateValue: (node('k, 'v), 'v) => node('k, 'v)", "docs": null, "kind": "value", "args": [["", "node('k, 'v)"], ["", "'v"]]}, {"path": "Belt_internalAVLtree", "name": "minKey", "type": "let minKey: t('a, 'b) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a, 'b) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "maxKey", "type": "let maxKey: t('a, 'b) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a, 'b) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "minimum", "type": "let minimum: t('a, 'b) => option(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "minUndefined", "type": "let minUndefined: t('a, 'b) => Js.undefined(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "maximum", "type": "let maximum: t('a, 'b) => option(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "maxUndefined", "type": "let maxUndefined: t('a, 'b) => Js.undefined(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "removeMinAuxWithRef", "type": "let removeMinAuxWithRef: (node('a, 'b), Pervasives.ref('a), Pervasives.ref('b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"], ["", "Pervasives.ref('a)"], ["", "Pervasives.ref('b)"]]}, {"path": "Belt_internalAVLtree", "name": "empty", "type": "let empty: t('a, 'a)", "docs": null, "kind": "value"}, {"path": "Belt_internalAVLtree", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_internalAVLtree", "name": "stackAllLeft", "type": "let stackAllLeft: (t('a, 'b), list(node('a, 'b))) => list(node('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "list(node('a, 'b))"]]}, {"path": "Belt_internalAVLtree", "name": "forEachU", "type": "let forEachU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a159 * 'b47 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a159 * 'b47 ], unit)"]]}, {"path": "Belt_internalAVLtree", "name": "forEach", "type": "let forEach: (t('a, 'b), ('a, 'b) => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => unit"]]}, {"path": "Belt_internalAVLtree", "name": "mapU", "type": "let mapU: (t('c, 'a), Js.Internal.fn([ `Arity_1 of 'a158 ], 'b)) => t('c, 'b)", "docs": null, "kind": "value", "args": [["", "t('c, 'a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a158 ], 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "map", "type": "let map: (t('c, 'a), 'a => 'b) => t('c, 'b)", "docs": null, "kind": "value", "args": [["", "t('c, 'a)"], ["", "'a => 'b"]]}, {"path": "Belt_internalAVLtree", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a157 * 'b46 ], 'c)) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a157 * 'b46 ], 'c)"]]}, {"path": "Belt_internalAVLtree", "name": "mapWithKey", "type": "let mapWithKey: (t('a, 'b), ('a, 'b) => 'c) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_internalAVLtree", "name": "reduceU", "type": "let reduceU: (t('a, 'b), 'c, Js.Internal.fn([ `Arity_3 of 'c12 * 'a156 * 'b45 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c12 * 'a156 * 'b45 ], 'c)"]]}, {"path": "Belt_internalAVLtree", "name": "reduce", "type": "let reduce: (t('a, 'b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_internalAVLtree", "name": "everyU", "type": "let everyU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a155 * 'b44 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a155 * 'b44 ], bool)"]]}, {"path": "Belt_internalAVLtree", "name": "every", "type": "let every: (t('a, 'b), ('a, 'b) => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalAVLtree", "name": "someU", "type": "let someU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a154 * 'b43 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a154 * 'b43 ], bool)"]]}, {"path": "Belt_internalAVLtree", "name": "some", "type": "let some: (t('a, 'b), ('a, 'b) => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalAVLtree", "name": "join", "type": "let join: (t('a, 'b), 'a, 'b, t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "concat", "type": "let concat: (t('a, 'b), t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "concatOrJoin", "type": "let concatOrJoin: (t('a, 'b), 'a, option('b), t('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "option('b)"], ["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "keepSharedU", "type": "let keepSharedU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a153 * 'b42 ], bool)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a153 * 'b42 ], bool)"]]}, {"path": "Belt_internalAVLtree", "name": "keepShared", "type": "let keepShared: (t('a, 'b), ('a, 'b) => bool) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalAVLtree", "name": "keepMapU", "type": "let keepMapU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a152 * 'b41 ], option('c))) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a152 * 'b41 ], option('c))"]]}, {"path": "Belt_internalAVLtree", "name": "keepMap", "type": "let keepMap: (t('a, 'b), ('a, 'b) => option('c)) => t('a, 'c)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => option('c)"]]}, {"path": "Belt_internalAVLtree", "name": "partitionSharedU", "type": "let partitionSharedU: (t('a, 'b), Js.Internal.fn([ `Arity_2 of 'a151 * 'b40 ], bool)) => (\n  t('a, 'b),\n  t('a, 'b)\n)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a151 * 'b40 ], bool)"]]}, {"path": "Belt_internalAVLtree", "name": "partitionShared", "type": "let partitionShared: (t('a, 'b), ('a, 'b) => bool) => (t('a, 'b), t('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_internalAVLtree", "name": "lengthNode", "type": "let lengthNode: node('a, 'b) => int", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "size", "type": "let size: t('a, 'b) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "toList", "type": "let toList: t('a, 'b) => list(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'b) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "fillArray", "type": "let fillArray: (node('a, 'b), int, array(('a, 'b))) => int", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"], ["", "int"], ["", "array(('a, 'b))"]]}, {"path": "Belt_internalAVLtree", "name": "toArray", "type": "let toArray: t('a, 'b) => array(('a, 'b))", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "keysToArray", "type": "let keysToArray: t('a, 'b) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "valuesToArray", "type": "let valuesToArray: t('a, 'b) => array('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "fromSortedArrayAux", "type": "let fromSortedArrayAux: (array(('a, 'b)), int, int) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalAVLtree", "name": "fromSortedArrayRevAux", "type": "let fromSortedArrayRevAux: (array(('a, 'b)), int, int) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalAVLtree", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"]]}, {"path": "Belt_internalAVLtree", "name": "cmpU", "type": "let cmpU: (\n  t('a, 'b),\n  t('a, 'c),\n  ~kcmp: cmp('a, 'a),\n  ~vcmp: Js.Internal.fn([ `Arity_2 of 'b39 * 'c11 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["vcmp", "Js.Internal.fn([ `Arity_2 of 'b39 * 'c11 ], int)"]]}, {"path": "Belt_internalAVLtree", "name": "cmp", "type": "let cmp: (t('a, 'b), t('a, 'c), ~kcmp: cmp('a, 'a), ~vcmp: ('b, 'c) => int) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["vcmp", "('b, 'c) => int"]]}, {"path": "Belt_internalAVLtree", "name": "eqU", "type": "let eqU: (\n  t('a, 'b),\n  t('a, 'c),\n  ~kcmp: cmp('a, 'a),\n  ~veq: Js.Internal.fn([ `Arity_2 of 'b38 * 'c10 ], bool)\n) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["veq", "Js.Internal.fn([ `Arity_2 of 'b38 * 'c10 ], bool)"]]}, {"path": "Belt_internalAVLtree", "name": "eq", "type": "let eq: (t('a, 'b), t('a, 'c), ~kcmp: cmp('a, 'a), ~veq: ('b, 'c) => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "t('a, 'c)"], ["kcmp", "cmp('a, 'a)"], ["veq", "('b, 'c) => bool"]]}, {"path": "Belt_internalAVLtree", "name": "get", "type": "let get: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => option('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalAVLtree", "name": "getUndefined", "type": "let getUndefined: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => Js.undefined('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalAVLtree", "name": "getWithDefault", "type": "let getWithDefault: (t('a, 'b), 'a, 'b, ~cmp: cmp('a, 'a)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalAVLtree", "name": "getExn", "type": "let getExn: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalAVLtree", "name": "has", "type": "let has: (t('a, 'b), 'a, ~cmp: cmp('a, 'a)) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["cmp", "cmp('a, 'a)"]]}, {"path": "Belt_internalAVLtree", "name": "fromArray", "type": "let fromArray: (array(('a, 'b)), ~cmp: cmp('a, 'id)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "array(('a, 'b))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_internalAVLtree", "name": "updateMutate", "type": "let updateMutate: (t('a, 'b), 'a, 'b, ~cmp: cmp('a, 'id)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt_internalAVLtree", "name": "balMutate", "type": "let balMutate: node('a, 'b) => node('a, 'b)", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"]]}, {"path": "Belt_internalAVLtree", "name": "removeMinAuxWithRootMutate", "type": "let removeMinAuxWithRootMutate: (node('a, 'b), node('a, 'b)) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "node('a, 'b)"], ["", "node('a, 'b)"]]}, {"path": "", "name": "Belt_internalAVLtree", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>balMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatOrJoin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayRevAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>join\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lengthNode\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRef\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRootMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>singleton\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stackAllLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOpt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateValue\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp", "docs": null, "kind": "module"}, {"path": "Belt_internalAVLset", "name": "t", "type": "type t('value) = Js.null(node('value))", "docs": null, "kind": "type"}, {"path": "Belt_internalAVLset", "name": "node", "type": "type node('value)", "docs": null, "kind": "type"}, {"path": "Belt_internalAVLset", "name": "value", "type": "let value: node('value) => 'value", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalAVLset", "name": "height", "type": "let height: node('value) => int", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalAVLset", "name": "leftSet", "type": "let leftSet: (node('value), t('value)) => unit", "docs": null, "kind": "value", "args": [["", "node('value)"], ["", "t('value)"]]}, {"path": "Belt_internalAVLset", "name": "left", "type": "let left: node('value) => t('value)", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalAVLset", "name": "rightSet", "type": "let rightSet: (node('value), t('value)) => unit", "docs": null, "kind": "value", "args": [["", "node('value)"], ["", "t('value)"]]}, {"path": "Belt_internalAVLset", "name": "right", "type": "let right: node('value) => t('value)", "docs": null, "kind": "value", "args": [["", "node('value)"]]}, {"path": "Belt_internalAVLset", "name": "cmp", "type": "type cmp('a, 'b) = Belt_Id.cmp('a, 'b)", "docs": null, "kind": "type"}, {"path": "Belt_internalAVLset", "name": "toOpt", "type": "let toOpt: Js.null('a) => option('a)", "docs": null, "kind": "value", "args": [["", "Js.null('a)"]]}, {"path": "Belt_internalAVLset", "name": "return", "type": "let return: 'a => Js.null('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalAVLset", "name": "empty", "type": "let empty: Js.null('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalAVLset", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "create", "type": "let create: (t('a), 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "bal", "type": "let bal: (t('a), 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "singleton", "type": "let singleton: 'a => t('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Belt_internalAVLset", "name": "minimum", "type": "let minimum: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "minUndefined", "type": "let minUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "maximum", "type": "let maximum: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "maxUndefined", "type": "let maxUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "removeMinAuxWithRef", "type": "let removeMinAuxWithRef: (node('a), Pervasives.ref('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "node('a)"], ["", "Pervasives.ref('a)"]]}, {"path": "Belt_internalAVLset", "name": "empty", "type": "let empty: t('a)", "docs": null, "kind": "value"}, {"path": "Belt_internalAVLset", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "stackAllLeft", "type": "let stackAllLeft: (t('a), list(node('a))) => list(node('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "list(node('a))"]]}, {"path": "Belt_internalAVLset", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_1 of 'a150 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a150 ], unit)"]]}, {"path": "Belt_internalAVLset", "name": "forEach", "type": "let forEach: (t('a), 'a => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => unit"]]}, {"path": "Belt_internalAVLset", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'b37 * 'a149 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b37 * 'a149 ], 'b)"]]}, {"path": "Belt_internalAVLset", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt_internalAVLset", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a148 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a148 ], bool)"]]}, {"path": "Belt_internalAVLset", "name": "every", "type": "let every: (t('a), 'a => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalAVLset", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_1 of 'a147 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a147 ], bool)"]]}, {"path": "Belt_internalAVLset", "name": "some", "type": "let some: (t('a), 'a => bool) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalAVLset", "name": "joinShared", "type": "let joinShared: (t('a), 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "concatShared", "type": "let concatShared: (t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "keepSharedU", "type": "let keepSharedU: (t('a), Js.Internal.fn([ `Arity_1 of 'a146 ], bool)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a146 ], bool)"]]}, {"path": "Belt_internalAVLset", "name": "keepShared", "type": "let keepShared: (t('a), 'a => bool) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalAVLset", "name": "keepCopyU", "type": "let keepCopyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a145 ], bool)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a145 ], bool)"]]}, {"path": "Belt_internalAVLset", "name": "keepCopy", "type": "let keepCopy: (t('a), 'a => bool) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalAVLset", "name": "partitionSharedU", "type": "let partitionSharedU: (t('a), Js.Internal.fn([ `Arity_1 of 'a144 ], bool)) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a144 ], bool)"]]}, {"path": "Belt_internalAVLset", "name": "partitionShared", "type": "let partitionShared: (t('a), 'a => bool) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalAVLset", "name": "partitionCopyU", "type": "let partitionCopyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a143 ], bool)) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a143 ], bool)"]]}, {"path": "Belt_internalAVLset", "name": "partitionCopy", "type": "let partitionCopy: (t('a), 'a => bool) => (t('a), t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt_internalAVLset", "name": "lengthNode", "type": "let lengthNode: node('a) => int", "docs": null, "kind": "value", "args": [["", "node('a)"]]}, {"path": "Belt_internalAVLset", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "toList", "type": "let toList: t('a) => list('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "fillArray", "type": "let fillArray: (node('a), int, array('a)) => int", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "node('a)"], ["", "int"], ["", "array('a)"]]}, {"path": "Belt_internalAVLset", "name": "toArray", "type": "let toArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_internalAVLset", "name": "fromSortedArrayAux", "type": "let fromSortedArrayAux: (array('a), int, int) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalAVLset", "name": "fromSortedArrayRevAux", "type": "let fromSortedArrayRevAux: (array('a), int, int) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"]]}, {"path": "Belt_internalAVLset", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array('a) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_internalAVLset", "name": "has", "type": "let has: (t('a), 'a, ~cmp: cmp('a, 'b)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalAVLset", "name": "cmp", "type": "let cmp: (t('a), t('a), ~cmp: cmp('a, 'b)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalAVLset", "name": "eq", "type": "let eq: (t('a), t('a), ~cmp: cmp('a, 'b)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalAVLset", "name": "subset", "type": "let subset: (t('a), t('a), ~cmp: cmp('a, 'b)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalAVLset", "name": "get", "type": "let get: (t('a), 'a, ~cmp: cmp('a, 'b)) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalAVLset", "name": "getUndefined", "type": "let getUndefined: (t('a), 'a, ~cmp: cmp('a, 'b)) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalAVLset", "name": "getExn", "type": "let getExn: (t('a), 'a, ~cmp: cmp('a, 'b)) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalAVLset", "name": "fromArray", "type": "let fromArray: (array('a), ~cmp: cmp('a, 'b)) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["cmp", "cmp('a, 'b)"]]}, {"path": "Belt_internalAVLset", "name": "addMutate", "type": "let addMutate: (~cmp: cmp('a, 'b), t('a), 'a) => t('a)", "docs": null, "kind": "value", "args": [["cmp", "cmp('a, 'b)"], ["", "t('a)"], ["", "'a"]]}, {"path": "Belt_internalAVLset", "name": "balMutate", "type": "let balMutate: node('a) => node('a)", "docs": null, "kind": "value", "args": [["", "node('a)"]]}, {"path": "Belt_internalAVLset", "name": "removeMinAuxWithRootMutate", "type": "let removeMinAuxWithRootMutate: (node('a), node('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "node('a)"], ["", "node('a)"]]}, {"path": "", "name": "Belt_internalAVLset", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>balMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayRevAux\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>joinShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepCopy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepCopyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lengthNode\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionCopy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionCopyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionShared\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionSharedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRef\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMinAuxWithRootMutate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>singleton\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stackAllLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOpt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp", "docs": null, "kind": "module"}, {"path": "Belt_Id", "name": "hash", "type": "type hash('a, 'id)", "docs": "<p><code>(&#39;a, &#39;id) hash</code></p>\n<p>Its runtime represenation is a <code>hash</code> function, but signed with a type parameter, so that different hash functions type mismatch</p>\n", "kind": "type"}, {"path": "Belt_Id", "name": "eq", "type": "type eq('a, 'id)", "docs": "<p><code>(&#39;a, &#39;id) eq</code></p>\n<p>Its runtime represenation is an <code>eq</code> function, but signed with a type parameter, so that different hash functions type mismatch</p>\n", "kind": "type"}, {"path": "Belt_Id", "name": "cmp", "type": "type cmp('a, 'id)", "docs": "<p><code>(&#39;a,&#39;id) cmp</code></p>\n<p>Its runtime representation is a <code>cmp</code> function, but signed with a type parameter, so that different hash functions type mismatch</p>\n", "kind": "type"}, {"path": "Belt_Id", "name": "comparable", "type": "type comparable('key, 'id) = (module Comparable with type identity = 'id0 and type t = 'key3)", "docs": "<p><code>(&#39;key, &#39;id) cmparable</code> is a module of functions, here it only includes <code>cmp</code>.</p>\n<p>Unlike normal functions, when created, it comes with a unique identity (guaranteed by the type system).</p>\n<p>It can be created using function comparableU orcomparable.</p>\n<p>The idea of a unique identity when created is that it makes sure two sets would type mismatch if they use different comparison function</p>\n", "kind": "type"}, {"path": "Belt_Id", "name": "MakeComparableU", "type": "", "docs": null, "kind": "module"}, {"path": "Belt_Id", "name": "MakeComparable", "type": "", "docs": null, "kind": "module"}, {"path": "Belt_Id", "name": "comparableU", "type": "let comparableU: (\n  ~cmp: Js.Internal.fn(\n    [ `Arity_2 of 'a142 * 'a142 ],\n    int\n  )\n) => (module Comparable with type t = 'a142)", "docs": null, "kind": "value", "args": [["cmp", "Js.Internal.fn([ `Arity_2 of 'a142 * 'a142 ], int)"]]}, {"path": "Belt_Id", "name": "comparable", "type": "let comparable: (~cmp: ('a, 'a) => int) => (module Comparable with type t = 'a141)", "docs": null, "kind": "value", "args": [["cmp", "('a, 'a) => int"]]}, {"path": "Belt_Id", "name": "hashable", "type": "type hashable('key, 'id) = (module Hashable with type identity = 'id and type t = 'key2)", "docs": "<p><code>(&#39;key, &#39;id) hashable</code> is a module of functions, here it only includes <code>hash</code>, <code>eq</code>.</p>\n<p>Unlike normal functions, when created, it comes with a unique identity (guaranteed by the type system).</p>\n<p>It can be created using function hashableU or hashable.</p>\n<p>The idea of a unique identity when created is that it makes sure two hash sets would type mismatch if they use different comparison function</p>\n", "kind": "type"}, {"path": "Belt_Id", "name": "MakeHashableU", "type": "", "docs": null, "kind": "module"}, {"path": "Belt_Id", "name": "MakeHashable", "type": "", "docs": null, "kind": "module"}, {"path": "Belt_Id", "name": "hashableU", "type": "let hashableU: (\n  ~hash: Js.Internal.fn([ `Arity_1 of 'a140 ], int),\n  ~eq: Js.Internal.fn([ `Arity_2 of 'a140 * 'a140 ], bool)\n) => (module Hashable with type t = 'a140)", "docs": null, "kind": "value", "args": [["hash", "Js.Internal.fn([ `Arity_1 of 'a140 ], int)"], ["eq", "Js.Internal.fn([ `Arity_2 of 'a140 * 'a140 ], bool)"]]}, {"path": "Belt_Id", "name": "hashable", "type": "let hashable: (~hash: 'a => int, ~eq: ('a, 'a) => bool) => (module Hashable with type t = 'a139)", "docs": null, "kind": "value", "args": [["hash", "'a => int"], ["eq", "('a, 'a) => bool"]]}, {"path": "Belt_Id", "name": "getHashInternal", "type": "let getHashInternal: hash('a, 'id) => Js.Internal.fn([ `Arity_1 of 'a138 ], int)", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "hash('a, 'id)"]]}, {"path": "Belt_Id", "name": "getEqInternal", "type": "let getEqInternal: eq('a, 'id) => Js.Internal.fn([ `Arity_2 of 'a137 * 'a137 ], bool)", "docs": null, "kind": "value", "args": [["", "eq('a, 'id)"]]}, {"path": "Belt_Id", "name": "getCmpInternal", "type": "let getCmpInternal: cmp('a, 'id) => Js.Internal.fn([ `Arity_2 of 'a136 * 'a136 ], int)", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "cmp('a, 'id)"]]}, {"path": "", "name": "Belt_Id", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>comparable\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>comparableU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getCmpInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getEqInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getHashInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hashable\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hashableU\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>comparable\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>eq\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>hash\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>hashable\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeComparable\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeComparableU\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeHashable\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeHashableU", "docs": null, "kind": "module"}, {"path": "Belt_HashSetString", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt_HashSetString", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Belt_HashSetString", "name": "make", "type": "let make: (~hintSize: int) => t", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt_HashSetString", "name": "clear", "type": "let clear: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetString", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetString", "name": "add", "type": "let add: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSetString", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetString", "name": "has", "type": "let has: (t, key) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSetString", "name": "remove", "type": "let remove: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSetString", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of key ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of key ], unit)"]]}, {"path": "Belt_HashSetString", "name": "forEach", "type": "let forEach: (t, key => unit) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key => unit"]]}, {"path": "Belt_HashSetString", "name": "reduceU", "type": "let reduceU: (t, 'c, Js.Internal.fn([ `Arity_2 of 'c4 * key ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'c4 * key ], 'c)"]]}, {"path": "Belt_HashSetString", "name": "reduce", "type": "let reduce: (t, 'c, ('c, key) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "('c, key) => 'c"]]}, {"path": "Belt_HashSetString", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetString", "name": "logStats", "type": "let logStats: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetString", "name": "toArray", "type": "let toArray: t => array(key)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetString", "name": "ofArray", "type": "let ofArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt_HashSetString", "name": "fromArray", "type": "let fromArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt_HashSetString", "name": "mergeMany", "type": "let mergeMany: (t, array(key)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(key)"]]}, {"path": "Belt_HashSetString", "name": "getBucketHistogram", "type": "let getBucketHistogram: t => array(int)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "", "name": "Belt_HashSetString", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_HashSetInt", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt_HashSetInt", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Belt_HashSetInt", "name": "make", "type": "let make: (~hintSize: int) => t", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt_HashSetInt", "name": "clear", "type": "let clear: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetInt", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetInt", "name": "add", "type": "let add: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSetInt", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetInt", "name": "has", "type": "let has: (t, key) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSetInt", "name": "remove", "type": "let remove: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSetInt", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of key ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of key ], unit)"]]}, {"path": "Belt_HashSetInt", "name": "forEach", "type": "let forEach: (t, key => unit) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key => unit"]]}, {"path": "Belt_HashSetInt", "name": "reduceU", "type": "let reduceU: (t, 'c, Js.Internal.fn([ `Arity_2 of 'c5 * key ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'c5 * key ], 'c)"]]}, {"path": "Belt_HashSetInt", "name": "reduce", "type": "let reduce: (t, 'c, ('c, key) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "('c, key) => 'c"]]}, {"path": "Belt_HashSetInt", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetInt", "name": "logStats", "type": "let logStats: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetInt", "name": "toArray", "type": "let toArray: t => array(key)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSetInt", "name": "ofArray", "type": "let ofArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt_HashSetInt", "name": "fromArray", "type": "let fromArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt_HashSetInt", "name": "mergeMany", "type": "let mergeMany: (t, array(key)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(key)"]]}, {"path": "Belt_HashSetInt", "name": "getBucketHistogram", "type": "let getBucketHistogram: t => array(int)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "", "name": "Belt_HashSetInt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_HashSet.Int", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt_HashSet.Int", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Belt_HashSet.Int", "name": "make", "type": "let make: (~hintSize: int) => t", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt_HashSet.Int", "name": "clear", "type": "let clear: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.Int", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.Int", "name": "add", "type": "let add: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSet.Int", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.Int", "name": "has", "type": "let has: (t, key) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSet.Int", "name": "remove", "type": "let remove: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSet.Int", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of key ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of key ], unit)"]]}, {"path": "Belt_HashSet.Int", "name": "forEach", "type": "let forEach: (t, key => unit) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key => unit"]]}, {"path": "Belt_HashSet.Int", "name": "reduceU", "type": "let reduceU: (t, 'c, Js.Internal.fn([ `Arity_2 of 'c5 * key ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'c5 * key ], 'c)"]]}, {"path": "Belt_HashSet.Int", "name": "reduce", "type": "let reduce: (t, 'c, ('c, key) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "('c, key) => 'c"]]}, {"path": "Belt_HashSet.Int", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.Int", "name": "logStats", "type": "let logStats: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.Int", "name": "toArray", "type": "let toArray: t => array(key)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.Int", "name": "ofArray", "type": "let ofArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt_HashSet.Int", "name": "fromArray", "type": "let fromArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt_HashSet.Int", "name": "mergeMany", "type": "let mergeMany: (t, array(key)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(key)"]]}, {"path": "Belt_HashSet.Int", "name": "getBucketHistogram", "type": "let getBucketHistogram: t => array(int)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_HashSet.String", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt_HashSet.String", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Belt_HashSet.String", "name": "make", "type": "let make: (~hintSize: int) => t", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt_HashSet.String", "name": "clear", "type": "let clear: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.String", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.String", "name": "add", "type": "let add: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSet.String", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.String", "name": "has", "type": "let has: (t, key) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSet.String", "name": "remove", "type": "let remove: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt_HashSet.String", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of key ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of key ], unit)"]]}, {"path": "Belt_HashSet.String", "name": "forEach", "type": "let forEach: (t, key => unit) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key => unit"]]}, {"path": "Belt_HashSet.String", "name": "reduceU", "type": "let reduceU: (t, 'c, Js.Internal.fn([ `Arity_2 of 'c4 * key ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'c4 * key ], 'c)"]]}, {"path": "Belt_HashSet.String", "name": "reduce", "type": "let reduce: (t, 'c, ('c, key) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "('c, key) => 'c"]]}, {"path": "Belt_HashSet.String", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.String", "name": "logStats", "type": "let logStats: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.String", "name": "toArray", "type": "let toArray: t => array(key)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet.String", "name": "ofArray", "type": "let ofArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt_HashSet.String", "name": "fromArray", "type": "let fromArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt_HashSet.String", "name": "mergeMany", "type": "let mergeMany: (t, array(key)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(key)"]]}, {"path": "Belt_HashSet.String", "name": "getBucketHistogram", "type": "let getBucketHistogram: t => array(int)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt_HashSet", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_HashSet", "name": "t", "type": "type t('a, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_HashSet", "name": "id", "type": "type id('a, 'id) = Belt_Id.hashable('a, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_HashSet", "name": "make", "type": "let make: (~hintSize: int, ~id: id('a, 'id)) => t('a, 'id)", "docs": null, "kind": "value", "args": [["hintSize", "int"], ["id", "id('a, 'id)"]]}, {"path": "Belt_HashSet", "name": "clear", "type": "let clear: t('a, 'id) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"]]}, {"path": "Belt_HashSet", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_HashSet", "name": "add", "type": "let add: (t('a, 'id), 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "'a"]]}, {"path": "Belt_HashSet", "name": "copy", "type": "let copy: t('a, 'id) => t('a, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"]]}, {"path": "Belt_HashSet", "name": "has", "type": "let has: (t('a, 'id), 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "'a"]]}, {"path": "Belt_HashSet", "name": "remove", "type": "let remove: (t('a, 'id), 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "'a"]]}, {"path": "Belt_HashSet", "name": "forEachU", "type": "let forEachU: (t('a, 'id), Js.Internal.fn([ `Arity_1 of 'a34 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'a34 ], unit)"]]}, {"path": "Belt_HashSet", "name": "forEach", "type": "let forEach: (t('a, 'id), 'a => unit) => unit", "docs": "<p>Order unspecified.</p>\n", "kind": "value", "args": [["", "t('a, 'id)"], ["", "'a => unit"]]}, {"path": "Belt_HashSet", "name": "reduceU", "type": "let reduceU: (t('a, 'id), 'c, Js.Internal.fn([ `Arity_2 of 'c3 * 'a33 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'c3 * 'a33 ], 'c)"]]}, {"path": "Belt_HashSet", "name": "reduce", "type": "let reduce: (t('a, 'id), 'c, ('c, 'a) => 'c) => 'c", "docs": "<p>Order unspecified.</p>\n", "kind": "value", "args": [["", "t('a, 'id)"], ["", "'c"], ["", "('c, 'a) => 'c"]]}, {"path": "Belt_HashSet", "name": "size", "type": "let size: t('a, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"]]}, {"path": "Belt_HashSet", "name": "logStats", "type": "let logStats: t('a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt_HashSet", "name": "toArray", "type": "let toArray: t('a, 'id) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"]]}, {"path": "Belt_HashSet", "name": "ofArray", "type": "let ofArray: (array('a), ~id: id('a, 'id)) => t('a, 'id)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["id", "id('a, 'id)"]]}, {"path": "Belt_HashSet", "name": "fromArray", "type": "let fromArray: (array('a), ~id: id('a, 'id)) => t('a, 'id)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["id", "id('a, 'id)"]]}, {"path": "Belt_HashSet", "name": "mergeMany", "type": "let mergeMany: (t('a, 'id), array('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "array('a)"]]}, {"path": "Belt_HashSet", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a, 'a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "", "name": "Belt_HashSet", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt_HashMapString", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt_HashMapString", "name": "t", "type": "type t('b)", "docs": null, "kind": "type"}, {"path": "Belt_HashMapString", "name": "make", "type": "let make: (~hintSize: int) => t('b)", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt_HashMapString", "name": "clear", "type": "let clear: t('b) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"]]}, {"path": "Belt_HashMapString", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapString", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>setDone tbl k v</code> if <code>k</code> does not exist, add the binding <code>k,v</code>, otherwise, update the old value with the new <code>v</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_HashMapString", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapString", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_HashMapString", "name": "has", "type": "let has: (t('b), key) => bool", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "key"]]}, {"path": "Belt_HashMapString", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_HashMapString", "name": "forEachU", "type": "let forEachU: (t('b), Js.Internal.fn([ `Arity_2 of key * 'b8 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'b8 ], unit)"]]}, {"path": "Belt_HashMapString", "name": "forEach", "type": "let forEach: (t('b), (key, 'b) => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "(key, 'b) => unit"]]}, {"path": "Belt_HashMapString", "name": "reduceU", "type": "let reduceU: (t('b), 'c, Js.Internal.fn([ `Arity_3 of 'c1 * key * 'b7 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c1 * key * 'b7 ], 'c)"]]}, {"path": "Belt_HashMapString", "name": "reduce", "type": "let reduce: (t('b), 'c, ('c, key, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "('c, key, 'b) => 'c"]]}, {"path": "Belt_HashMapString", "name": "keepMapInPlaceU", "type": "let keepMapInPlaceU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a31 ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a31 ], option('a))"]]}, {"path": "Belt_HashMapString", "name": "keepMapInPlace", "type": "let keepMapInPlace: (t('a), (key, 'a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => option('a)"]]}, {"path": "Belt_HashMapString", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapString", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapString", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapString", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapString", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_HashMapString", "name": "mergeMany", "type": "let mergeMany: (t('a), array((key, 'a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "array((key, 'a))"]]}, {"path": "Belt_HashMapString", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapString", "name": "logStats", "type": "let logStats: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapString", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "", "name": "Belt_HashMapString", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlaceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_HashMapInt", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt_HashMapInt", "name": "t", "type": "type t('b)", "docs": null, "kind": "type"}, {"path": "Belt_HashMapInt", "name": "make", "type": "let make: (~hintSize: int) => t('b)", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt_HashMapInt", "name": "clear", "type": "let clear: t('b) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"]]}, {"path": "Belt_HashMapInt", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapInt", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>setDone tbl k v</code> if <code>k</code> does not exist, add the binding <code>k,v</code>, otherwise, update the old value with the new <code>v</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_HashMapInt", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapInt", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_HashMapInt", "name": "has", "type": "let has: (t('b), key) => bool", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "key"]]}, {"path": "Belt_HashMapInt", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_HashMapInt", "name": "forEachU", "type": "let forEachU: (t('b), Js.Internal.fn([ `Arity_2 of key * 'b10 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'b10 ], unit)"]]}, {"path": "Belt_HashMapInt", "name": "forEach", "type": "let forEach: (t('b), (key, 'b) => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "(key, 'b) => unit"]]}, {"path": "Belt_HashMapInt", "name": "reduceU", "type": "let reduceU: (t('b), 'c, Js.Internal.fn([ `Arity_3 of 'c2 * key * 'b9 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c2 * key * 'b9 ], 'c)"]]}, {"path": "Belt_HashMapInt", "name": "reduce", "type": "let reduce: (t('b), 'c, ('c, key, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "('c, key, 'b) => 'c"]]}, {"path": "Belt_HashMapInt", "name": "keepMapInPlaceU", "type": "let keepMapInPlaceU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a32 ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a32 ], option('a))"]]}, {"path": "Belt_HashMapInt", "name": "keepMapInPlace", "type": "let keepMapInPlace: (t('a), (key, 'a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => option('a)"]]}, {"path": "Belt_HashMapInt", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapInt", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapInt", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapInt", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapInt", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_HashMapInt", "name": "mergeMany", "type": "let mergeMany: (t('a), array((key, 'a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "array((key, 'a))"]]}, {"path": "Belt_HashMapInt", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapInt", "name": "logStats", "type": "let logStats: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMapInt", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "", "name": "Belt_HashMapInt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlaceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt_HashMap.Int", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt_HashMap.Int", "name": "t", "type": "type t('b)", "docs": null, "kind": "type"}, {"path": "Belt_HashMap.Int", "name": "make", "type": "let make: (~hintSize: int) => t('b)", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt_HashMap.Int", "name": "clear", "type": "let clear: t('b) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"]]}, {"path": "Belt_HashMap.Int", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.Int", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>setDone tbl k v</code> if <code>k</code> does not exist, add the binding <code>k,v</code>, otherwise, update the old value with the new <code>v</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_HashMap.Int", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.Int", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_HashMap.Int", "name": "has", "type": "let has: (t('b), key) => bool", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "key"]]}, {"path": "Belt_HashMap.Int", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_HashMap.Int", "name": "forEachU", "type": "let forEachU: (t('b), Js.Internal.fn([ `Arity_2 of key * 'b10 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'b10 ], unit)"]]}, {"path": "Belt_HashMap.Int", "name": "forEach", "type": "let forEach: (t('b), (key, 'b) => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "(key, 'b) => unit"]]}, {"path": "Belt_HashMap.Int", "name": "reduceU", "type": "let reduceU: (t('b), 'c, Js.Internal.fn([ `Arity_3 of 'c2 * key * 'b9 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c2 * key * 'b9 ], 'c)"]]}, {"path": "Belt_HashMap.Int", "name": "reduce", "type": "let reduce: (t('b), 'c, ('c, key, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "('c, key, 'b) => 'c"]]}, {"path": "Belt_HashMap.Int", "name": "keepMapInPlaceU", "type": "let keepMapInPlaceU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a32 ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a32 ], option('a))"]]}, {"path": "Belt_HashMap.Int", "name": "keepMapInPlace", "type": "let keepMapInPlace: (t('a), (key, 'a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => option('a)"]]}, {"path": "Belt_HashMap.Int", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.Int", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.Int", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.Int", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.Int", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_HashMap.Int", "name": "mergeMany", "type": "let mergeMany: (t('a), array((key, 'a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "array((key, 'a))"]]}, {"path": "Belt_HashMap.Int", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.Int", "name": "logStats", "type": "let logStats: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.Int", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_HashMap", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlaceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_HashMap.String", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt_HashMap.String", "name": "t", "type": "type t('b)", "docs": null, "kind": "type"}, {"path": "Belt_HashMap.String", "name": "make", "type": "let make: (~hintSize: int) => t('b)", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt_HashMap.String", "name": "clear", "type": "let clear: t('b) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"]]}, {"path": "Belt_HashMap.String", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.String", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>setDone tbl k v</code> if <code>k</code> does not exist, add the binding <code>k,v</code>, otherwise, update the old value with the new <code>v</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt_HashMap.String", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.String", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_HashMap.String", "name": "has", "type": "let has: (t('b), key) => bool", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "key"]]}, {"path": "Belt_HashMap.String", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt_HashMap.String", "name": "forEachU", "type": "let forEachU: (t('b), Js.Internal.fn([ `Arity_2 of key * 'b8 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'b8 ], unit)"]]}, {"path": "Belt_HashMap.String", "name": "forEach", "type": "let forEach: (t('b), (key, 'b) => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "(key, 'b) => unit"]]}, {"path": "Belt_HashMap.String", "name": "reduceU", "type": "let reduceU: (t('b), 'c, Js.Internal.fn([ `Arity_3 of 'c1 * key * 'b7 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c1 * key * 'b7 ], 'c)"]]}, {"path": "Belt_HashMap.String", "name": "reduce", "type": "let reduce: (t('b), 'c, ('c, key, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "('c, key, 'b) => 'c"]]}, {"path": "Belt_HashMap.String", "name": "keepMapInPlaceU", "type": "let keepMapInPlaceU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a31 ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a31 ], option('a))"]]}, {"path": "Belt_HashMap.String", "name": "keepMapInPlace", "type": "let keepMapInPlace: (t('a), (key, 'a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => option('a)"]]}, {"path": "Belt_HashMap.String", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.String", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.String", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.String", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.String", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_HashMap.String", "name": "mergeMany", "type": "let mergeMany: (t('a), array((key, 'a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "array((key, 'a))"]]}, {"path": "Belt_HashMap.String", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.String", "name": "logStats", "type": "let logStats: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt_HashMap.String", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt_HashMap", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlaceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt_HashMap", "name": "t", "type": "type t('key, 'value, 'id)", "docs": "<p>The type of hash tables from type <code>&#39;key</code> to type <code>&#39;value</code>.</p>\n", "kind": "type"}, {"path": "Belt_HashMap", "name": "id", "type": "type id('a, 'id) = Belt_Id.hashable('a, 'id)", "docs": null, "kind": "type"}, {"path": "Belt_HashMap", "name": "make", "type": "let make: (~hintSize: int, ~id: id('key, 'id)) => t('key, 'value, 'id)", "docs": null, "kind": "value", "args": [["hintSize", "int"], ["id", "id('key, 'id)"]]}, {"path": "Belt_HashMap", "name": "clear", "type": "let clear: t('key, 'value, 'id) => unit", "docs": "<p>Empty a hash table.</p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"]]}, {"path": "Belt_HashMap", "name": "isEmpty", "type": "let isEmpty: t('a, 'a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_HashMap", "name": "set", "type": "let set: (t('key, 'value, 'id), 'key, 'value) => unit", "docs": "<p><code>set tbl k v</code> if <code>k</code> does not exist, add the binding <code>k,v</code>, otherwise, update the old value with the new <code>v</code></p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'key"], ["", "'value"]]}, {"path": "Belt_HashMap", "name": "copy", "type": "let copy: t('key, 'value, 'id) => t('key, 'value, 'id)", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"]]}, {"path": "Belt_HashMap", "name": "get", "type": "let get: (t('key, 'value, 'id), 'key) => option('value)", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'key"]]}, {"path": "Belt_HashMap", "name": "has", "type": "let has: (t('key, 'value, 'id), 'key) => bool", "docs": "<p><code>has tbl x</code> checks if <code>x</code> is bound in <code>tbl</code>.</p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'key"]]}, {"path": "Belt_HashMap", "name": "remove", "type": "let remove: (t('key, 'value, 'id), 'key) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'key"]]}, {"path": "Belt_HashMap", "name": "forEachU", "type": "let forEachU: (t('key, 'value, 'id), Js.Internal.fn([ `Arity_2 of 'key1 * 'value1 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'key1 * 'value1 ], unit)"]]}, {"path": "Belt_HashMap", "name": "forEach", "type": "let forEach: (t('key, 'value, 'id), ('key, 'value) => unit) => unit", "docs": "<p><code>forEach tbl f</code> applies <code>f</code> to all bindings in table <code>tbl</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "('key, 'value) => unit"]]}, {"path": "Belt_HashMap", "name": "reduceU", "type": "let reduceU: (\n  t('key, 'value, 'id),\n  'c,\n  Js.Internal.fn([ `Arity_3 of 'c0 * 'key0 * 'value0 ], 'c)\n) => 'c", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c0 * 'key0 * 'value0 ], 'c)"]]}, {"path": "Belt_HashMap", "name": "reduce", "type": "let reduce: (t('key, 'value, 'id), 'c, ('c, 'key, 'value) => 'c) => 'c", "docs": "<p><code>reduce  tbl init f</code> computes <code>(f kN dN ... (f k1 d1 init)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>tbl</code>, and <code>d1 ... dN</code> are the associated values. Each binding is presented exactly once to <code>f</code>.</p>\n<p>The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'c"], ["", "('c, 'key, 'value) => 'c"]]}, {"path": "Belt_HashMap", "name": "keepMapInPlaceU", "type": "let keepMapInPlaceU: (\n  t('key, 'value, 'id),\n  Js.Internal.fn([ `Arity_2 of 'key * 'value ], option('value))\n) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'key * 'value ], option('value))"]]}, {"path": "Belt_HashMap", "name": "keepMapInPlace", "type": "let keepMapInPlace: (t('key, 'value, 'id), ('key, 'value) => option('value)) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "('key, 'value) => option('value)"]]}, {"path": "Belt_HashMap", "name": "size", "type": "let size: t('a, 'a, 'a) => int", "docs": "<p><code>size tbl</code> returns the number of bindings in <code>tbl</code>. It takes constant time.</p>\n", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_HashMap", "name": "toArray", "type": "let toArray: t('key, 'value, 'id) => array(('key, 'value))", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"]]}, {"path": "Belt_HashMap", "name": "keysToArray", "type": "let keysToArray: t('key, 'a, 'a) => array('key)", "docs": null, "kind": "value", "args": [["", "t('key, 'a, 'a)"]]}, {"path": "Belt_HashMap", "name": "valuesToArray", "type": "let valuesToArray: t('a, 'value, 'a) => array('value)", "docs": null, "kind": "value", "args": [["", "t('a, 'value, 'a)"]]}, {"path": "Belt_HashMap", "name": "fromArray", "type": "let fromArray: (array(('key, 'value)), ~id: id('key, 'id)) => t('key, 'value, 'id)", "docs": null, "kind": "value", "args": [["", "array(('key, 'value))"], ["id", "id('key, 'id)"]]}, {"path": "Belt_HashMap", "name": "mergeMany", "type": "let mergeMany: (t('key, 'value, 'id), array(('key, 'value))) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "array(('key, 'value))"]]}, {"path": "Belt_HashMap", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a, 'a, 'a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_HashMap", "name": "logStats", "type": "let logStats: t('a, 'a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt_HashMap", "name": "ofArray", "type": "let ofArray: (array(('key, 'value)), ~id: id('key, 'id)) => t('key, 'value, 'id)", "docs": null, "kind": "value", "args": [["", "array(('key, 'value))"], ["id", "id('key, 'id)"]]}, {"path": "", "name": "Belt_HashMap", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlaceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt_Array", "name": "length", "type": "let length: array('a) => int", "docs": "<p><code>length xs</code> return the size of the array</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_Array", "name": "size", "type": "let size: array('a) => int", "docs": "<p><strong>See</strong> length</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_Array", "name": "get", "type": "let get: (array('a), int) => option('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_Array", "name": "getExn", "type": "let getExn: (array('a), int) => 'a", "docs": "<p><code>getExn arr i</code></p>\n<p><strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_Array", "name": "getUnsafe", "type": "let getUnsafe: (array('a), int) => 'a", "docs": "<p><code>getUnasfe arr i</code></p>\n<p><strong>Unsafe</strong></p>\n<p>no bounds checking, this would cause type error if <code>i</code> does not stay within range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_Array", "name": "getUndefined", "type": "let getUndefined: (array('a), int) => Js.undefined('a)", "docs": "<p><code>getUndefined arr i</code></p>\n<p>It does the samething in the runtime as getUnsafe, it is <em>type safe</em> since the return type still track whether it is in range or not</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt_Array", "name": "set", "type": "let set: (array('a), int, 'a) => bool", "docs": "<p><code>set arr n x</code> modifies <code>arr</code> in place, it replaces the nth element of <code>arr</code> with <code>x</code></p>\n<p>Returns: <p>false means not updated due to out of range</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_Array", "name": "setExn", "type": "let setExn: (array('a), int, 'a) => unit", "docs": "<p><code>setExn arr i x</code> <strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_Array", "name": "setUnsafe", "type": "let setUnsafe: (array('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt_Array", "name": "shuffleInPlace", "type": "let shuffleInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_Array", "name": "shuffle", "type": "let shuffle: array('a) => array('a)", "docs": "<p><code>shuffle xs</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_Array", "name": "reverseInPlace", "type": "let reverseInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_Array", "name": "reverse", "type": "let reverse: array('a) => array('a)", "docs": "<p><code>reverse x</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_Array", "name": "makeUninitialized", "type": "let makeUninitialized: int => array(Js.undefined('a))", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Belt_Array", "name": "makeUninitializedUnsafe", "type": "let makeUninitializedUnsafe: int => array('a)", "docs": "<p><code>makeUninitializedUnsafe n</code></p>\n<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Belt_Array", "name": "make", "type": "let make: (int, 'a) => array('a)", "docs": "<p><code>make n e</code> return an array of size <code>n</code> filled with value <code>e</code></p>\n<p>Returns: <p>an empty array when <code>n</code> is negative.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Belt_Array", "name": "range", "type": "let range: (int, int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Belt_Array", "name": "rangeBy", "type": "let rangeBy: (int, int, ~step: int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"]]}, {"path": "Belt_Array", "name": "makeByU", "type": "let makeByU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_Array", "name": "makeBy", "type": "let makeBy: (int, int => 'a) => array('a)", "docs": "<p><code>makeBy n f</code></p>\n<p>return an empty array when <code>n</code> is negative return an array of size <code>n</code> populated by <code>f i</code> start from <code>0</code> to <code>n - 1</code></p>\n<pre class='ml'><code class='ml'>makeBy 5 (fun i -&gt; i) = [|0;1;2;3;4|]\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_Array", "name": "makeByAndShuffleU", "type": "let makeByAndShuffleU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt_Array", "name": "makeByAndShuffle", "type": "let makeByAndShuffle: (int, int => 'a) => array('a)", "docs": "<p><code>makeByAndShuffle n f</code></p>\n<p>Equivalent to <code>shuffle (makeBy n f)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt_Array", "name": "zip", "type": "let zip: (array('a), array('b)) => array(('a, 'b))", "docs": "<p><code>zip a b</code></p>\n<p>Stop with the shorter array</p>\n<pre class='ml'><code class='ml'>zip [|1;2] [|1;2;3|] = [| (1,2); (2;2)|]\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"]]}, {"path": "Belt_Array", "name": "zipByU", "type": "let zipByU: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)) => array('c)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)"]]}, {"path": "Belt_Array", "name": "zipBy", "type": "let zipBy: (array('a), array('b), ('a, 'b) => 'c) => array('c)", "docs": "<p><code>zipBy xs ys f</code></p>\n<p>Stops with shorter array</p>\n<p>Equivalent to <code>map (zip xs ys) (fun (a,b) -&gt; f a b) </code></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt_Array", "name": "concat", "type": "let concat: (array('a), array('a)) => array('a)", "docs": "<p><code>concat xs ys</code></p>\n<p>Returns: <p>a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>, so even if <code>v1</code> or <code>v2</code> is empty, it can not be shared</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"]]}, {"path": "Belt_Array", "name": "concatMany", "type": "let concatMany: array(array('a)) => array('a)", "docs": "<p><code>concatMany xss</code></p>\n<p>Returns: <p>a fresh array as the concatenation of <code>xss</code></p></p>\n", "kind": "value", "args": [["", "array(array('a))"]]}, {"path": "Belt_Array", "name": "slice", "type": "let slice: (array('a), ~offset: int, ~len: int) => array('a)", "docs": "<p><code>slice arr offset len</code></p>\n<p><code>offset</code> can be negative, <code>slice arr -1 1</code> means get the last element as a singleton array</p>\n<p><code>slice arr -(very_large_index) len</code> will do a copy of the array</p>\n<p>if the array does not have enough data, <code>slice</code> extracts through the end of sequence</p>\n", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"]]}, {"path": "Belt_Array", "name": "copy", "type": "let copy: array('a) => array('a)", "docs": "<p><code>copy a</code></p>\n<p>Returns: <p>a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt_Array", "name": "fill", "type": "let fill: (array('a), ~offset: int, ~len: int, 'a) => unit", "docs": "<p><code>fill arr ~offset ~len x</code></p>\n<p>Modifies <code>arr</code> in place, storing <code>x</code> in elements number <code>offset</code> to <code>offset + len - 1</code>.</p>\n<p><code>offset</code> can be negative</p>\n<p><code>fill arr offset:(-1) len:1 </code> means fill the last element, if the array does not have enough data, <code>fill</code> will ignore it</p>\n<pre class='ml'><code class='ml'>\nlet arr = makeBy 5 (fun i -&gt; i) ;;\nfill arr ~offset:2 ~len:2 0 ;;\narr = [|0;1;0;0;4|];;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"], ["", "'a"]]}, {"path": "Belt_Array", "name": "blit", "type": "let blit: (~src: array('a), ~srcOffset: int, ~dst: array('a), ~dstOffset: int, ~len: int) => unit", "docs": "<p><code>blit ~src:v1 ~srcOffset:o1 ~dst:v2 ~dstOffset:o2 ~len</code></p>\n<p>copies <code>len</code> elements from array <code>v1</code>, starting at element number <code>o1</code>, to array <code>v2</code>, starting at element number <code>o2</code>.</p>\n<p>It works correctly even if <code>v1</code> and <code>v2</code> are the same array, and the source and destination chunks overlap.</p>\n<p><code>offset</code> can be negative, <code>-1</code> means <code>len - 1</code>, if <code>len + offset</code> is still negative, it will be set as 0</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_Array", "name": "blitUnsafe", "type": "let blitUnsafe: (\n  ~src: array('a),\n  ~srcOffset: int,\n  ~dst: array('a),\n  ~dstOffset: int,\n  ~len: int\n) => unit", "docs": "<p><strong>Unsafe</strong> blit without bounds checking</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt_Array", "name": "forEachU", "type": "let forEachU: (array('a), Js.Internal.fn([ `Arity_1 of 'a134 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a134 ], unit)"]]}, {"path": "Belt_Array", "name": "forEach", "type": "let forEach: (array('a), 'a => unit) => unit", "docs": "<p><code>forEach xs f</code></p>\n<p>Call f on each element of <code>xs</code> from the beginning to end</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => unit"]]}, {"path": "Belt_Array", "name": "mapU", "type": "let mapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)"]]}, {"path": "Belt_Array", "name": "map", "type": "let map: (array('a), 'a => 'b) => array('b)", "docs": "<p><code>map xs f </code></p>\n<p>Returns: <p>a new array by calling <code>f</code> to element of <code>xs</code> from the beginning to end</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => 'b"]]}, {"path": "Belt_Array", "name": "keepU", "type": "let keepU: (array('a), Js.Internal.fn([ `Arity_1 of 'a132 ], bool)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a132 ], bool)"]]}, {"path": "Belt_Array", "name": "keep", "type": "let keep: (array('a), 'a => bool) => array('a)", "docs": "<p><code>keep xs p </code></p>\n<p>Returns: <p>a new array that keep all elements satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [|1;2;3|] (fun x -&gt; x mod  2 = 0) = [|2|]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_Array", "name": "keepMapU", "type": "let keepMapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))"]]}, {"path": "Belt_Array", "name": "keepMap", "type": "let keepMap: (array('a), 'a => option('b)) => array('b)", "docs": "<p><code>keepMap xs p</code></p>\n<p>Returns: <p>a new array that keep all elements that return a non-None applied <code>p</code></p>\n<pre class='ml'><code class='ml'>keepMap [|1;2;3|] (fun x -&gt; if x mod 2 then Some x else None)\n= [| 2 |]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => option('b)"]]}, {"path": "Belt_Array", "name": "forEachWithIndexU", "type": "let forEachWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)"]]}, {"path": "Belt_Array", "name": "forEachWithIndex", "type": "let forEachWithIndex: (array('a), (int, 'a) => unit) => unit", "docs": "<p><code>forEachWithIndex xs f</code></p>\n<p>The same with forEach, except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => unit"]]}, {"path": "Belt_Array", "name": "mapWithIndexU", "type": "let mapWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)"]]}, {"path": "Belt_Array", "name": "mapWithIndex", "type": "let mapWithIndex: (array('a), (int, 'a) => 'b) => array('b)", "docs": "<p><code>mapWithIndex xs f </code></p>\n<p>The same with map except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt_Array", "name": "reduceU", "type": "let reduceU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)"]]}, {"path": "Belt_Array", "name": "reduce", "type": "let reduce: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduce xs init f</code></p>\n<pre class='ml'><code class='ml'>reduce [|2;3;4|] 1 (+) = 10\n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_Array", "name": "reduceReverseU", "type": "let reduceReverseU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)"]]}, {"path": "Belt_Array", "name": "reduceReverse", "type": "let reduceReverse: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduceReverse xs init f</code></p>\n<pre class='ml'><code class='ml'>reduceReverse [|1;2;3;4|] 100 (-) = 90 \n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt_Array", "name": "reduceReverse2U", "type": "let reduceReverse2U: (\n  array('a),\n  array('b),\n  'c,\n  Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)\n) => 'c", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)"]]}, {"path": "Belt_Array", "name": "reduceReverse2", "type": "let reduceReverse2: (array('a), array('b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": "<pre class='ml'><code class='ml'>reduceReverse2 [|1;2;3|] [|1;2|] 0 (fun acc x y -&gt; acc + x + y) = 6\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt_Array", "name": "someU", "type": "let someU: (array('a), Js.Internal.fn([ `Arity_1 of 'a125 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a125 ], bool)"]]}, {"path": "Belt_Array", "name": "some", "type": "let some: (array('a), 'a => bool) => bool", "docs": "<p><code>some xs p</code></p>\n<p>Returns: <p>true if one of element satifies <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_Array", "name": "everyU", "type": "let everyU: (array('a), Js.Internal.fn([ `Arity_1 of 'a124 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a124 ], bool)"]]}, {"path": "Belt_Array", "name": "every", "type": "let every: (array('a), 'a => bool) => bool", "docs": "<p><code>every xs p</code></p>\n<p>Returns: <p>true if all elements satisfy <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt_Array", "name": "every2U", "type": "let every2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)"]]}, {"path": "Belt_Array", "name": "every2", "type": "let every2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>every2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>every2 [|1;2;3|] [|0;1|] (&gt;) = true;;\n(every2 [||] [|1|] (fun   x y -&gt; x &gt; y)) = true;;\n(every2 [|2;3|] [|1|] (fun   x y -&gt; x &gt; y)) = true;; \n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_Array", "name": "some2U", "type": "let some2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)"]]}, {"path": "Belt_Array", "name": "some2", "type": "let some2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>some2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>some2 [|0;2|] [|1;0;3|] (&gt;) = true ;;\n(some2 [||] [|1|] (fun   x y -&gt; x &gt; y)) =  false;;\n(some2 [|2;3|] [|1;4|] (fun   x y -&gt; x &gt; y)) = true;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt_Array", "name": "cmpU", "type": "let cmpU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)"]]}, {"path": "Belt_Array", "name": "cmp", "type": "let cmp: (array('a), array('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp a b</code></p>\n<ul><li><p>Compared by length if <code>length a &lt;&gt; length b</code></p>\n</li><li><p>Otherwise compare one by one <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt_Array", "name": "eqU", "type": "let eqU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)"]]}, {"path": "Belt_Array", "name": "eq", "type": "let eq: (array('a), array('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq a b</code></p>\n<ul><li><p>return false if length is not the same</p>\n</li><li><p>equal one by one using <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt_Array", "name": "truncateToLengthUnsafe", "type": "let truncateToLengthUnsafe: (array('a), int) => unit", "docs": "<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "", "name": "Belt_Array", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blitUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffleU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitialized\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitializedUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>range\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rangeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffleInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncateToLengthUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipByU", "docs": null, "kind": "module"}, {"path": "Belt.Id", "name": "hash", "type": "type hash('a, 'id)", "docs": "<p><code>(&#39;a, &#39;id) hash</code></p>\n<p>Its runtime represenation is a <code>hash</code> function, but signed with a type parameter, so that different hash functions type mismatch</p>\n", "kind": "type"}, {"path": "Belt.Id", "name": "eq", "type": "type eq('a, 'id)", "docs": "<p><code>(&#39;a, &#39;id) eq</code></p>\n<p>Its runtime represenation is an <code>eq</code> function, but signed with a type parameter, so that different hash functions type mismatch</p>\n", "kind": "type"}, {"path": "Belt.Id", "name": "cmp", "type": "type cmp('a, 'id)", "docs": "<p><code>(&#39;a,&#39;id) cmp</code></p>\n<p>Its runtime representation is a <code>cmp</code> function, but signed with a type parameter, so that different hash functions type mismatch</p>\n", "kind": "type"}, {"path": "Belt.Id", "name": "comparable", "type": "type comparable('key, 'id) = (module Comparable with type identity = 'id0 and type t = 'key3)", "docs": "<p><code>(&#39;key, &#39;id) cmparable</code> is a module of functions, here it only includes <code>cmp</code>.</p>\n<p>Unlike normal functions, when created, it comes with a unique identity (guaranteed by the type system).</p>\n<p>It can be created using function comparableU orcomparable.</p>\n<p>The idea of a unique identity when created is that it makes sure two sets would type mismatch if they use different comparison function</p>\n", "kind": "type"}, {"path": "Belt.Id", "name": "MakeComparableU", "type": "", "docs": null, "kind": "module"}, {"path": "Belt.Id", "name": "MakeComparable", "type": "", "docs": null, "kind": "module"}, {"path": "Belt.Id", "name": "comparableU", "type": "let comparableU: (\n  ~cmp: Js.Internal.fn(\n    [ `Arity_2 of 'a142 * 'a142 ],\n    int\n  )\n) => (module Comparable with type t = 'a142)", "docs": null, "kind": "value", "args": [["cmp", "Js.Internal.fn([ `Arity_2 of 'a142 * 'a142 ], int)"]]}, {"path": "Belt.Id", "name": "comparable", "type": "let comparable: (~cmp: ('a, 'a) => int) => (module Comparable with type t = 'a141)", "docs": null, "kind": "value", "args": [["cmp", "('a, 'a) => int"]]}, {"path": "Belt.Id", "name": "hashable", "type": "type hashable('key, 'id) = (module Hashable with type identity = 'id and type t = 'key2)", "docs": "<p><code>(&#39;key, &#39;id) hashable</code> is a module of functions, here it only includes <code>hash</code>, <code>eq</code>.</p>\n<p>Unlike normal functions, when created, it comes with a unique identity (guaranteed by the type system).</p>\n<p>It can be created using function hashableU or hashable.</p>\n<p>The idea of a unique identity when created is that it makes sure two hash sets would type mismatch if they use different comparison function</p>\n", "kind": "type"}, {"path": "Belt.Id", "name": "MakeHashableU", "type": "", "docs": null, "kind": "module"}, {"path": "Belt.Id", "name": "MakeHashable", "type": "", "docs": null, "kind": "module"}, {"path": "Belt.Id", "name": "hashableU", "type": "let hashableU: (\n  ~hash: Js.Internal.fn([ `Arity_1 of 'a140 ], int),\n  ~eq: Js.Internal.fn([ `Arity_2 of 'a140 * 'a140 ], bool)\n) => (module Hashable with type t = 'a140)", "docs": null, "kind": "value", "args": [["hash", "Js.Internal.fn([ `Arity_1 of 'a140 ], int)"], ["eq", "Js.Internal.fn([ `Arity_2 of 'a140 * 'a140 ], bool)"]]}, {"path": "Belt.Id", "name": "hashable", "type": "let hashable: (~hash: 'a => int, ~eq: ('a, 'a) => bool) => (module Hashable with type t = 'a139)", "docs": null, "kind": "value", "args": [["hash", "'a => int"], ["eq", "('a, 'a) => bool"]]}, {"path": "Belt.Id", "name": "getHashInternal", "type": "let getHashInternal: hash('a, 'id) => Js.Internal.fn([ `Arity_1 of 'a138 ], int)", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "hash('a, 'id)"]]}, {"path": "Belt.Id", "name": "getEqInternal", "type": "let getEqInternal: eq('a, 'id) => Js.Internal.fn([ `Arity_2 of 'a137 * 'a137 ], bool)", "docs": null, "kind": "value", "args": [["", "eq('a, 'id)"]]}, {"path": "Belt.Id", "name": "getCmpInternal", "type": "let getCmpInternal: cmp('a, 'id) => Js.Internal.fn([ `Arity_2 of 'a136 * 'a136 ], int)", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "cmp('a, 'id)"]]}, {"path": "Belt", "name": "Id", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>comparable\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>comparableU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getCmpInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getEqInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getHashInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hashable\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hashableU\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>comparable\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>eq\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>hash\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>hashable\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeComparable\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeComparableU\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeHashable\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeHashableU", "docs": null, "kind": "module"}, {"path": "Belt.Array", "name": "length", "type": "let length: array('a) => int", "docs": "<p><code>length xs</code> return the size of the array</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.Array", "name": "size", "type": "let size: array('a) => int", "docs": "<p><strong>See</strong> length</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.Array", "name": "get", "type": "let get: (array('a), int) => option('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt.Array", "name": "getExn", "type": "let getExn: (array('a), int) => 'a", "docs": "<p><code>getExn arr i</code></p>\n<p><strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt.Array", "name": "getUnsafe", "type": "let getUnsafe: (array('a), int) => 'a", "docs": "<p><code>getUnasfe arr i</code></p>\n<p><strong>Unsafe</strong></p>\n<p>no bounds checking, this would cause type error if <code>i</code> does not stay within range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt.Array", "name": "getUndefined", "type": "let getUndefined: (array('a), int) => Js.undefined('a)", "docs": "<p><code>getUndefined arr i</code></p>\n<p>It does the samething in the runtime as getUnsafe, it is <em>type safe</em> since the return type still track whether it is in range or not</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt.Array", "name": "set", "type": "let set: (array('a), int, 'a) => bool", "docs": "<p><code>set arr n x</code> modifies <code>arr</code> in place, it replaces the nth element of <code>arr</code> with <code>x</code></p>\n<p>Returns: <p>false means not updated due to out of range</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt.Array", "name": "setExn", "type": "let setExn: (array('a), int, 'a) => unit", "docs": "<p><code>setExn arr i x</code> <strong>raise</strong> an exception if <code>i</code> is out of range</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt.Array", "name": "setUnsafe", "type": "let setUnsafe: (array('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Belt.Array", "name": "shuffleInPlace", "type": "let shuffleInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.Array", "name": "shuffle", "type": "let shuffle: array('a) => array('a)", "docs": "<p><code>shuffle xs</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.Array", "name": "reverseInPlace", "type": "let reverseInPlace: array('a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.Array", "name": "reverse", "type": "let reverse: array('a) => array('a)", "docs": "<p><code>reverse x</code></p>\n<p>Returns: <p>a fresh array</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.Array", "name": "makeUninitialized", "type": "let makeUninitialized: int => array(Js.undefined('a))", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Belt.Array", "name": "makeUninitializedUnsafe", "type": "let makeUninitializedUnsafe: int => array('a)", "docs": "<p><code>makeUninitializedUnsafe n</code></p>\n<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Belt.Array", "name": "make", "type": "let make: (int, 'a) => array('a)", "docs": "<p><code>make n e</code> return an array of size <code>n</code> filled with value <code>e</code></p>\n<p>Returns: <p>an empty array when <code>n</code> is negative.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Belt.Array", "name": "range", "type": "let range: (int, int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Belt.Array", "name": "rangeBy", "type": "let rangeBy: (int, int, ~step: int) => array(int)", "docs": "<p><code>range start finish</code> create an inclusive array</p>\n<pre class='ml'><code class='ml'>range 0 3 =  [|0;1;2;3|];;\nrange 3 0 =  [||] ;;\nrange 3 3 = [|3|];;\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"]]}, {"path": "Belt.Array", "name": "makeByU", "type": "let makeByU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt.Array", "name": "makeBy", "type": "let makeBy: (int, int => 'a) => array('a)", "docs": "<p><code>makeBy n f</code></p>\n<p>return an empty array when <code>n</code> is negative return an array of size <code>n</code> populated by <code>f i</code> start from <code>0</code> to <code>n - 1</code></p>\n<pre class='ml'><code class='ml'>makeBy 5 (fun i -&gt; i) = [|0;1;2;3;4|]\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt.Array", "name": "makeByAndShuffleU", "type": "let makeByAndShuffleU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => array('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt.Array", "name": "makeByAndShuffle", "type": "let makeByAndShuffle: (int, int => 'a) => array('a)", "docs": "<p><code>makeByAndShuffle n f</code></p>\n<p>Equivalent to <code>shuffle (makeBy n f)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt.Array", "name": "zip", "type": "let zip: (array('a), array('b)) => array(('a, 'b))", "docs": "<p><code>zip a b</code></p>\n<p>Stop with the shorter array</p>\n<pre class='ml'><code class='ml'>zip [|1;2] [|1;2;3|] = [| (1,2); (2;2)|]\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"]]}, {"path": "Belt.Array", "name": "zipByU", "type": "let zipByU: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)) => array('c)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a135 * 'b36 ], 'c)"]]}, {"path": "Belt.Array", "name": "zipBy", "type": "let zipBy: (array('a), array('b), ('a, 'b) => 'c) => array('c)", "docs": "<p><code>zipBy xs ys f</code></p>\n<p>Stops with shorter array</p>\n<p>Equivalent to <code>map (zip xs ys) (fun (a,b) -&gt; f a b) </code></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt.Array", "name": "concat", "type": "let concat: (array('a), array('a)) => array('a)", "docs": "<p><code>concat xs ys</code></p>\n<p>Returns: <p>a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>, so even if <code>v1</code> or <code>v2</code> is empty, it can not be shared</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"]]}, {"path": "Belt.Array", "name": "concatMany", "type": "let concatMany: array(array('a)) => array('a)", "docs": "<p><code>concatMany xss</code></p>\n<p>Returns: <p>a fresh array as the concatenation of <code>xss</code></p></p>\n", "kind": "value", "args": [["", "array(array('a))"]]}, {"path": "Belt.Array", "name": "slice", "type": "let slice: (array('a), ~offset: int, ~len: int) => array('a)", "docs": "<p><code>slice arr offset len</code></p>\n<p><code>offset</code> can be negative, <code>slice arr -1 1</code> means get the last element as a singleton array</p>\n<p><code>slice arr -(very_large_index) len</code> will do a copy of the array</p>\n<p>if the array does not have enough data, <code>slice</code> extracts through the end of sequence</p>\n", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"]]}, {"path": "Belt.Array", "name": "copy", "type": "let copy: array('a) => array('a)", "docs": "<p><code>copy a</code></p>\n<p>Returns: <p>a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.Array", "name": "fill", "type": "let fill: (array('a), ~offset: int, ~len: int, 'a) => unit", "docs": "<p><code>fill arr ~offset ~len x</code></p>\n<p>Modifies <code>arr</code> in place, storing <code>x</code> in elements number <code>offset</code> to <code>offset + len - 1</code>.</p>\n<p><code>offset</code> can be negative</p>\n<p><code>fill arr offset:(-1) len:1 </code> means fill the last element, if the array does not have enough data, <code>fill</code> will ignore it</p>\n<pre class='ml'><code class='ml'>\nlet arr = makeBy 5 (fun i -&gt; i) ;;\nfill arr ~offset:2 ~len:2 0 ;;\narr = [|0;1;0;0;4|];;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["offset", "int"], ["len", "int"], ["", "'a"]]}, {"path": "Belt.Array", "name": "blit", "type": "let blit: (~src: array('a), ~srcOffset: int, ~dst: array('a), ~dstOffset: int, ~len: int) => unit", "docs": "<p><code>blit ~src:v1 ~srcOffset:o1 ~dst:v2 ~dstOffset:o2 ~len</code></p>\n<p>copies <code>len</code> elements from array <code>v1</code>, starting at element number <code>o1</code>, to array <code>v2</code>, starting at element number <code>o2</code>.</p>\n<p>It works correctly even if <code>v1</code> and <code>v2</code> are the same array, and the source and destination chunks overlap.</p>\n<p><code>offset</code> can be negative, <code>-1</code> means <code>len - 1</code>, if <code>len + offset</code> is still negative, it will be set as 0</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt.Array", "name": "blitUnsafe", "type": "let blitUnsafe: (\n  ~src: array('a),\n  ~srcOffset: int,\n  ~dst: array('a),\n  ~dstOffset: int,\n  ~len: int\n) => unit", "docs": "<p><strong>Unsafe</strong> blit without bounds checking</p>\n", "kind": "value", "args": [["src", "array('a)"], ["srcOffset", "int"], ["dst", "array('a)"], ["dstOffset", "int"], ["len", "int"]]}, {"path": "Belt.Array", "name": "forEachU", "type": "let forEachU: (array('a), Js.Internal.fn([ `Arity_1 of 'a134 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a134 ], unit)"]]}, {"path": "Belt.Array", "name": "forEach", "type": "let forEach: (array('a), 'a => unit) => unit", "docs": "<p><code>forEach xs f</code></p>\n<p>Call f on each element of <code>xs</code> from the beginning to end</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => unit"]]}, {"path": "Belt.Array", "name": "mapU", "type": "let mapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a133 ], 'b)"]]}, {"path": "Belt.Array", "name": "map", "type": "let map: (array('a), 'a => 'b) => array('b)", "docs": "<p><code>map xs f </code></p>\n<p>Returns: <p>a new array by calling <code>f</code> to element of <code>xs</code> from the beginning to end</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => 'b"]]}, {"path": "Belt.Array", "name": "keepU", "type": "let keepU: (array('a), Js.Internal.fn([ `Arity_1 of 'a132 ], bool)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a132 ], bool)"]]}, {"path": "Belt.Array", "name": "keep", "type": "let keep: (array('a), 'a => bool) => array('a)", "docs": "<p><code>keep xs p </code></p>\n<p>Returns: <p>a new array that keep all elements satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [|1;2;3|] (fun x -&gt; x mod  2 = 0) = [|2|]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt.Array", "name": "keepMapU", "type": "let keepMapU: (array('a), Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a131 ], option('b))"]]}, {"path": "Belt.Array", "name": "keepMap", "type": "let keepMap: (array('a), 'a => option('b)) => array('b)", "docs": "<p><code>keepMap xs p</code></p>\n<p>Returns: <p>a new array that keep all elements that return a non-None applied <code>p</code></p>\n<pre class='ml'><code class='ml'>keepMap [|1;2;3|] (fun x -&gt; if x mod 2 then Some x else None)\n= [| 2 |]\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => option('b)"]]}, {"path": "Belt.Array", "name": "forEachWithIndexU", "type": "let forEachWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a130 ], unit)"]]}, {"path": "Belt.Array", "name": "forEachWithIndex", "type": "let forEachWithIndex: (array('a), (int, 'a) => unit) => unit", "docs": "<p><code>forEachWithIndex xs f</code></p>\n<p>The same with forEach, except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => unit"]]}, {"path": "Belt.Array", "name": "mapWithIndexU", "type": "let mapWithIndexU: (array('a), Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)) => array('b)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a129 ], 'b)"]]}, {"path": "Belt.Array", "name": "mapWithIndex", "type": "let mapWithIndex: (array('a), (int, 'a) => 'b) => array('b)", "docs": "<p><code>mapWithIndex xs f </code></p>\n<p>The same with map except that <code>f</code> is supplied with one more argument: the index starting from 0</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt.Array", "name": "reduceU", "type": "let reduceU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a128 * 'b35 ], 'a)"]]}, {"path": "Belt.Array", "name": "reduce", "type": "let reduce: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduce xs init f</code></p>\n<pre class='ml'><code class='ml'>reduce [|2;3;4|] 1 (+) = 10\n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt.Array", "name": "reduceReverseU", "type": "let reduceReverseU: (array('b), 'a, Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a127 * 'b34 ], 'a)"]]}, {"path": "Belt.Array", "name": "reduceReverse", "type": "let reduceReverse: (array('b), 'a, ('a, 'b) => 'a) => 'a", "docs": "<p><code>reduceReverse xs init f</code></p>\n<pre class='ml'><code class='ml'>reduceReverse [|1;2;3;4|] 100 (-) = 90 \n</code></pre>", "kind": "value", "args": [["", "array('b)"], ["", "'a"], ["", "('a, 'b) => 'a"]]}, {"path": "Belt.Array", "name": "reduceReverse2U", "type": "let reduceReverse2U: (\n  array('a),\n  array('b),\n  'c,\n  Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)\n) => 'c", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c9 * 'a126 * 'b33 ], 'c)"]]}, {"path": "Belt.Array", "name": "reduceReverse2", "type": "let reduceReverse2: (array('a), array('b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": "<pre class='ml'><code class='ml'>reduceReverse2 [|1;2;3|] [|1;2|] 0 (fun acc x y -&gt; acc + x + y) = 6\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt.Array", "name": "someU", "type": "let someU: (array('a), Js.Internal.fn([ `Arity_1 of 'a125 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a125 ], bool)"]]}, {"path": "Belt.Array", "name": "some", "type": "let some: (array('a), 'a => bool) => bool", "docs": "<p><code>some xs p</code></p>\n<p>Returns: <p>true if one of element satifies <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt.Array", "name": "everyU", "type": "let everyU: (array('a), Js.Internal.fn([ `Arity_1 of 'a124 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a124 ], bool)"]]}, {"path": "Belt.Array", "name": "every", "type": "let every: (array('a), 'a => bool) => bool", "docs": "<p><code>every xs p</code></p>\n<p>Returns: <p>true if all elements satisfy <code>p</code></p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "'a => bool"]]}, {"path": "Belt.Array", "name": "every2U", "type": "let every2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a123 * 'b32 ], bool)"]]}, {"path": "Belt.Array", "name": "every2", "type": "let every2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>every2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>every2 [|1;2;3|] [|0;1|] (&gt;) = true;;\n(every2 [||] [|1|] (fun   x y -&gt; x &gt; y)) = true;;\n(every2 [|2;3|] [|1|] (fun   x y -&gt; x &gt; y)) = true;; \n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt.Array", "name": "some2U", "type": "let some2U: (array('a), array('b), Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a122 * 'b31 ], bool)"]]}, {"path": "Belt.Array", "name": "some2", "type": "let some2: (array('a), array('b), ('a, 'b) => bool) => bool", "docs": "<p><code>some2 xs ys p</code> only tests the length of shorter</p>\n<pre class='ml'><code class='ml'>some2 [|0;2|] [|1;0;3|] (&gt;) = true ;;\n(some2 [||] [|1|] (fun   x y -&gt; x &gt; y)) =  false;;\n(some2 [|2;3|] [|1;4|] (fun   x y -&gt; x &gt; y)) = true;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "array('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt.Array", "name": "cmpU", "type": "let cmpU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a121 * 'a121 ], int)"]]}, {"path": "Belt.Array", "name": "cmp", "type": "let cmp: (array('a), array('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp a b</code></p>\n<ul><li><p>Compared by length if <code>length a &lt;&gt; length b</code></p>\n</li><li><p>Otherwise compare one by one <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt.Array", "name": "eqU", "type": "let eqU: (array('a), array('a), Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a120 * 'a120 ], bool)"]]}, {"path": "Belt.Array", "name": "eq", "type": "let eq: (array('a), array('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq a b</code></p>\n<ul><li><p>return false if length is not the same</p>\n</li><li><p>equal one by one using <code>f ai bi</code></p>\n</li></ul>", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt.Array", "name": "truncateToLengthUnsafe", "type": "let truncateToLengthUnsafe: (array('a), int) => unit", "docs": "<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Belt", "name": "Array", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blitUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByAndShuffleU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitialized\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeUninitializedUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>range\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rangeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffleInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncateToLengthUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipByU", "docs": null, "kind": "module"}, {"path": "Belt.SortArray.Int", "name": "element", "type": "type element = int", "docs": null, "kind": "type"}, {"path": "Belt.SortArray.Int", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt.SortArray.Int", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt.SortArray.Int", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt.SortArray.Int", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt.SortArray.Int", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt.SortArray.Int", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt.SortArray.Int", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt.SortArray.Int", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt.SortArray", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt.SortArray.String", "name": "element", "type": "type element = string", "docs": null, "kind": "type"}, {"path": "Belt.SortArray.String", "name": "strictlySortedLength", "type": "let strictlySortedLength: array(element) => int", "docs": "<p>The same as strictlySortedLength except the comparator is fixed</p>\n<p>Returns: <p><code>+n</code> means increasing order <code>-n</code> means negative order</p></p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt.SortArray.String", "name": "isSorted", "type": "let isSorted: array(element) => bool", "docs": "<p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt.SortArray.String", "name": "stableSortInPlace", "type": "let stableSortInPlace: array(element) => unit", "docs": "<p>The same as stableSortInPlaceBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt.SortArray.String", "name": "stableSort", "type": "let stableSort: array(element) => array(element)", "docs": "<p>The same as stableSortBy except the comparator is fixed</p>\n", "kind": "value", "args": [["", "array(element)"]]}, {"path": "Belt.SortArray.String", "name": "binarySearch", "type": "let binarySearch: (array(element), element) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n", "kind": "value", "args": [["", "array(element)"], ["", "element"]]}, {"path": "Belt.SortArray.String", "name": "union", "type": "let union: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt.SortArray.String", "name": "intersect", "type": "let intersect: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": null, "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt.SortArray.String", "name": "diff", "type": "let diff: (array(element), int, int, array(element), int, int, array(element), int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"], ["", "int"], ["", "array(element)"], ["", "int"]]}, {"path": "Belt.SortArray", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>element", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt.SortArray", "name": "strictlySortedLengthU", "type": "let strictlySortedLengthU: (array('a), Js.Internal.fn([ `Arity_2 of 'a119 * 'a119 ], bool)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a119 * 'a119 ], bool)"]]}, {"path": "Belt.SortArray", "name": "strictlySortedLength", "type": "let strictlySortedLength: (array('a), ('a, 'a) => bool) => int", "docs": "<p><code>strictlySortedLenght xs cmp</code> return <code>+n</code> means increasing order <code>-n</code> means negative order</p>\n<pre class='ml'><code class='ml'>strictlySortedLength [|1;2;3;4;3|] (fun x y -&gt; x &lt; y) = 4;;\nstrictlySortedLength [||] (fun x y -&gt; x &lt; y) = 0;;\nstrictlySortedLength [|1|] (fun x y -&gt; x &lt; y) = 1;;\nstrictlySortedLength [|4;3;2;1|] (fun x y -&gt; x &lt; y) = -4;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt.SortArray", "name": "isSortedU", "type": "let isSortedU: (array('a), Js.Internal.fn([ `Arity_2 of 'a118 * 'a118 ], int)) => bool", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a118 * 'a118 ], int)"]]}, {"path": "Belt.SortArray", "name": "isSorted", "type": "let isSorted: (array('a), ('a, 'a) => int) => bool", "docs": "<p><code>isSorted arr cmp</code></p>\n<p>Returns: <p>true if array is increasingly sorted (equal is okay )</p>\n<pre class='ml'><code class='ml'>isSorted [|1;1;2;3;4|] (fun x y -&gt; compare x y)) = true\n</code></pre></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt.SortArray", "name": "stableSortInPlaceByU", "type": "let stableSortInPlaceByU: (array('a), Js.Internal.fn([ `Arity_2 of 'a117 * 'a117 ], int)) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a117 * 'a117 ], int)"]]}, {"path": "Belt.SortArray", "name": "stableSortInPlaceBy", "type": "let stableSortInPlaceBy: (array('a), ('a, 'a) => int) => unit", "docs": "<p><code>stableSortBy xs cmp</code></p>\n<p>Sort xs in place using comparator <code>cmp</code>, the stable means if the elements are equal, their order will be preserved</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt.SortArray", "name": "stableSortByU", "type": "let stableSortByU: (array('a), Js.Internal.fn([ `Arity_2 of 'a116 * 'a116 ], int)) => array('a)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a116 * 'a116 ], int)"]]}, {"path": "Belt.SortArray", "name": "stableSortBy", "type": "let stableSortBy: (array('a), ('a, 'a) => int) => array('a)", "docs": "<p><code>stableSort xs cmp</code></p>\n<p>Returns: <p>a fresh array</p>\n<p>The same as stableSortInPlaceBy except that <code>xs</code> is not modified</p></p>\n", "kind": "value", "args": [["", "array('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt.SortArray", "name": "binarySearchByU", "type": "let binarySearchByU: (array('a), 'a, Js.Internal.fn([ `Arity_2 of 'a115 * 'a115 ], int)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a115 * 'a115 ], int)"]]}, {"path": "Belt.SortArray", "name": "binarySearchBy", "type": "let binarySearchBy: (array('a), 'a, ('a, 'a) => int) => int", "docs": "<p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p>\n<p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p>\n<p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p>\n<pre class='ml'><code class='ml'>binarySearchBy [|1;2;3;4;33;35;36|] 33 = 4;;\nlnot (binarySearchBy [|1;3;5;7|] 4) = 2;;\n</code></pre>", "kind": "value", "args": [["", "array('a)"], ["", "'a"], ["", "('a, 'a) => int"]]}, {"path": "Belt.SortArray", "name": "unionU", "type": "let unionU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a114 * 'a114 ], int)\n) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a114 * 'a114 ], int)"]]}, {"path": "Belt.SortArray", "name": "union", "type": "let union: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p><code>union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp</code> assume <code>src</code> and <code>src2</code> is strictly sorted. for equivalent elements, it is picked from <code>src</code> also assume that <code>dst</code> is large enough to store all elements</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt.SortArray", "name": "intersectU", "type": "let intersectU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a113 * 'a113 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a113 * 'a113 ], int)"]]}, {"path": "Belt.SortArray", "name": "intersect", "type": "let intersect: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p><code>union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp</code> return the <code>offset</code> in the output array</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt.SortArray", "name": "diffU", "type": "let diffU: (\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  int,\n  array('a),\n  int,\n  Js.Internal.fn([ `Arity_2 of 'a112 * 'a112 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "Js.Internal.fn([ `Arity_2 of 'a112 * 'a112 ], int)"]]}, {"path": "Belt.SortArray", "name": "diff", "type": "let diff: (array('a), int, int, array('a), int, int, array('a), int, ('a, 'a) => int) => int", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "('a, 'a) => int"]]}, {"path": "Belt", "name": "SortArray", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearchBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearchByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diffU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersectU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSorted\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSortedU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlaceBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stableSortInPlaceByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strictlySortedLengthU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unionU\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt.MutableQueue", "name": "t", "type": "type t('a)", "docs": "<p>The type of queues containing elements of type <code>&#39;a</code>.</p>\n", "kind": "type"}, {"path": "Belt.MutableQueue", "name": "make", "type": "let make: unit => t('a)", "docs": "<p>Returns: <p>a new queue, initially empty.</p></p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Belt.MutableQueue", "name": "clear", "type": "let clear: t('a) => unit", "docs": "<p>Discard all elements from the queue.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": "<p>Returns: <p><code>true</code> if the given queue is empty, <code>false</code> otherwise.</p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "ofArray", "type": "let ofArray: array('a) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.MutableQueue", "name": "fromArray", "type": "let fromArray: array('a) => t('a)", "docs": "<p><code>fromArray a</code> is equivalent to <code>Array.forEach a (add q a)</code></p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.MutableQueue", "name": "add", "type": "let add: (t('a), 'a) => unit", "docs": "<p><code>add q x</code> adds the element <code>x</code> at the end of the queue <code>q</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a"]]}, {"path": "Belt.MutableQueue", "name": "peek", "type": "let peek: t('a) => option('a)", "docs": "<p><code>peekOpt q</code> returns the first element in queue <code>q</code>, without removing it from the queue.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "peekUndefined", "type": "let peekUndefined: t('a) => Js.undefined('a)", "docs": "<p><code>peekUndefined q</code> returns <code>undefined</code> if not found</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "peekExn", "type": "let peekExn: t('a) => 'a", "docs": "<p><code>peekUndefined q</code> returns <code>undefined</code> if not found</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "pop", "type": "let pop: t('a) => option('a)", "docs": "<p><code>pop q</code> removes and returns the first element in queue <code>q</code>.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "popUndefined", "type": "let popUndefined: t('a) => Js.undefined('a)", "docs": "<p><code>popUndefined q</code> removes and returns the first element in queue <code>q</code>. it will return undefined if it is already empty</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "popExn", "type": "let popExn: t('a) => 'a", "docs": "<p><code>popExn q</code></p>\n<p><strong>raise</strong> an exception if <code>q</code> is empty</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": "<p><code>copy q</code></p>\n<p>Returns: <p>a fresh queue</p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "size", "type": "let size: t('a) => int", "docs": "<p>Returns: <p>the number of elements in a queue.</p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a111 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a111 ], 'b)"]]}, {"path": "Belt.MutableQueue", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt.MutableQueue", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_1 of 'a110 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a110 ], unit)"]]}, {"path": "Belt.MutableQueue", "name": "forEach", "type": "let forEach: (t('a), 'a => unit) => unit", "docs": "<p><code>forEach q f</code> applies <code>f</code> in turn to all elements of <code>q</code>, from the least recently entered to the most recently entered. The queue itself is unchanged.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => unit"]]}, {"path": "Belt.MutableQueue", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'b30 * 'a109 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b30 * 'a109 ], 'b)"]]}, {"path": "Belt.MutableQueue", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b", "docs": "<p><code>reduce q accu f</code> is equivalent to <code>List.reduce l accu f</code>, where <code>l</code> is the list of <code>q</code>&#39;s elements. The queue remains unchanged.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt.MutableQueue", "name": "transfer", "type": "let transfer: (t('a), t('a)) => unit", "docs": "<p><code>transfer q1 q2</code> adds all of <code>q1</code>&#39;s elements at the end of the queue <code>q2</code>, then clears <code>q1</code>. It is equivalent to the sequence <code>forEach (fun x -&gt; add x q2) q1; clear q1</code>, but runs in constant time.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt.MutableQueue", "name": "toArray", "type": "let toArray: t('a) => array('a)", "docs": "<p>First added will be in the beginning of the array</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt", "name": "MutableQueue", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>peek\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>peekExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>peekUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>popExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>popUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>transfer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt.MutableStack", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Belt.MutableStack", "name": "make", "type": "let make: unit => t('a)", "docs": "<p>Returns: <p>a new stack, initially empty.</p></p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Belt.MutableStack", "name": "clear", "type": "let clear: t('a) => unit", "docs": "<p>Discard all elements from the stack.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableStack", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": "<p>Discard all elements from the stack.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableStack", "name": "push", "type": "let push: (t('a), 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a"]]}, {"path": "Belt.MutableStack", "name": "popUndefined", "type": "let popUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableStack", "name": "pop", "type": "let pop: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableStack", "name": "topUndefined", "type": "let topUndefined: t('a) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableStack", "name": "top", "type": "let top: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableStack", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableStack", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableStack", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_1 of 'a108 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a108 ], unit)"]]}, {"path": "Belt.MutableStack", "name": "forEach", "type": "let forEach: (t('a), 'a => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'a => unit"]]}, {"path": "Belt.MutableStack", "name": "dynamicPopIterU", "type": "let dynamicPopIterU: (t('a), Js.Internal.fn([ `Arity_1 of 'a107 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a107 ], unit)"]]}, {"path": "Belt.MutableStack", "name": "dynamicPopIter", "type": "let dynamicPopIter: (t('a), 'a => unit) => unit", "docs": "<p><code>dynamicPopIter s f </code> apply <code>f</code> to each element of <code>s</code>. The item is poped before applying <code>f</code>, <code>s</code> will be empty after this opeartion. This function is useful for worklist algorithm</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => unit"]]}, {"path": "Belt", "name": "MutableStack", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dynamicPopIter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dynamicPopIterU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>popUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>push\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>top\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>topUndefined\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt.List", "name": "t", "type": "type t('a) = list('a)", "docs": "<p><code>&#39;a t</code> is compatible with built-in <code>list</code> type</p>\n", "kind": "type"}, {"path": "Belt.List", "name": "length", "type": "let length: t('a) => int", "docs": "<p><code>length xs</code></p>\n<p>Returns: <p>the length of the list <code>xs</code></p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.List", "name": "size", "type": "let size: t('a) => int", "docs": "<p><strong>See</strong> length</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.List", "name": "head", "type": "let head: t('a) => option('a)", "docs": "<p><code>head xs</code> returns <code>None</code> if <code>xs</code> is the empty list, otherwise it returns <code>Some value</code> where <code>value</code> is the first element in the list.</p>\n<pre class='ml'><code class='ml'>head [] = None ;;\nhead [1;2;3] = Some 1 ;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.List", "name": "headExn", "type": "let headExn: t('a) => 'a", "docs": "<p><code>head xs</code> returns <code>None</code> if <code>xs</code> is the empty list, otherwise it returns <code>Some value</code> where <code>value</code> is the first element in the list.</p>\n<pre class='ml'><code class='ml'>head [] = None ;;\nhead [1;2;3] = Some 1 ;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.List", "name": "tail", "type": "let tail: t('a) => option(t('a))", "docs": "<p><code>tail xs</code> returns <code>None</code> if <code>xs</code> is empty; otherwise it returns <code>Some xs2</code> where <code>xs2</code> is everything except the first element of <code>xs</code>;</p>\n<pre class='ml'><code class='ml'>\ntail [] = None;;\ntail [1;2;3;4] = Some [2;3;4];;\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.List", "name": "tailExn", "type": "let tailExn: t('a) => t('a)", "docs": "<p><code>tailExn xs</code></p>\n<p><strong>See</strong> tail</p>\n<p><strong>raise</strong> an exception if <code>xs</code> is empty</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.List", "name": "add", "type": "let add: (t('a), 'a) => t('a)", "docs": "<p><code>add xs y</code> adds <code>y</code> to the end of list <code>xs</code></p>\n<pre class='ml'><code class='ml'>add [1] 3 = [3;1];;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a"]]}, {"path": "Belt.List", "name": "get", "type": "let get: (t('a), int) => option('a)", "docs": "<p><code>add xs y</code> adds <code>y</code> to the end of list <code>xs</code></p>\n<pre class='ml'><code class='ml'>add [1] 3 = [3;1];;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt.List", "name": "getExn", "type": "let getExn: (t('a), int) => 'a", "docs": "<p><code>getExn xs n</code></p>\n<p><strong>See</strong> get</p>\n<p><strong>raise</strong> an exception if <code>n</code> is larger than the length</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt.List", "name": "make", "type": "let make: (int, 'a) => t('a)", "docs": "<p><code>make n v</code></p>\n<ul><li><p>return a list of length <code>n</code> with each element filled with value <code>v</code></p>\n</li><li><p>return the empty list if <code>n</code> is negative</p>\n</li></ul><pre class='ml'><code class='ml'>make 3 1 =  [1;1;1]\n</code></pre>", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Belt.List", "name": "makeByU", "type": "let makeByU: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Belt.List", "name": "makeBy", "type": "let makeBy: (int, int => 'a) => t('a)", "docs": "<p><code>makeBy n f</code></p>\n<p><code>n</code> with element <code>i</code> initialized with <code>f i</code> f <code>n</code> is negative</p>\n<p><code>0;1;2;3;4</code>;; i) = <code>0;1;4;9;16</code>;;</p>\n", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Belt.List", "name": "shuffle", "type": "let shuffle: t('a) => t('a)", "docs": "<p><code>shuffle xs</code></p>\n<p>Returns: <p>a new list in random order</p></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.List", "name": "drop", "type": "let drop: (t('a), int) => option(t('a))", "docs": "<p><code>drop xs n</code></p>\n<p>return the list obtained by dropping the first <code>n</code> elements, or <code>None</code> if <code>xs</code> has fewer than <code>n</code> elements</p>\n<pre class='ml'><code class='ml'>drop [1;2;3] 2 = Some [3];;\ndrop [1;2;3] 3 = Some [];;\ndrop [1;2;3] 4 = None;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt.List", "name": "take", "type": "let take: (t('a), int) => option(t('a))", "docs": "<p><code>take xs n</code></p>\n<p>return a list with the first <code>n</code> elements from <code>xs</code>, or <code>None</code> if <code>xs</code> has fewer than <code>n</code> elements</p>\n<pre class='ml'><code class='ml'>take [1;2;3] 1 = Some [1];;\ntake [1;2;3] 2 = Some [1;2];;\ntake [1;2;3] 4 = None;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt.List", "name": "splitAt", "type": "let splitAt: (t('a), int) => option((list('a), list('a)))", "docs": "<p><code>splitAt xs n</code> split the list <code>xs</code> at position <code>n</code> return None when the length of <code>xs</code> is less than <code>n</code></p>\n<pre class='ml'><code class='ml'>splitAt [0;1;2;3;4] 2 = Some ([0;1], [2;3;4])\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Belt.List", "name": "concat", "type": "let concat: (t('a), t('a)) => t('a)", "docs": "<p><code>concat xs ys</code></p>\n<p>Returns: <p>the list obtained by adding <code>ys</code> after <code>xs</code></p>\n<pre class='ml'><code class='ml'>concat [1;2;3] [4;5] = [1;2;3;4;5]\n</code></pre></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt.List", "name": "concatMany", "type": "let concatMany: array(t('a)) => t('a)", "docs": "<p><code>concatMany a</code> return the list obtained by concatenating in order all the lists in array <code>a</code></p>\n<pre class='ml'><code class='ml'>concatMany [| [1;2;3] ; []; [3]; [4] |] = [1;2;3;3;4]\n</code></pre>", "kind": "value", "args": [["", "array(t('a))"]]}, {"path": "Belt.List", "name": "reverseConcat", "type": "let reverseConcat: (t('a), t('a)) => t('a)", "docs": "<p><code>reverseConcat xs ys</code> is equivalent to <code>concat (reverse xs) ys</code></p>\n<pre class='ml'><code class='ml'>reverseConcat [1;2] [3;4] = [2;1;3;4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt.List", "name": "flatten", "type": "let flatten: t(t('a)) => t('a)", "docs": "<p><code>flatten ls</code> return the list obtained by concatenating in order all the lists in list <code>ls</code></p>\n<pre class='ml'><code class='ml'>flatten [ [1;2;3] ; []; [3]; [4] ] = [1;2;3;3;4]\n</code></pre>", "kind": "value", "args": [["", "t(t('a))"]]}, {"path": "Belt.List", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a106 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a106 ], 'b)"]]}, {"path": "Belt.List", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>map xs f</code></p>\n<p>return the list obtained by applying <code>f</code> to each element of <code>xs</code></p>\n<pre class='ml'><code class='ml'>map [1;2] (fun x-&gt; x + 1) = [3;4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt.List", "name": "zip", "type": "let zip: (t('a), t('b)) => t(('a, 'b))", "docs": "<p><code>zip xs ys</code></p>\n<p>Returns: <p>a list of pairs from the two lists with the length of the shorter list</p>\n<pre class='ml'><code class='ml'>zip [1;2] [3;4;5] = [(1,3); (2,4)]\n</code></pre></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"]]}, {"path": "Belt.List", "name": "zipByU", "type": "let zipByU: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a105 * 'b29 ], 'c)) => t('c)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a105 * 'b29 ], 'c)"]]}, {"path": "Belt.List", "name": "zipBy", "type": "let zipBy: (t('a), t('b), ('a, 'b) => 'c) => t('c)", "docs": "failed to parse: File &quot;&quot;, line 4, characters 19-20:\nunpaired &#39;]&#39; (end of code)", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt.List", "name": "mapWithIndexU", "type": "let mapWithIndexU: (t('a), Js.Internal.fn([ `Arity_2 of int * 'a104 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a104 ], 'b)"]]}, {"path": "Belt.List", "name": "mapWithIndex", "type": "let mapWithIndex: (t('a), (int, 'a) => 'b) => t('b)", "docs": "<p><code>mapWithIndex xs f</code> applies <code>f</code> to each element of <code>xs</code>. Function <code>f</code> takes two arguments: the index starting from 0 and the element from <code>xs</code>.</p>\n<pre class='ml'><code class='ml'>mapWithIndex [1;2;3] (fun i x -&gt; i + x) =\n[0 + 1; 1 + 2; 2 + 3 ]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt.List", "name": "ofArray", "type": "let ofArray: array('a) => t('a)", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.List", "name": "fromArray", "type": "let fromArray: array('a) => t('a)", "docs": "<p><code>fromArray arr</code> converts the given array to a list</p>\n<pre class='ml'><code class='ml'>fromArray [|1;2;3|]  = [1;2;3]\n</code></pre>", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Belt.List", "name": "toArray", "type": "let toArray: t('a) => array('a)", "docs": "<p><code>toArray xs</code> converts the given list to an array</p>\n<pre class='ml'><code class='ml'>toArray [1;2;3] = [|1;2;3|]\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.List", "name": "reverse", "type": "let reverse: t('a) => t('a)", "docs": "<p><code>reverse xs</code> returns a new list whose elements are those of <code>xs</code> in reverse order.</p>\n<pre class='ml'><code class='ml'>reverse [1;2;3] = [3;2;1]\n</code></pre>", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.List", "name": "mapReverseU", "type": "let mapReverseU: (t('a), Js.Internal.fn([ `Arity_1 of 'a103 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a103 ], 'b)"]]}, {"path": "Belt.List", "name": "mapReverse", "type": "let mapReverse: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>mapReverse xs f</code></p>\n<p>x) = <code>25;16;9</code>;;</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt.List", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_1 of 'a102 ], 'b)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a102 ], 'b)"]]}, {"path": "Belt.List", "name": "forEach", "type": "let forEach: (t('a), 'a => 'b) => unit", "docs": "failed to parse: File &quot;&quot;, line 16, characters 0-0:\nend of text is not allowed in &#39;{[...]}&#39; (code block)", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt.List", "name": "forEachWithIndexU", "type": "let forEachWithIndexU: (t('a), Js.Internal.fn([ `Arity_2 of int * 'a101 ], 'b)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of int * 'a101 ], 'b)"]]}, {"path": "Belt.List", "name": "forEachWithIndex", "type": "let forEachWithIndex: (t('a), (int, 'a) => 'b) => unit", "docs": "failed to parse: File &quot;&quot;, line 14, characters 0-0:\nend of text is not allowed in &#39;{[...]}&#39; (code block)", "kind": "value", "args": [["", "t('a)"], ["", "(int, 'a) => 'b"]]}, {"path": "Belt.List", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'b28 * 'a100 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b28 * 'a100 ], 'b)"]]}, {"path": "Belt.List", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b", "docs": "<p><code>reduce xs f</code></p>\n<p>Applies <code>f</code> to each element of <code>xs</code> from beginning to end. Function <code>f</code> has two parameters: the item from the list and an \226\128\156accumulator\226\128\157, which starts with a value of <code>init</code>. <code>reduce</code> returns the final value of the accumulator.</p>\n<pre class='ml'><code class='ml'>reduce [1;2;3;4] 0 (+) = 10;;\nreduce [1;2;3;4] 10 (-) = 0;;\nreduce [1;2;3;4] [] add = [4;3;2;1];\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt.List", "name": "reduceReverseU", "type": "let reduceReverseU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'b27 * 'a99 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'b27 * 'a99 ], 'b)"]]}, {"path": "Belt.List", "name": "reduceReverse", "type": "let reduceReverse: (t('a), 'b, ('b, 'a) => 'b) => 'b", "docs": "<p><code>reduceReverse xs f</code></p>\n<p>Works like reduce, except that function <code>f</code> is applied to each item of <code>xs</code> from the last back to the first.</p>\n<pre class='ml'><code class='ml'>reduceReverse [1;2;3;4] 0 (+) = 10;;\nreduceReverse [1;2;3;4] 10 (-) = 0;;\nreduceReverse [1;2;3;4] [] add = [1;2;3;4];;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, 'a) => 'b"]]}, {"path": "Belt.List", "name": "mapReverse2U", "type": "let mapReverse2U: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a98 * 'b26 ], 'c)) => t('c)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a98 * 'b26 ], 'c)"]]}, {"path": "Belt.List", "name": "mapReverse2", "type": "let mapReverse2: (t('a), t('b), ('a, 'b) => 'c) => t('c)", "docs": "<p><code>mapReverse2 xs ys f</code></p>\n<p>equivalent to <code>reverse (zipBy xs ys f)</code></p>\n<pre class='ml'><code class='ml'>mapReverse2 [1;2;3] [1;2] (+) = [4;2]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt.List", "name": "forEach2U", "type": "let forEach2U: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a97 * 'b25 ], 'c)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a97 * 'b25 ], 'c)"]]}, {"path": "Belt.List", "name": "forEach2", "type": "let forEach2: (t('a), t('b), ('a, 'b) => 'c) => unit", "docs": "<p><code>forEach2 xs ys f</code> stop with the shorter list</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => 'c"]]}, {"path": "Belt.List", "name": "reduce2U", "type": "let reduce2U: (t('b), t('c), 'a, Js.Internal.fn([ `Arity_3 of 'a96 * 'b24 * 'c8 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "t('c)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_3 of 'a96 * 'b24 * 'c8 ], 'a)"]]}, {"path": "Belt.List", "name": "reduce2", "type": "let reduce2: (t('b), t('c), 'a, ('a, 'b, 'c) => 'a) => 'a", "docs": "<p><code>reduce2 xs ys init f </code></p>\n<p>ginning to end. Stops with the shorter list. \226\128\157 which starts with a value of <code>init</code>, returns the final value of the accumulator.</p>\n<p>x + y) = 0 + (1 * 1 + 4) + (2 * 2 + 5);; x + y) = <code>2 +5;1 + 4 </code>;; (*add appends at end *)</p>\n", "kind": "value", "args": [["", "t('b)"], ["", "t('c)"], ["", "'a"], ["", "('a, 'b, 'c) => 'a"]]}, {"path": "Belt.List", "name": "reduceReverse2U", "type": "let reduceReverse2U: (t('a), t('b), 'c, Js.Internal.fn([ `Arity_3 of 'c7 * 'a95 * 'b23 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c7 * 'a95 * 'b23 ], 'c)"]]}, {"path": "Belt.List", "name": "reduceReverse2", "type": "let reduceReverse2: (t('a), t('b), 'c, ('c, 'a, 'b) => 'c) => 'c", "docs": "<p><code>reduceReverse2 xs ys init f </code></p>\n<p>ginning. Stops with the shorter list. ch starts with a value of <code>init</code>, the final value of the accumulator.</p>\n<p>x + y) = 0 + (1 * 1 + 4) + (2 * 2 + 5);; x + y) = <code>1 + 4;2 + 5</code>;; (*add appends at end *)</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "'c"], ["", "('c, 'a, 'b) => 'c"]]}, {"path": "Belt.List", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_1 of 'a94 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a94 ], bool)"]]}, {"path": "Belt.List", "name": "every", "type": "let every: (t('a), 'a => bool) => bool", "docs": "<p><code>every xs p</code></p>\n<p>Returns: <p>true if all elements satisfy <code>p</code>, where <code>p</code> is a <em>predicate</em>: a function taking an element and returning a <code>bool</code>.</p>\n<pre class='ml'><code class='ml'>every [] (fun x -&gt; x mod 2 = 0) = true;;\nevery [2;4;6] (fun x -&gt; x mod 2 = 0 ) = true;;\nevery [1;-3;5] (fun x -&gt; x &gt; 0) = false;;\n</code></pre></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt.List", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_1 of 'a93 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a93 ], bool)"]]}, {"path": "Belt.List", "name": "some", "type": "let some: (t('a), 'a => bool) => bool", "docs": "<p><code>some xs p</code></p>\n<p>Returns: <p>true if at least one of the elements in <code>xs</code> satifies <code>p</code>, where <code>p</code> is a <em>predicate</em>: a function taking an element and returning a <code>bool</code>.</p>\n<pre class='ml'><code class='ml'>some [] (fun x -&gt; x mod 2 = 0) = false ;;\nsome [1;2;4] (fun x -&gt; x mod 2 = 0) = true;;\nsome [-1;-3;-5] (fun x -&gt; x &gt; 0) = false;;\n</code></pre></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt.List", "name": "every2U", "type": "let every2U: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a92 * 'b22 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a92 * 'b22 ], bool)"]]}, {"path": "Belt.List", "name": "every2", "type": "let every2: (t('a), t('b), ('a, 'b) => bool) => bool", "docs": "<p><code>every2 xs ys p</code> returns true if predicate <code>p xi yi</code> is true for all pairs of elements up to the shorter length (i.e. <code>min (length xs) (length ys)</code>)</p>\n<pre class='ml'><code class='ml'>every2 [1;2;3] [0;1] (&gt;) = true;;\nevery2 [] [1] (fun  x y -&gt; x &gt; y) = true;;\nevery2 [2;3] [1] (fun  x y -&gt; x &gt; y) = true;;\nevery2 [0;1] [5;0] (fun x y -&gt; x &gt; y) = false;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt.List", "name": "some2U", "type": "let some2U: (t('a), t('b), Js.Internal.fn([ `Arity_2 of 'a91 * 'b21 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a91 * 'b21 ], bool)"]]}, {"path": "Belt.List", "name": "some2", "type": "let some2: (t('a), t('b), ('a, 'b) => bool) => bool", "docs": "<p><code>some2 xs ys p</code> returns true if <code>p xi yi</code> is true for any pair of elements up to the shorter length (i.e. <code>min (length xs) (length ys)</code>)</p>\n<pre class='ml'><code class='ml'>some2 [0;2] [1;0;3] (&gt;) = true ;;\nsome2 [] [1] (fun  x y -&gt; x &gt; y) =  false;;\nsome2 [2;3] [1;4] (fun  x y -&gt; x &gt; y) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt.List", "name": "cmpByLength", "type": "let cmpByLength: (t('a), t('a)) => int", "docs": "<p><code>cmpByLength l1 l2</code></p>\n<p>Compare two lists solely by length. Returns -1 if <code>length l1</code> is less than <code>length l2</code>, 0 if <code>length l1</code> equals <code>length l2</code>, and 1 if <code>length l1</code> is greater than <code>length l2</code>.</p>\n<pre class='ml'><code class='ml'>cmpByLength [1;2] [3;4;5;6] = -1;;\ncmpByLength [1;2;3] [4;5;6] = 0;;\ncmpByLength [1;2;3;4] [5;6] = 1;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Belt.List", "name": "cmpU", "type": "let cmpU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a90 * 'a90 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a90 * 'a90 ], int)"]]}, {"path": "Belt.List", "name": "cmp", "type": "let cmp: (t('a), t('a), ('a, 'a) => int) => int", "docs": "<p>Compare elements one by one <code>f x y</code>. <code>f</code> returns</p>\n<ul><li><p>a negative number if <code>x</code> is \226\128\156less than\226\128\157 <code>y</code></p>\n</li><li><p>zero if <code>x</code> is \226\128\156equal to\226\128\157 <code>y</code></p>\n</li><li><p>a positive number if <code>x</code> is \226\128\156greater than\226\128\157 <code>y</code> The comparison returns the first non-zero result of <code>f</code>, or zero if <code>f</code> returns zero for all <code>x</code> and <code>y</code>. If all items have compared equal, but <code>xs</code> is exhausted first, return -1. (<code>xs</code> is shorter) If all items have compared equal, but <code>ys</code> is exhausted first, return 1 (<code>xs</code> is longer)</p>\n</li></ul><pre class='ml'><code class='ml'>cmp [3] [3;7] (fun a b -&gt; compare a b) = -1\ncmp [5;3] [5] (fun a b -&gt; compare a b)  = 1\ncmp [|1; 3; 5|] [|1; 4; 2|] (fun a b -&gt; compare a b) = -1;;\ncmp [|1; 3; 5|] [|1; 2; 3|] (fun a b -&gt; compare a b) = 1;;\ncmp [|1; 3; 5|] [|1; 3; 5|] (fun a b -&gt; compare a b) = 0;;\n</code></pre><p><strong>Attention</strong>: The total ordering of List is different from Array, for Array, we compare the length first and, only if the lengths are equal, elements one by one. For lists, we just compare elements one by one</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt.List", "name": "eqU", "type": "let eqU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a89 * 'a89 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a89 * 'a89 ], bool)"]]}, {"path": "Belt.List", "name": "eq", "type": "let eq: (t('a), t('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq xs ys eqElem</code> check equality of <code>xs</code> and <code>ys</code> using <code>eqElem</code> for equality on elements, where <code>eqElem</code> is a function that returns true if items <code>x</code> and <code>y</code> meet some criterion for equality, false otherwise. <code>eq</code> false if length of <code>xs</code> and <code>ys</code> are not the same.</p>\n<pre class='ml'><code class='ml'>eq [1;2;3] [1;2] (=) = false ;;\neq [1;2] [1;2] (=) = true;;\neq [1; 2; 3] [-1; -2; -3] (fun a b -&gt; abs a = abs b) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt.List", "name": "hasU", "type": "let hasU: (t('a), 'b, Js.Internal.fn([ `Arity_2 of 'a88 * 'b20 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'a88 * 'b20 ], bool)"]]}, {"path": "Belt.List", "name": "has", "type": "let has: (t('a), 'b, ('a, 'b) => bool) => bool", "docs": "<p><code>has xs eqFcn</code> returns true if the list contains at least one element for which <code>eqFcn x</code> returns true</p>\n<pre class='ml'><code class='ml'>has [1;2;3] 2 (=) = true;;\nhas [1;2;3] 4 (=) = false;;\nhas [-1;-2;-3] 2 (fun a b -&gt; abs a = abs b) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('a, 'b) => bool"]]}, {"path": "Belt.List", "name": "getByU", "type": "let getByU: (t('a), Js.Internal.fn([ `Arity_1 of 'a87 ], bool)) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a87 ], bool)"]]}, {"path": "Belt.List", "name": "getBy", "type": "let getBy: (t('a), 'a => bool) => option('a)", "docs": "<p><code>getBy xs p</code> returns <code>Some value</code> for the first value in <code>xs</code> that satisifies the predicate function <code>p</code>; returns <code>None</code> if no element satisifies the function.</p>\n<pre class='ml'><code class='ml'>getBy [1;4;3;2] (fun x -&gt; x mod 2 = 0) = Some 4\ngetBy [15;13;11] (fun x -&gt; x mod 2 = 0) = None\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt.List", "name": "keepU", "type": "let keepU: (t('a), Js.Internal.fn([ `Arity_1 of 'a86 ], bool)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a86 ], bool)"]]}, {"path": "Belt.List", "name": "keep", "type": "let keep: (t('a), 'a => bool) => t('a)", "docs": "<p><code>keep  xs p</code> returns a list of all elements in <code>xs</code> which satisfy the predicate function <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [1;2;3;4] (fun x -&gt; x mod 2 = 0) =\n[2;4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt.List", "name": "keepMapU", "type": "let keepMapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a85 ], option('b))) => t('b)", "docs": "<p><code>keep  xs p</code> returns a list of all elements in <code>xs</code> which satisfy the predicate function <code>p</code></p>\n<pre class='ml'><code class='ml'>keep [1;2;3;4] (fun x -&gt; x mod 2 = 0) =\n[2;4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a85 ], option('b))"]]}, {"path": "Belt.List", "name": "keepMap", "type": "let keepMap: (t('a), 'a => option('b)) => t('b)", "docs": "<p><code>keepMap xs f</code> applies <code>f</code> to each element of <code>xs</code>. If <code>f xi</code> returns <code>Some value</code>, then <code>value</code> is kept in the resulting list; if <code>f xi</code> returns <code>None</code>, the element is not retained in the result.</p>\n<pre class='ml'><code class='ml'>keepMap [1;2;3;4] (fun x -&gt; if x mod 2 = 0 then Some (-x ) else None)\n=\n[-2;-4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => option('b)"]]}, {"path": "Belt.List", "name": "partitionU", "type": "let partitionU: (t('a), Js.Internal.fn([ `Arity_1 of 'a84 ], bool)) => (t('a), t('a))", "docs": "<p><code>keepMap xs f</code> applies <code>f</code> to each element of <code>xs</code>. If <code>f xi</code> returns <code>Some value</code>, then <code>value</code> is kept in the resulting list; if <code>f xi</code> returns <code>None</code>, the element is not retained in the result.</p>\n<pre class='ml'><code class='ml'>keepMap [1;2;3;4] (fun x -&gt; if x mod 2 = 0 then Some (-x ) else None)\n=\n[-2;-4]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a84 ], bool)"]]}, {"path": "Belt.List", "name": "partition", "type": "let partition: (t('a), 'a => bool) => (t('a), t('a))", "docs": "<p><code>partition xs p</code> creates a pair of lists; the first list consists of all elements of <code>xs</code> that satisfy the predicate function <code>p</code>; the second list consists of all elements of <code>xs</code> that do not satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>partition [1;2;3;4] (fun x -&gt; x mod 2 = 0) =\n([2;4], [1;3])\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "'a => bool"]]}, {"path": "Belt.List", "name": "unzip", "type": "let unzip: t(('a, 'b)) => (t('a), t('b))", "docs": "<p><code>partition xs p</code> creates a pair of lists; the first list consists of all elements of <code>xs</code> that satisfy the predicate function <code>p</code>; the second list consists of all elements of <code>xs</code> that do not satisfy <code>p</code></p>\n<pre class='ml'><code class='ml'>partition [1;2;3;4] (fun x -&gt; x mod 2 = 0) =\n([2;4], [1;3])\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'b))"]]}, {"path": "Belt.List", "name": "getAssocU", "type": "let getAssocU: (t(('a, 'c)), 'b, Js.Internal.fn([ `Arity_2 of 'a83 * 'b19 ], bool)) => option('c)", "docs": "<p><code>unzip xs</code> takes a list of pairs and creates a pair of lists. The first list contains all the first items of the pairs; the second list contains all the second items.</p>\n<pre class='ml'><code class='ml'>unzip [(1,2) ; (3,4)] = ([1;3], [2;4]);;\nunzip [(1,2) ; (3,4) ; (5,6) ; (7,8)] = ([1;3;5;7], [2;4;6;8]);;\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'a83 * 'b19 ], bool)"]]}, {"path": "Belt.List", "name": "getAssoc", "type": "let getAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => option('c)", "docs": "<p><code>getAssoc xs k eq</code></p>\n<p>return the second element of a pair in <code>xs</code> where the first element equals <code>x</code> as per the predicate function <code>eq</code>, or <code>None</code> if not found</p>\n<pre class='ml'><code class='ml'>getAssoc [ 1, &quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot;] 2 (=) = Some &quot;b&quot;\ngetAssoc [9, &quot;morning&quot;; 15, &quot;afternoon&quot;; 22, &quot;night&quot;] 3 (fun a b -&gt; a mod 12 = b mod 12) = Some &quot;afternoon&quot;\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "('a, 'b) => bool"]]}, {"path": "Belt.List", "name": "hasAssocU", "type": "let hasAssocU: (t(('a, 'c)), 'b, Js.Internal.fn([ `Arity_2 of 'a82 * 'b18 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'a82 * 'b18 ], bool)"]]}, {"path": "Belt.List", "name": "hasAssoc", "type": "let hasAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => bool", "docs": "<p><code>hasAssoc xs k eq</code> return true if there is a pair in <code>xs</code> where the first element equals <code>k</code> as per the predicate funtion <code>eq</code></p>\n<pre class='ml'><code class='ml'>hasAssoc [1, &quot;a&quot;; 2, &quot;b&quot;; 3,&quot;c&quot;] 1 (=) = true;;\nhasAssoc [9, &quot;morning&quot;; 15, &quot;afternoon&quot;; 22, &quot;night&quot;] 3 (fun a b -&gt; a mod 12 = b mod 12) = true;;\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "('a, 'b) => bool"]]}, {"path": "Belt.List", "name": "removeAssocU", "type": "let removeAssocU: (t(('a, 'c)), 'b, Js.Internal.fn([ `Arity_2 of 'a81 * 'b17 ], bool)) => t(\n  ('a, 'c)\n)", "docs": null, "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_2 of 'a81 * 'b17 ], bool)"]]}, {"path": "Belt.List", "name": "removeAssoc", "type": "let removeAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => t(('a, 'c))", "docs": "<p><code>removeAssoc xs k eq</code> Return a list after removing the first pair whose first value is <code>k</code> per the equality predicate <code>eq</code>; if not found, return a new list identical to <code>xs</code>.</p>\n<pre class='ml'><code class='ml'>removeAssoc [1,&quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot; ] 1 (=) =\n  [2, &quot;b&quot;; 3, &quot;c&quot;]\nremoveAssoc [1,&quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot; ] 99 (=) =\n  [1, &quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot;]\n</code></pre>", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'b"], ["", "('a, 'b) => bool"]]}, {"path": "Belt.List", "name": "setAssocU", "type": "let setAssocU: (t(('a, 'c)), 'a, 'c, Js.Internal.fn([ `Arity_2 of 'a80 * 'a80 ], bool)) => t(\n  ('a, 'c)\n)", "docs": null, "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'a"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'a80 * 'a80 ], bool)"]]}, {"path": "Belt.List", "name": "setAssoc", "type": "let setAssoc: (t(('a, 'c)), 'a, 'c, ('a, 'a) => bool) => t(('a, 'c))", "docs": "<p><code>setAssoc xs k v eq</code> if <code>k</code> exists in <code>xs</code> by satisfying the <code>eq</code> predicate, return a new list with the key and value replaced by the new <code>k</code> and <code>v</code>; otherwise, return a new list with the pair <code>k, v</code> added to the head of <code>xs</code>.</p>\n<pre class='ml'><code class='ml'>setAssoc [1,&quot;a&quot;; 2, &quot;b&quot;; 3, &quot;c&quot;] 2 &quot;x&quot; (=) =\n[1,&quot;a&quot;; 2, &quot;x&quot;; 3,&quot;c&quot;] ;; \n\nsetAssoc [1,&quot;a&quot;; 3, &quot;c&quot;] 2 &quot;b&quot; (=) = \n[2,&quot;b&quot;; 1,&quot;a&quot;; 3, &quot;c&quot;]\n\nsetAssoc [9, &quot;morning&quot;; 3, &quot;morning?!&quot;; 22, &quot;night&quot;] 15 &quot;afternoon&quot;\n  (fun a b -&gt; a mod 12 = b mod 12) = [9, &quot;morning&quot;; 15, &quot;afternoon&quot;; 22, &quot;night&quot;]\n</code></pre><p>Note carefully the last example! Since <code>15 mod 12</code> equals <code>3 mod 12</code>, <em>both</em> the key and value are replaced in the list.</p>\n", "kind": "value", "args": [["", "t(('a, 'c))"], ["", "'a"], ["", "'c"], ["", "('a, 'a) => bool"]]}, {"path": "Belt.List", "name": "sortU", "type": "let sortU: (t('a), Js.Internal.fn([ `Arity_2 of 'a79 * 'a79 ], int)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a79 * 'a79 ], int)"]]}, {"path": "Belt.List", "name": "sort", "type": "let sort: (t('a), ('a, 'a) => int) => t('a)", "docs": "<p><code>sort xs</code> Returns a sorted list.</p>\n<pre class='ml'><code class='ml'>sort [5; 4; 9; 3; 7] (fun a b -&gt; a - b) = [3; 4; 5; 7; 9]\n</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt", "name": "List", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpByLength\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>drop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatten\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getAssoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getAssocU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hasAssoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hasAssocU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hasU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>head\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>headExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithIndexU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverse2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceReverseU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeAssoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeAssocU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseConcat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setAssoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setAssocU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shuffle\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some2U\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sortU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitAt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tail\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tailExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>take\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unzip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zip\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zipByU\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt.Range", "name": "forEachU", "type": "let forEachU: (int, int, Js.Internal.fn([ `Arity_1 of int ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], unit)"]]}, {"path": "Belt.Range", "name": "forEach", "type": "let forEach: (int, int, int => unit) => unit", "docs": "<p><code>forEach start finish action</code></p>\n<p>equivalent to <code>Belt.Array.(forEach (range start finish) action)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "int => unit"]]}, {"path": "Belt.Range", "name": "everyU", "type": "let everyU: (int, int, Js.Internal.fn([ `Arity_1 of int ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], bool)"]]}, {"path": "Belt.Range", "name": "every", "type": "let every: (int, int, int => bool) => bool", "docs": "<p><code>every start finish p</code></p>\n<p>equivalent to <code>Belt.Array.(every (range start finish) p )</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "int => bool"]]}, {"path": "Belt.Range", "name": "everyByU", "type": "let everyByU: (int, int, ~step: int, Js.Internal.fn([ `Arity_1 of int ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], bool)"]]}, {"path": "Belt.Range", "name": "everyBy", "type": "let everyBy: (int, int, ~step: int, int => bool) => bool", "docs": "<p><code>everyBy start finish ~step p</code></p>\n<p><strong>See</strong> rangeBy</p>\n<p>equivalent to <code>Belt.Array.(every (rangeBy start finish ~step) p)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"], ["", "int => bool"]]}, {"path": "Belt.Range", "name": "someU", "type": "let someU: (int, int, Js.Internal.fn([ `Arity_1 of int ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], bool)"]]}, {"path": "Belt.Range", "name": "some", "type": "let some: (int, int, int => bool) => bool", "docs": "<p><code>some start finish p</code></p>\n<p>equivalent to <code>Belt.Array.(some (range start finish) p)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "int => bool"]]}, {"path": "Belt.Range", "name": "someByU", "type": "let someByU: (int, int, ~step: int, Js.Internal.fn([ `Arity_1 of int ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], bool)"]]}, {"path": "Belt.Range", "name": "someBy", "type": "let someBy: (int, int, ~step: int, int => bool) => bool", "docs": "<p><code>someBy start finish ~step  p</code></p>\n<p><strong>See</strong> rangeBy</p>\n<p>equivalent to <code>Belt.Array.(some (rangeBy start finish ~step) p)</code></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["step", "int"], ["", "int => bool"]]}, {"path": "Belt", "name": "Range", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someByU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU", "docs": null, "kind": "module"}, {"path": "Belt.Set.Int", "name": "value", "type": "type value = int", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt.Set.Int", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt.Set.Int", "name": "empty", "type": "let empty: t", "docs": null, "kind": "value"}, {"path": "Belt.Set.Int", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.Set.Int", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.Set.Int", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.Set.Int", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.Set.Int", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.Int", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.Int", "name": "add", "type": "let add: (t, value) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.Int", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt.Set.Int", "name": "remove", "type": "let remove: (t, value) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.Int", "name": "removeMany", "type": "let removeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt.Set.Int", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.Int", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.Int", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.Int", "name": "subset", "type": "let subset: (t, t) => bool", "docs": "<p><code>subset s1 s2</code> tests whether the set <code>s1</code> is a subset of the set <code>s2</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.Int", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.Int", "name": "eq", "type": "let eq: (t, t) => bool", "docs": "<p><code>eq s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> are equal, that is, contain equal elements.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.Int", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt.Set.Int", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt.Set.Int", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a78 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a78 * value ], 'a)"]]}, {"path": "Belt.Set.Int", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt.Set.Int", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.Set.Int", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.Set.Int", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.Set.Int", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.Set.Int", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.Set.Int", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep p s</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.Set.Int", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.Set.Int", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.Set.Int", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.Int", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.Int", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.Int", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.Int", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.Int", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.Int", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.Int", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.Int", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.Int", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.Int", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split x s</code> returns a triple <code>(l, present, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": "<p>Specalized when value type is <code>int</code>, more efficient than the gerneic type, its compare behavior is fixed using the built-in comparison</p>\n", "kind": "module"}, {"path": "Belt.Set.String", "name": "value", "type": "type value = string", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt.Set.String", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt.Set.String", "name": "empty", "type": "let empty: t", "docs": null, "kind": "value"}, {"path": "Belt.Set.String", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.Set.String", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.Set.String", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.Set.String", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.Set.String", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.String", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.String", "name": "add", "type": "let add: (t, value) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.String", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt.Set.String", "name": "remove", "type": "let remove: (t, value) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.String", "name": "removeMany", "type": "let removeMany: (t, array(value)) => t", "docs": "<p>If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt.Set.String", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.String", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.String", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.String", "name": "subset", "type": "let subset: (t, t) => bool", "docs": "<p><code>subset s1 s2</code> tests whether the set <code>s1</code> is a subset of the set <code>s2</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.String", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.String", "name": "eq", "type": "let eq: (t, t) => bool", "docs": "<p><code>eq s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> are equal, that is, contain equal elements.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.Set.String", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt.Set.String", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt.Set.String", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a77 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a77 * value ], 'a)"]]}, {"path": "Belt.Set.String", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt.Set.String", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.Set.String", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.Set.String", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.Set.String", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.Set.String", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.Set.String", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep p s</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.Set.String", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.Set.String", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.Set.String", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.String", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.String", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.String", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.String", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.String", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.String", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set.String", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.String", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.String", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.String", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split x s</code> returns a triple <code>(l, present, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.Set.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.Set", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": "<p>Specalized when value type is <code>string</code>, more efficient than the gerneic type, its compare behavior is fixed using the built-in comparison</p>\n", "kind": "module"}, {"path": "Belt.Set.Dict", "name": "t", "type": "type t('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.Set.Dict", "name": "cmp", "type": "type cmp('key, 'id) = Belt_Id.cmp('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.Set.Dict", "name": "empty", "type": "let empty: t('value, 'id)", "docs": null, "kind": "value"}, {"path": "Belt.Set.Dict", "name": "ofArray", "type": "let ofArray: (array('k), ~cmp: cmp('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array('value) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"]]}, {"path": "Belt.Set.Dict", "name": "fromArray", "type": "let fromArray: (array('k), ~cmp: cmp('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array('value) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"]]}, {"path": "Belt.Set.Dict", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt.Set.Dict", "name": "has", "type": "let has: (t('k, 'id), 'k, ~cmp: cmp('k, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "add", "type": "let add: (t('k, 'id), 'k, ~cmp: cmp('k, 'id)) => t('k, 'id)", "docs": "<p><code>add s x</code> If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n", "kind": "value", "args": [["", "t('k, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "mergeMany", "type": "let mergeMany: (t('value, 'id), array('value), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "remove", "type": "let remove: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": "<p><code>remove m x</code> If <code>x</code> was not in <code>m</code>, <code>m</code> is returned reference unchanged.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "removeMany", "type": "let removeMany: (t('value, 'id), array('value), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "union", "type": "let union: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "intersect", "type": "let intersect: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "diff", "type": "let diff: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "subset", "type": "let subset: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "cmp", "type": "let cmp: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "eq", "type": "let eq: (t('value, 'id), t('value, 'id), ~cmp: cmp('value, 'id)) => bool", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "forEachU", "type": "let forEachU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value19 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value19 ], unit)"]]}, {"path": "Belt.Set.Dict", "name": "forEach", "type": "let forEach: (t('value, 'id), 'value => unit) => unit", "docs": "<p><code>forEach s f</code> applies <code>f</code> in turn to all elements of <code>s</code>. In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => unit"]]}, {"path": "Belt.Set.Dict", "name": "reduceU", "type": "let reduceU: (t('value, 'id), 'a, Js.Internal.fn([ `Arity_2 of 'a76 * 'value18 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a76 * 'value18 ], 'a)"]]}, {"path": "Belt.Set.Dict", "name": "reduce", "type": "let reduce: (t('value, 'id), 'a, ('a, 'value) => 'a) => 'a", "docs": "<p>In increasing order.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "('a, 'value) => 'a"]]}, {"path": "Belt.Set.Dict", "name": "everyU", "type": "let everyU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value17 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value17 ], bool)"]]}, {"path": "Belt.Set.Dict", "name": "every", "type": "let every: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.Set.Dict", "name": "someU", "type": "let someU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value16 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value16 ], bool)"]]}, {"path": "Belt.Set.Dict", "name": "some", "type": "let some: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.Set.Dict", "name": "keepU", "type": "let keepU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value15 ], bool)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value15 ], bool)"]]}, {"path": "Belt.Set.Dict", "name": "keep", "type": "let keep: (t('value, 'id), 'value => bool) => t('value, 'id)", "docs": "<p><code>keep m p</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.Set.Dict", "name": "partitionU", "type": "let partitionU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value14 ], bool)) => (\n  t('value, 'id),\n  t('value, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value14 ], bool)"]]}, {"path": "Belt.Set.Dict", "name": "partition", "type": "let partition: (t('value, 'id), 'value => bool) => (t('value, 'id), t('value, 'id))", "docs": "<p><code>partition m p</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.Set.Dict", "name": "size", "type": "let size: t('value, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "toList", "type": "let toList: t('value, 'id) => list('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "toArray", "type": "let toArray: t('value, 'id) => array('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "minimum", "type": "let minimum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "minUndefined", "type": "let minUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "maximum", "type": "let maximum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "maxUndefined", "type": "let maxUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "get", "type": "let get: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "getUndefined", "type": "let getUndefined: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "getExn", "type": "let getExn: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => 'value", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "split", "type": "let split: (t('value, 'id), 'value, ~cmp: cmp('value, 'id)) => (\n  (t('value, 'id), t('value, 'id)),\n  bool\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"], ["cmp", "cmp('value, 'id)"]]}, {"path": "Belt.Set.Dict", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt.Set", "name": "Dict", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>This module seprate identity from data, it is a bit more verbsoe but slightly more efficient due to the fact that there is no need to pack identity and data back after each operation</p>\n", "kind": "module"}, {"path": "Belt.Set", "name": "t", "type": "type t('value, 'identity)", "docs": "<p><code>(&#39;value, &#39;identity) t</code></p>\n<p><code>&#39;value</code> is the element type</p>\n<p><code>&#39;identity</code> the identity of the collection</p>\n", "kind": "type"}, {"path": "Belt.Set", "name": "id", "type": "type id('value, 'id) = Belt_Id.comparable('value, 'id)", "docs": "<p>The identity needed for making a set from scratch</p>\n", "kind": "type"}, {"path": "Belt.Set", "name": "make", "type": "let make: (~id: id('value, 'id)) => t('value, 'id)", "docs": "<p><code>make ~id</code> creates a new set by taking in the comparator</p>\n<pre class='ml'><code class='ml'>let s = make ~id:(module IntCmp)\n</code></pre>", "kind": "value", "args": [["id", "id('value, 'id)"]]}, {"path": "Belt.Set", "name": "ofArray", "type": "let ofArray: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt.Set", "name": "fromArray", "type": "let fromArray: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": "<p><code>fromArray xs ~id</code></p>\n<pre class='ml'><code class='ml'>toArray (fromArray [1;3;2;4] (module IntCmp)) = [1;2;3;4]\n</code></pre>", "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt.Set", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt.Set", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": "<p><code>fromSortedArrayUnsafe xs ~id</code></p>\n<p>The same as fromArray except it is after assuming the input array <code>x</code> is already sorted</p>\n<p><strong>Unsafe</strong></p>\n", "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt.Set", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": "<pre class='ml'><code class='ml'>isEmpty (fromArray [||] ~id:(module IntCmp)) = true;;\nisEmpty (fromArray [|1|] ~id:(module IntCmp)) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt.Set", "name": "has", "type": "let has: (t('value, 'id), 'value) => bool", "docs": "<pre class='ml'><code class='ml'>isEmpty (fromArray [||] ~id:(module IntCmp)) = true;;\nisEmpty (fromArray [|1|] ~id:(module IntCmp)) = true;;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.Set", "name": "add", "type": "let add: (t('value, 'id), 'value) => t('value, 'id)", "docs": "<p><code>add s x</code> If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p>\n<pre class='ml'><code class='ml'>let s0 = make ~id:(module IntCmp);;\nlet s1 = add s0 1 ;;\nlet s2 = add s1 2;;\nlet s3 = add s2 2;;\ntoArray s0 = [||];;\ntoArray s1 = [|1|];;\ntoArray s2 = [|1;2|];;\ntoArray s3 = [|1;2|];;\ns2 == s3;;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.Set", "name": "mergeMany", "type": "let mergeMany: (t('value, 'id), array('value)) => t('value, 'id)", "docs": "<p><code>mergeMany s xs</code></p>\n<p>Adding each of <code>xs</code> to <code>s</code>, note unlike add, the reference of return value might be changed even if all values in <code>xs</code> exist <code>s</code></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"]]}, {"path": "Belt.Set", "name": "remove", "type": "let remove: (t('value, 'id), 'value) => t('value, 'id)", "docs": "<p><code>mergeMany s xs</code></p>\n<p>Adding each of <code>xs</code> to <code>s</code>, note unlike add, the reference of return value might be changed even if all values in <code>xs</code> exist <code>s</code></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.Set", "name": "removeMany", "type": "let removeMany: (t('value, 'id), array('value)) => t('value, 'id)", "docs": "<p><code>removeMany s xs</code></p>\n<p>Removing each of <code>xs</code> to <code>s</code>, note unlike remove, the reference of return value might be changed even if none in <code>xs</code> exists <code>s</code></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"]]}, {"path": "Belt.Set", "name": "union", "type": "let union: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": "<p><code>union s0 s1</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet s1 = fromArray ~id:(module IntCmp) [|5;2;3;1;5;4;|];;\ntoArray (union s0 s1) =  [|1;2;3;4;5;6|]\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "intersect", "type": "let intersect: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": "<p><code>intersect s0 s1</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet s1 = fromArray ~id:(module IntCmp) [|5;2;3;1;5;4;|];;\ntoArray (intersect s0 s1) =  [|2;3;5|]\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "diff", "type": "let diff: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": "<p><code>intersect s0 s1</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet s1 = fromArray ~id:(module IntCmp) [|5;2;3;1;5;4;|];;\ntoArray (intersect s0 s1) =  [|2;3;5|]\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "subset", "type": "let subset: (t('value, 'id), t('value, 'id)) => bool", "docs": "<p><code>subset s0 s1</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet s1 = fromArray ~id:(module IntCmp) [|5;2;3;1;5;4;|];;\nlet s2 = intersect s0 s1;;\nsubset s2 s0 = true;;\nsubset s2 s1 = true;;\nsubset s1 s0 = false;;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "cmp", "type": "let cmp: (t('value, 'id), t('value, 'id)) => int", "docs": "<p>Total ordering between sets. Can be used as the ordering function for doing sets of sets. It compare <code>size</code> first and then iterate over each element following the order of elements</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "eq", "type": "let eq: (t('value, 'id), t('value, 'id)) => bool", "docs": "<p><code>eq s0 s1</code></p>\n<p>Returns: <p>true if <code>toArray s0 = toArray s1</code></p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "forEachU", "type": "let forEachU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value13 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value13 ], unit)"]]}, {"path": "Belt.Set", "name": "forEach", "type": "let forEach: (t('value, 'id), 'value => unit) => unit", "docs": "<p><code>forEach s f</code> applies <code>f</code> in turn to all elements of <code>s</code>. In increasing order</p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nlet acc = ref [] ;;\nforEach s0 (fun x -&gt; acc := x !acc);;\n!acc = [6;5;3;2];;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => unit"]]}, {"path": "Belt.Set", "name": "reduceU", "type": "let reduceU: (t('value, 'id), 'a, Js.Internal.fn([ `Arity_2 of 'a75 * 'value12 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a75 * 'value12 ], 'a)"]]}, {"path": "Belt.Set", "name": "reduce", "type": "let reduce: (t('value, 'id), 'a, ('a, 'value) => 'a) => 'a", "docs": "<p>In increasing order.</p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nreduce s0 [] Bs.List.add = [6;5;3;2];;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "('a, 'value) => 'a"]]}, {"path": "Belt.Set", "name": "everyU", "type": "let everyU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value11 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value11 ], bool)"]]}, {"path": "Belt.Set", "name": "every", "type": "let every: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.Set", "name": "someU", "type": "let someU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value10 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value10 ], bool)"]]}, {"path": "Belt.Set", "name": "some", "type": "let some: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.Set", "name": "keepU", "type": "let keepU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value9 ], bool)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value9 ], bool)"]]}, {"path": "Belt.Set", "name": "keep", "type": "let keep: (t('value, 'id), 'value => bool) => t('value, 'id)", "docs": "<p><code>keep m p</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.Set", "name": "partitionU", "type": "let partitionU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value8 ], bool)) => (\n  t('value, 'id),\n  t('value, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value8 ], bool)"]]}, {"path": "Belt.Set", "name": "partition", "type": "let partition: (t('value, 'id), 'value => bool) => (t('value, 'id), t('value, 'id))", "docs": "<p><code>partition m p</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.Set", "name": "size", "type": "let size: t('value, 'id) => int", "docs": "<p><code>size s</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\nsize s0 = 4;;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "toArray", "type": "let toArray: t('value, 'id) => array('value)", "docs": "<p><code>toArray s0</code></p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|5;2;3;5;6|]];;\ntoArray s0 = [|2;3;5;6|];;\n</code></pre>", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "toList", "type": "let toList: t('value, 'id) => list('value)", "docs": "<p>In increasing order</p>\n<p><strong>See</strong> toArray</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "minimum", "type": "let minimum: t('value, 'id) => option('value)", "docs": "<p><code>minimum s0</code></p>\n<p>Returns: <p>the minimum element of the collection, <code>None</code> if it is empty</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "minUndefined", "type": "let minUndefined: t('value, 'id) => Js.undefined('value)", "docs": "<p><code>minUndefined s0</code></p>\n<p>Returns: <p>the minimum element of the collection, <code>undefined</code> if it is empty</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "maximum", "type": "let maximum: t('value, 'id) => option('value)", "docs": "<p><code>maximum s0</code></p>\n<p>Returns: <p>the maximum element of the collection, <code>None</code> if it is empty</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "maxUndefined", "type": "let maxUndefined: t('value, 'id) => Js.undefined('value)", "docs": "<p><code>maximum s0</code></p>\n<p>Returns: <p>the maximum element of the collection, <code>None</code> if it is empty</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "get", "type": "let get: (t('value, 'id), 'value) => option('value)", "docs": "<p><code>get s0 k</code></p>\n<p>Returns: <p>the reference of the value <code>k&#39;</code> which is equivalent to <code>k</code> using the comparator specifiecd by this collection, <code>None</code> if it does not exist</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.Set", "name": "getUndefined", "type": "let getUndefined: (t('value, 'id), 'value) => Js.undefined('value)", "docs": "<p><strong>See</strong> get</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.Set", "name": "getExn", "type": "let getExn: (t('value, 'id), 'value) => 'value", "docs": "<p><strong>See</strong> get</p>\n<p><strong>raise</strong> if not exist</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.Set", "name": "split", "type": "let split: (t('value, 'id), 'value) => ((t('value, 'id), t('value, 'id)), bool)", "docs": "<p><code>split set ele</code></p>\n<p>Returns: <p>a tuple <code>((smaller, larger), present)</code>, <code>present</code> is true when <code>ele</code> exist in <code>set</code></p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.Set", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt.Set", "name": "getData", "type": "let getData: t('value, 'id) => Belt_SetDict.t('value, 'id)", "docs": "<p><code>getData s0</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the raw data (detached from comparator), but its type is still manifested, so that user can pass identity directly without boxing</p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "getId", "type": "let getId: t('value, 'id) => id('value, 'id)", "docs": "<p><code>getId s0</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the identity of <code>s0</code></p></p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.Set", "name": "packIdData", "type": "let packIdData: (~id: id('value, 'id), ~data: Belt_SetDict.t('value, 'id)) => t('value, 'id)", "docs": "<p><code>packIdData ~id ~data</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the packed collection</p></p>\n", "kind": "value", "args": [["id", "id('value, 'id)"], ["data", "Belt_SetDict.t('value, 'id)"]]}, {"path": "Belt", "name": "Set", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getData\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getId\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>packIdData\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Dict\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt.Map.Int", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt.Map.Int", "name": "t", "type": "type t('value)", "docs": "<p>The type of maps from type <code>key</code> to type <code>&#39;value</code>.</p>\n", "kind": "type"}, {"path": "Belt.Map.Int", "name": "empty", "type": "let empty: t('v)", "docs": null, "kind": "value"}, {"path": "Belt.Map.Int", "name": "isEmpty", "type": "let isEmpty: t('v) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "has", "type": "let has: (t('v), key) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.Int", "name": "cmpU", "type": "let cmpU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v38 * 'v38 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v38 * 'v38 ], int)"]]}, {"path": "Belt.Map.Int", "name": "cmp", "type": "let cmp: (t('v), t('v), ('v, 'v) => int) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => int"]]}, {"path": "Belt.Map.Int", "name": "eqU", "type": "let eqU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v37 * 'v37 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v37 * 'v37 ], bool)"]]}, {"path": "Belt.Map.Int", "name": "eq", "type": "let eq: (t('v), t('v), ('v, 'v) => bool) => bool", "docs": "<p><code>equal m1 m2 cmp</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => bool"]]}, {"path": "Belt.Map.Int", "name": "forEachU", "type": "let forEachU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v36 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v36 ], unit)"]]}, {"path": "Belt.Map.Int", "name": "forEach", "type": "let forEach: (t('v), (key, 'v) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => unit"]]}, {"path": "Belt.Map.Int", "name": "reduceU", "type": "let reduceU: (t('v), 'v2, Js.Internal.fn([ `Arity_3 of 'v211 * key * 'v35 ], 'v2)) => 'v2", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "Js.Internal.fn([ `Arity_3 of 'v211 * key * 'v35 ], 'v2)"]]}, {"path": "Belt.Map.Int", "name": "reduce", "type": "let reduce: (t('v), 'v2, ('v2, key, 'v) => 'v2) => 'v2", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "('v2, key, 'v) => 'v2"]]}, {"path": "Belt.Map.Int", "name": "everyU", "type": "let everyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v34 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v34 ], bool)"]]}, {"path": "Belt.Map.Int", "name": "every", "type": "let every: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt.Map.Int", "name": "someU", "type": "let someU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v33 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v33 ], bool)"]]}, {"path": "Belt.Map.Int", "name": "some", "type": "let some: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt.Map.Int", "name": "size", "type": "let size: t('v) => int", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "toList", "type": "let toList: t('v) => list((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "toArray", "type": "let toArray: t('v) => array((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "ofArray", "type": "let ofArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt.Map.Int", "name": "fromArray", "type": "let fromArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt.Map.Int", "name": "keysToArray", "type": "let keysToArray: t('v) => array(key)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "valuesToArray", "type": "let valuesToArray: t('v) => array('v)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.Int", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.Int", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.Int", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.Int", "name": "minimum", "type": "let minimum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "minUndefined", "type": "let minUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "maximum", "type": "let maximum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "maxUndefined", "type": "let maxUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "get", "type": "let get: (t('v), key) => option('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.Int", "name": "getUndefined", "type": "let getUndefined: (t('v), key) => Js.undefined('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.Int", "name": "getWithDefault", "type": "let getWithDefault: (t('v), key, 'v) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt.Map.Int", "name": "getExn", "type": "let getExn: (t('v), key) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.Int", "name": "remove", "type": "let remove: (t('v), key) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.Int", "name": "removeMany", "type": "let removeMany: (t('v), array(key)) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "array(key)"]]}, {"path": "Belt.Map.Int", "name": "set", "type": "let set: (t('v), key, 'v) => t('v)", "docs": "<p><code>add m x y</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt.Map.Int", "name": "updateU", "type": "let updateU: (t('v), key, Js.Internal.fn([ `Arity_1 of 'v32 option ], option('v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'v32 option ], option('v))"]]}, {"path": "Belt.Map.Int", "name": "update", "type": "let update: (t('v), key, option('v) => option('v)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "option('v) => option('v)"]]}, {"path": "Belt.Map.Int", "name": "mergeArray", "type": "let mergeArray: (t('v), array((key, 'v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "array((key, 'v))"]]}, {"path": "Belt.Map.Int", "name": "mergeU", "type": "let mergeU: (\n  t('v),\n  t('v2),\n  Js.Internal.fn([ `Arity_3 of key * 'v31 option * 'v210 option ], option('c))\n) => t('c)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "Js.Internal.fn([ `Arity_3 of key * 'v31 option * 'v210 option ], option('c))"]]}, {"path": "Belt.Map.Int", "name": "merge", "type": "let merge: (t('v), t('v2), (key, option('v), option('v2)) => option('c)) => t('c)", "docs": "<p><code>merge m1 m2 f</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "(key, option('v), option('v2)) => option('c)"]]}, {"path": "Belt.Map.Int", "name": "keepU", "type": "let keepU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v30 ], bool)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v30 ], bool)"]]}, {"path": "Belt.Map.Int", "name": "keep", "type": "let keep: (t('v), (key, 'v) => bool) => t('v)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt.Map.Int", "name": "partitionU", "type": "let partitionU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v29 ], bool)) => (t('v), t('v))", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v29 ], bool)"]]}, {"path": "Belt.Map.Int", "name": "partition", "type": "let partition: (t('v), (key, 'v) => bool) => (t('v), t('v))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt.Map.Int", "name": "split", "type": "let split: (key, t('v)) => (t('v), option('v), t('v))", "docs": "<p><code>split x m</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p>\n", "kind": "value", "args": [["", "key"], ["", "t('v)"]]}, {"path": "Belt.Map.Int", "name": "mapU", "type": "let mapU: (t('v), Js.Internal.fn([ `Arity_1 of 'v28 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_1 of 'v28 ], 'v2)"]]}, {"path": "Belt.Map.Int", "name": "map", "type": "let map: (t('v), 'v => 'v2) => t('v2)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v => 'v2"]]}, {"path": "Belt.Map.Int", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v27 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v27 ], 'v2)"]]}, {"path": "Belt.Map.Int", "name": "mapWithKey", "type": "let mapWithKey: (t('v), (key, 'v) => 'v2) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => 'v2"]]}, {"path": "Belt.Map.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type, its compare behavior is fixed using the built-in comparison</p>\n", "kind": "module"}, {"path": "Belt.Map.String", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt.Map.String", "name": "t", "type": "type t('value)", "docs": "<p>The type of maps from type <code>key</code> to type <code>&#39;value</code>.</p>\n", "kind": "type"}, {"path": "Belt.Map.String", "name": "empty", "type": "let empty: t('v)", "docs": null, "kind": "value"}, {"path": "Belt.Map.String", "name": "isEmpty", "type": "let isEmpty: t('v) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "has", "type": "let has: (t('v), key) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.String", "name": "cmpU", "type": "let cmpU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v26 * 'v26 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v26 * 'v26 ], int)"]]}, {"path": "Belt.Map.String", "name": "cmp", "type": "let cmp: (t('v), t('v), ('v, 'v) => int) => int", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => int"]]}, {"path": "Belt.Map.String", "name": "eqU", "type": "let eqU: (t('v), t('v), Js.Internal.fn([ `Arity_2 of 'v25 * 'v25 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of 'v25 * 'v25 ], bool)"]]}, {"path": "Belt.Map.String", "name": "eq", "type": "let eq: (t('v), t('v), ('v, 'v) => bool) => bool", "docs": "<p><code>equal m1 m2 cmp</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v)"], ["", "('v, 'v) => bool"]]}, {"path": "Belt.Map.String", "name": "forEachU", "type": "let forEachU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v24 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v24 ], unit)"]]}, {"path": "Belt.Map.String", "name": "forEach", "type": "let forEach: (t('v), (key, 'v) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => unit"]]}, {"path": "Belt.Map.String", "name": "reduceU", "type": "let reduceU: (t('v), 'v2, Js.Internal.fn([ `Arity_3 of 'v22 * key * 'v23 ], 'v2)) => 'v2", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "Js.Internal.fn([ `Arity_3 of 'v22 * key * 'v23 ], 'v2)"]]}, {"path": "Belt.Map.String", "name": "reduce", "type": "let reduce: (t('v), 'v2, ('v2, key, 'v) => 'v2) => 'v2", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v2"], ["", "('v2, key, 'v) => 'v2"]]}, {"path": "Belt.Map.String", "name": "everyU", "type": "let everyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v19 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v19 ], bool)"]]}, {"path": "Belt.Map.String", "name": "every", "type": "let every: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt.Map.String", "name": "someU", "type": "let someU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v18 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v18 ], bool)"]]}, {"path": "Belt.Map.String", "name": "some", "type": "let some: (t('v), (key, 'v) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt.Map.String", "name": "size", "type": "let size: t('v) => int", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "toList", "type": "let toList: t('v) => list((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "toArray", "type": "let toArray: t('v) => array((key, 'v))", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "ofArray", "type": "let ofArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt.Map.String", "name": "fromArray", "type": "let fromArray: array((key, 'v)) => t('v)", "docs": null, "kind": "value", "args": [["", "array((key, 'v))"]]}, {"path": "Belt.Map.String", "name": "keysToArray", "type": "let keysToArray: t('v) => array(key)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "valuesToArray", "type": "let valuesToArray: t('v) => array('v)", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.String", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.String", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.String", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.String", "name": "minimum", "type": "let minimum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "minUndefined", "type": "let minUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "maximum", "type": "let maximum: t('v) => option((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "maxUndefined", "type": "let maxUndefined: t('v) => Js.undefined((key, 'v))", "docs": null, "kind": "value", "args": [["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "get", "type": "let get: (t('v), key) => option('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.String", "name": "getUndefined", "type": "let getUndefined: (t('v), key) => Js.undefined('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.String", "name": "getWithDefault", "type": "let getWithDefault: (t('v), key, 'v) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt.Map.String", "name": "getExn", "type": "let getExn: (t('v), key) => 'v", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map.String", "name": "remove", "type": "let remove: (t('v), key) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"]]}, {"path": "Belt.Map.String", "name": "removeMany", "type": "let removeMany: (t('v), array(key)) => t('v)", "docs": "<p><code>remove m x</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "array(key)"]]}, {"path": "Belt.Map.String", "name": "set", "type": "let set: (t('v), key, 'v) => t('v)", "docs": "<p><code>add m x y</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "'v"]]}, {"path": "Belt.Map.String", "name": "updateU", "type": "let updateU: (t('v), key, Js.Internal.fn([ `Arity_1 of 'v17 option ], option('v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'v17 option ], option('v))"]]}, {"path": "Belt.Map.String", "name": "update", "type": "let update: (t('v), key, option('v) => option('v)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "key"], ["", "option('v) => option('v)"]]}, {"path": "Belt.Map.String", "name": "mergeArray", "type": "let mergeArray: (t('v), array((key, 'v))) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "array((key, 'v))"]]}, {"path": "Belt.Map.String", "name": "mergeU", "type": "let mergeU: (\n  t('v),\n  t('v2),\n  Js.Internal.fn([ `Arity_3 of key * 'v16 option * 'v21 option ], option('c))\n) => t('c)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "Js.Internal.fn([ `Arity_3 of key * 'v16 option * 'v21 option ], option('c))"]]}, {"path": "Belt.Map.String", "name": "merge", "type": "let merge: (t('v), t('v2), (key, option('v), option('v2)) => option('c)) => t('c)", "docs": "<p><code>merge m1 m2 f</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "t('v2)"], ["", "(key, option('v), option('v2)) => option('c)"]]}, {"path": "Belt.Map.String", "name": "keepU", "type": "let keepU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v15 ], bool)) => t('v)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v15 ], bool)"]]}, {"path": "Belt.Map.String", "name": "keep", "type": "let keep: (t('v), (key, 'v) => bool) => t('v)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt.Map.String", "name": "partitionU", "type": "let partitionU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v14 ], bool)) => (t('v), t('v))", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v14 ], bool)"]]}, {"path": "Belt.Map.String", "name": "partition", "type": "let partition: (t('v), (key, 'v) => bool) => (t('v), t('v))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => bool"]]}, {"path": "Belt.Map.String", "name": "split", "type": "let split: (key, t('v)) => (t('v), option('v), t('v))", "docs": "<p><code>split x m</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p>\n", "kind": "value", "args": [["", "key"], ["", "t('v)"]]}, {"path": "Belt.Map.String", "name": "mapU", "type": "let mapU: (t('v), Js.Internal.fn([ `Arity_1 of 'v13 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_1 of 'v13 ], 'v2)"]]}, {"path": "Belt.Map.String", "name": "map", "type": "let map: (t('v), 'v => 'v2) => t('v2)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('v)"], ["", "'v => 'v2"]]}, {"path": "Belt.Map.String", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('v), Js.Internal.fn([ `Arity_2 of key * 'v12 ], 'v2)) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'v12 ], 'v2)"]]}, {"path": "Belt.Map.String", "name": "mapWithKey", "type": "let mapWithKey: (t('v), (key, 'v) => 'v2) => t('v2)", "docs": null, "kind": "value", "args": [["", "t('v)"], ["", "(key, 'v) => 'v2"]]}, {"path": "Belt.Map.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.Map", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>specalized when key type is <code>string</code>, more efficient than the gerneic type, its compare behavior is fixed using the built-in comparison</p>\n", "kind": "module"}, {"path": "Belt.Map.Dict", "name": "t", "type": "type t('key, 'value, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.Map.Dict", "name": "cmp", "type": "type cmp('key, 'id) = Belt_Id.cmp('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.Map.Dict", "name": "empty", "type": "let empty: t('k, 'v, 'id)", "docs": null, "kind": "value"}, {"path": "Belt.Map.Dict", "name": "isEmpty", "type": "let isEmpty: t('k, 'v, 'id) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "has", "type": "let has: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "cmpU", "type": "let cmpU: (\n  t('k, 'v, 'id),\n  t('k, 'v, 'id),\n  ~kcmp: cmp('k, 'id),\n  ~vcmp: Js.Internal.fn([ `Arity_2 of 'v11 * 'v11 ], int)\n) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["kcmp", "cmp('k, 'id)"], ["vcmp", "Js.Internal.fn([ `Arity_2 of 'v11 * 'v11 ], int)"]]}, {"path": "Belt.Map.Dict", "name": "cmp", "type": "let cmp: (t('k, 'v, 'id), t('k, 'v, 'id), ~kcmp: cmp('k, 'id), ~vcmp: ('v, 'v) => int) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["kcmp", "cmp('k, 'id)"], ["vcmp", "('v, 'v) => int"]]}, {"path": "Belt.Map.Dict", "name": "eqU", "type": "let eqU: (\n  t('k, 'a, 'id),\n  t('k, 'a, 'id),\n  ~kcmp: cmp('k, 'id),\n  ~veq: Js.Internal.fn([ `Arity_2 of 'a74 * 'a74 ], bool)\n) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["kcmp", "cmp('k, 'id)"], ["veq", "Js.Internal.fn([ `Arity_2 of 'a74 * 'a74 ], bool)"]]}, {"path": "Belt.Map.Dict", "name": "eq", "type": "let eq: (t('k, 'a, 'id), t('k, 'a, 'id), ~kcmp: cmp('k, 'id), ~veq: ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 cmp</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["kcmp", "cmp('k, 'id)"], ["veq", "('a, 'a) => bool"]]}, {"path": "Belt.Map.Dict", "name": "forEachU", "type": "let forEachU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k19 * 'a73 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k19 * 'a73 ], unit)"]]}, {"path": "Belt.Map.Dict", "name": "forEach", "type": "let forEach: (t('k, 'a, 'id), ('k, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the &#39;k as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => unit"]]}, {"path": "Belt.Map.Dict", "name": "reduceU", "type": "let reduceU: (t('k, 'a, 'id), 'b, Js.Internal.fn([ `Arity_3 of 'b16 * 'k18 * 'a72 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b16 * 'k18 * 'a72 ], 'b)"]]}, {"path": "Belt.Map.Dict", "name": "reduce", "type": "let reduce: (t('k, 'a, 'id), 'b, ('b, 'k, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "('b, 'k, 'a) => 'b"]]}, {"path": "Belt.Map.Dict", "name": "everyU", "type": "let everyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k17 * 'a71 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k17 * 'a71 ], bool)"]]}, {"path": "Belt.Map.Dict", "name": "every", "type": "let every: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt.Map.Dict", "name": "someU", "type": "let someU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k16 * 'a70 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k16 * 'a70 ], bool)"]]}, {"path": "Belt.Map.Dict", "name": "some", "type": "let some: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt.Map.Dict", "name": "size", "type": "let size: t('k, 'a, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "toList", "type": "let toList: t('k, 'a, 'id) => list(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "toArray", "type": "let toArray: t('k, 'a, 'id) => array(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "ofArray", "type": "let ofArray: (array(('k, 'a)), ~cmp: cmp('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "fromArray", "type": "let fromArray: (array(('k, 'a)), ~cmp: cmp('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "keysToArray", "type": "let keysToArray: t('k, 'a, 'id) => array('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "valuesToArray", "type": "let valuesToArray: t('k, 'a, 'id) => array('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "minKey", "type": "let minKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map.Dict", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map.Dict", "name": "maxKey", "type": "let maxKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map.Dict", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map.Dict", "name": "minimum", "type": "let minimum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map.Dict", "name": "minUndefined", "type": "let minUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map.Dict", "name": "maximum", "type": "let maximum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map.Dict", "name": "maxUndefined", "type": "let maxUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map.Dict", "name": "get", "type": "let get: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => option('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "getUndefined", "type": "let getUndefined: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "getWithDefault", "type": "let getWithDefault: (t('k, 'a, 'id), 'k, 'a, ~cmp: cmp('k, 'id)) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "'a"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "getExn", "type": "let getExn: (t('k, 'a, 'id), 'k, ~cmp: cmp('k, 'id)) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["cmp", "cmp('k, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.Map.Dict", "name": "remove", "type": "let remove: (t('a, 'b, 'id), 'a, ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "removeMany", "type": "let removeMany: (t('a, 'b, 'id), array('a), ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "array('a)"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "set", "type": "let set: (t('a, 'b, 'id), 'a, 'b, ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["", "'b"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "updateU", "type": "let updateU: (\n  t('a, 'b, 'id),\n  'a,\n  Js.Internal.fn([ `Arity_1 of 'b15 option ], option('b)),\n  ~cmp: cmp('a, 'id)\n) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_1 of 'b15 option ], option('b))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "update", "type": "let update: (t('a, 'b, 'id), 'a, option('b) => option('b), ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["", "option('b) => option('b)"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "mergeU", "type": "let mergeU: (\n  t('a, 'b, 'id),\n  t('a, 'c, 'id),\n  Js.Internal.fn([ `Arity_3 of 'a69 * 'b14 option * 'c6 option ], option('d)),\n  ~cmp: cmp('a, 'id)\n) => t('a, 'd, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "t('a, 'c, 'id)"], ["", "Js.Internal.fn([ `Arity_3 of 'a69 * 'b14 option * 'c6 option ], option('d))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "merge", "type": "let merge: (\n  t('a, 'b, 'id),\n  t('a, 'c, 'id),\n  ('a, option('b), option('c)) => option('d),\n  ~cmp: cmp('a, 'id)\n) => t('a, 'd, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "t('a, 'c, 'id)"], ["", "('a, option('b), option('c)) => option('d)"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "mergeMany", "type": "let mergeMany: (t('a, 'b, 'id), array(('a, 'b)), ~cmp: cmp('a, 'id)) => t('a, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "array(('a, 'b))"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "keepU", "type": "let keepU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k15 * 'a68 ], bool)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k15 * 'a68 ], bool)"]]}, {"path": "Belt.Map.Dict", "name": "keep", "type": "let keep: (t('k, 'a, 'id), ('k, 'a) => bool) => t('k, 'a, 'id)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt.Map.Dict", "name": "partitionU", "type": "let partitionU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k14 * 'a67 ], bool)) => (\n  t('k, 'a, 'id),\n  t('k, 'a, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k14 * 'a67 ], bool)"]]}, {"path": "Belt.Map.Dict", "name": "partition", "type": "let partition: (t('k, 'a, 'id), ('k, 'a) => bool) => (t('k, 'a, 'id), t('k, 'a, 'id))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt.Map.Dict", "name": "split", "type": "let split: (t('a, 'b, 'id), 'a, ~cmp: cmp('a, 'id)) => (\n  (t('a, 'b, 'id), t('a, 'b, 'id)),\n  option('b)\n)", "docs": null, "kind": "value", "args": [["", "t('a, 'b, 'id)"], ["", "'a"], ["cmp", "cmp('a, 'id)"]]}, {"path": "Belt.Map.Dict", "name": "mapU", "type": "let mapU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_1 of 'a66 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'a66 ], 'b)"]]}, {"path": "Belt.Map.Dict", "name": "map", "type": "let map: (t('k, 'a, 'id), 'a => 'b) => t('k, 'b, 'id)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'a => 'b"]]}, {"path": "Belt.Map.Dict", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k13 * 'a65 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k13 * 'a65 ], 'b)"]]}, {"path": "Belt.Map.Dict", "name": "mapWithKey", "type": "let mapWithKey: (t('k, 'a, 'id), ('k, 'a) => 'b) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => 'b"]]}, {"path": "Belt.Map", "name": "Dict", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>cmp\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>This module seprate identity from data, it is a bit more verbsoe but slightly more efficient due to the fact that there is no need to pack identity and data back after each operation</p>\n<p><strong>Advanced usage only</strong></p>\n", "kind": "module"}, {"path": "Belt.Map", "name": "t", "type": "type t('key, 'value, 'identity)", "docs": "<p><code>(&#39;key, &#39;identity) t</code></p>\n<p><code>&#39;key</code> is the field type</p>\n<p><code>&#39;value</code> is the element type</p>\n<p><code>&#39;identity</code> the identity of the collection</p>\n", "kind": "type"}, {"path": "Belt.Map", "name": "id", "type": "type id('key, 'id) = Belt_Id.comparable('key, 'id)", "docs": "<p>The identity needed for making an empty map</p>\n", "kind": "type"}, {"path": "Belt.Map", "name": "make", "type": "let make: (~id: id('k, 'id)) => t('k, 'v, 'id)", "docs": "<p><code>make ~id</code> creates a new map by taking in the comparator</p>\n<pre class='ml'><code class='ml'>let m = Belt.Map.make ~id:(module IntCmp)\n</code></pre>", "kind": "value", "args": [["id", "id('k, 'id)"]]}, {"path": "Belt.Map", "name": "isEmpty", "type": "let isEmpty: t('a, 'a, 'a) => bool", "docs": "<p><code>isEmpty m</code> checks whether a map m is empty</p>\n<pre class='ml'><code class='ml'>isEmpty (fromArray [|1,&quot;1&quot;|] ~id:(module IntCmp)) = false\n</code></pre>", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.Map", "name": "has", "type": "let has: (t('k, 'v, 'id), 'k) => bool", "docs": "<p><code>has m k</code> checks whether m has the key k</p>\n<pre class='ml'><code class='ml'>has (fromArray [|1,&quot;1&quot;|] ~id:(module IntCmp)) 1 = true\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt.Map", "name": "cmpU", "type": "let cmpU: (t('k, 'v, 'id), t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'v10 * 'v10 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'v10 * 'v10 ], int)"]]}, {"path": "Belt.Map", "name": "cmp", "type": "let cmp: (t('k, 'v, 'id), t('k, 'v, 'id), ('v, 'v) => int) => int", "docs": "<p><code>cmp m0 m1 vcmp</code></p>\n<p>Total ordering of map given total ordering of value function.</p>\n<p>It will compare size first and each element following the order one by one.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["", "('v, 'v) => int"]]}, {"path": "Belt.Map", "name": "eqU", "type": "let eqU: (t('k, 'v, 'id), t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'v9 * 'v9 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'v9 * 'v9 ], bool)"]]}, {"path": "Belt.Map", "name": "eq", "type": "let eq: (t('k, 'v, 'id), t('k, 'v, 'id), ('v, 'v) => bool) => bool", "docs": "<p><code>eq m1 m2 veq</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>veq</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v, 'id)"], ["", "('v, 'v) => bool"]]}, {"path": "Belt.Map", "name": "forEachU", "type": "let forEachU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k12 * 'v8 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k12 * 'v8 ], unit)"]]}, {"path": "Belt.Map", "name": "forEach", "type": "let forEach: (t('k, 'v, 'id), ('k, 'v) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the &#39;k as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|4,&quot;4&quot;;1,&quot;1&quot;;2,&quot;2,&quot;3&quot;&quot;|];;\nlet acc = ref [] ;;\nforEach s0 (fun k v -&gt; acc := (k,v) :: !acc);;\n\n!acc = [4,&quot;4&quot;; 3,&quot;3&quot;; 2,&quot;2&quot;; 1,&quot;1&quot;]\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => unit"]]}, {"path": "Belt.Map", "name": "reduceU", "type": "let reduceU: (t('k, 'v, 'id), 'acc, Js.Internal.fn([ `Arity_3 of 'acc * 'k11 * 'v7 ], 'acc)) => 'acc", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'acc"], ["", "Js.Internal.fn([ `Arity_3 of 'acc * 'k11 * 'v7 ], 'acc)"]]}, {"path": "Belt.Map", "name": "reduce", "type": "let reduce: (t('k, 'v, 'id), 'acc, ('acc, 'k, 'v) => 'acc) => 'acc", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n<pre class='ml'><code class='ml'>let s0 = fromArray ~id:(module IntCmp) [|4,&quot;4&quot;;1,&quot;1&quot;;2,&quot;2,&quot;3&quot;&quot;|];;\nreduce s0 [] (fun acc k v -&gt; (k,v) acc ) = [4,&quot;4&quot;;3,&quot;3&quot;;2,&quot;2&quot;;1,&quot;1&quot;];;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'acc"], ["", "('acc, 'k, 'v) => 'acc"]]}, {"path": "Belt.Map", "name": "everyU", "type": "let everyU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k10 * 'v6 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k10 * 'v6 ], bool)"]]}, {"path": "Belt.Map", "name": "every", "type": "let every: (t('k, 'v, 'id), ('k, 'v) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => bool"]]}, {"path": "Belt.Map", "name": "someU", "type": "let someU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k9 * 'v5 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k9 * 'v5 ], bool)"]]}, {"path": "Belt.Map", "name": "some", "type": "let some: (t('k, 'v, 'id), ('k, 'v) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => bool"]]}, {"path": "Belt.Map", "name": "size", "type": "let size: t('k, 'v, 'id) => int", "docs": "<p><code>size s</code></p>\n<pre class='ml'><code class='ml'>size (fromArray [2,&quot;2&quot;; 2,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = 2 ;;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt.Map", "name": "toArray", "type": "let toArray: t('k, 'v, 'id) => array(('k, 'v))", "docs": "<p><code>size s</code></p>\n<pre class='ml'><code class='ml'>size (fromArray [2,&quot;2&quot;; 2,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = 2 ;;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt.Map", "name": "toList", "type": "let toList: t('k, 'v, 'id) => list(('k, 'v))", "docs": "<p><code>toArray s</code></p>\n<pre class='ml'><code class='ml'>toArray (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = [1,&quot;1&quot;;2,&quot;2&quot;;3,&quot;3&quot;]\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt.Map", "name": "ofArray", "type": "let ofArray: (array(('k, 'v)), ~id: id('k, 'id)) => t('k, 'v, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'v))"], ["id", "id('k, 'id)"]]}, {"path": "Belt.Map", "name": "fromArray", "type": "let fromArray: (array(('k, 'v)), ~id: id('k, 'id)) => t('k, 'v, 'id)", "docs": "<p><code>fromArray kvs ~id</code></p>\n<pre class='ml'><code class='ml'>toArray (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = [1,&quot;1&quot;;2,&quot;2&quot;;3,&quot;3&quot;]\n</code></pre>", "kind": "value", "args": [["", "array(('k, 'v))"], ["id", "id('k, 'id)"]]}, {"path": "Belt.Map", "name": "keysToArray", "type": "let keysToArray: t('k, 'v, 'id) => array('k)", "docs": "<p><code>fromArray kvs ~id</code></p>\n<pre class='ml'><code class='ml'>toArray (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) = [1,&quot;1&quot;;2,&quot;2&quot;;3,&quot;3&quot;]\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt.Map", "name": "valuesToArray", "type": "let valuesToArray: t('k, 'v, 'id) => array('v)", "docs": "<p><code>keysToArray s</code></p>\n<pre class='ml'><code class='ml'>keysToArray (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) =\n[|1;2;3|];;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt.Map", "name": "minKey", "type": "let minKey: t('k, 'a, 'a) => option('k)", "docs": "<p><code>minKey s</code></p>\n<p>Returns: <p>the minimum key, None if not exist</p></p>\n", "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": "<p><strong>See</strong> minKey</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map", "name": "maxKey", "type": "let maxKey: t('k, 'a, 'a) => option('k)", "docs": "<p><code>maxKey s</code></p>\n<p>Returns: <p>the maximum key, None if not exist</p></p>\n", "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": "<p><strong>See</strong> maxKey</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.Map", "name": "minimum", "type": "let minimum: t('k, 'v, 'a) => option(('k, 'v))", "docs": "<p><code>minimum s</code></p>\n<p>Returns: <p>the minimum key value pair, None if not exist</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'a)"]]}, {"path": "Belt.Map", "name": "minUndefined", "type": "let minUndefined: t('k, 'v, 'a) => Js.undefined(('k, 'v))", "docs": "<p><strong>See</strong> minimum</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'a)"]]}, {"path": "Belt.Map", "name": "maximum", "type": "let maximum: t('k, 'v, 'a) => option(('k, 'v))", "docs": "<p><code>maximum s</code></p>\n<p>Returns: <p>the maximum key value pair, None if not exist</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'a)"]]}, {"path": "Belt.Map", "name": "maxUndefined", "type": "let maxUndefined: t('k, 'v, 'a) => Js.undefined(('k, 'v))", "docs": "<p><strong>See</strong> maximum</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'a)"]]}, {"path": "Belt.Map", "name": "get", "type": "let get: (t('k, 'v, 'id), 'k) => option('v)", "docs": "<p><code>get s k</code></p>\n<pre class='ml'><code class='ml'>get (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) 2 =\nSome &quot;2&quot;;;\nget (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp)) 2 =\nNone;;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt.Map", "name": "getUndefined", "type": "let getUndefined: (t('k, 'v, 'id), 'k) => Js.undefined('v)", "docs": "<p><strong>See</strong> get</p>\n<p>Returns: <p><code>undefined</code> when not found</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt.Map", "name": "getWithDefault", "type": "let getWithDefault: (t('k, 'v, 'id), 'k, 'v) => 'v", "docs": "<p><strong>See</strong> get</p>\n<p>Returns: <p><code>undefined</code> when not found</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"], ["", "'v"]]}, {"path": "Belt.Map", "name": "getExn", "type": "let getExn: (t('k, 'v, 'id), 'k) => 'v", "docs": "<p><code>getWithDefault s k default</code></p>\n<p><strong>See</strong> get</p>\n<p>Returns: <p><code>default</code> when <code>k</code> is not found</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt.Map", "name": "remove", "type": "let remove: (t('k, 'v, 'id), 'k) => t('k, 'v, 'id)", "docs": "<p><code>remove m x</code> when <code>x</code> is not in <code>m</code>, <code>m</code> is returned reference unchanged.</p>\n<pre class='ml'><code class='ml'>let s0 =  (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp));;\n\nlet s1 = remove s0 1;;\nlet s2 = remove s1 1;;\ns1 == s2 ;;\nkeysToArray s1 = [|2;3|];;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt.Map", "name": "removeMany", "type": "let removeMany: (t('k, 'v, 'id), array('k)) => t('k, 'v, 'id)", "docs": "<p><code>removeMany s xs</code></p>\n<p>Removing each of <code>xs</code> to <code>s</code>, note unlike remove, the reference of return value might be changed even if none in <code>xs</code> exists <code>s</code></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "array('k)"]]}, {"path": "Belt.Map", "name": "set", "type": "let set: (t('k, 'v, 'id), 'k, 'v) => t('k, 'v, 'id)", "docs": "<p><code>set m x y </code> returns a map containing the same bindings as <code>m</code>, with a new binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n<pre class='ml'><code class='ml'>let s0 =  (fromArray [2,&quot;2&quot;; 1,&quot;1&quot;; 3,&quot;3&quot;] ~id:(module IntCmp));;\n\nlet s1 = set s0 2 &quot;3&quot;;;\n\nvaluesToArray s1 =  [&quot;1&quot;;&quot;3&quot;;&quot;3&quot;];;\n</code></pre>", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"], ["", "'v"]]}, {"path": "Belt.Map", "name": "updateU", "type": "let updateU: (t('k, 'v, 'id), 'k, Js.Internal.fn([ `Arity_1 of 'v4 option ], option('v))) => t(\n  'k,\n  'v,\n  'id\n)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"], ["", "Js.Internal.fn([ `Arity_1 of 'v4 option ], option('v))"]]}, {"path": "Belt.Map", "name": "update", "type": "let update: (t('k, 'v, 'id), 'k, option('v) => option('v)) => t('k, 'v, 'id)", "docs": "<p><code>update m x f</code> returns a map containing the same bindings as <code>m</code>, except for the binding of <code>x</code>. Depending on the value of <code>y</code> where <code>y</code> is <code>f (get x m)</code>, the binding of <code>x</code> is added, removed or updated. If <code>y</code> is <code>None</code>, the binding is removed if it exists; otherwise, if <code>y</code> is <code>Some z</code> then <code>x</code> is associated to <code>z</code> in the resulting map.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"], ["", "option('v) => option('v)"]]}, {"path": "Belt.Map", "name": "mergeMany", "type": "let mergeMany: (t('k, 'v, 'id), array(('k, 'v))) => t('k, 'v, 'id)", "docs": "<p><code>mergeMany s xs</code></p>\n<p>Adding each of <code>xs</code> to <code>s</code>, note unlike add, the reference of return value might be changed even if all values in <code>xs</code> exist <code>s</code></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "array(('k, 'v))"]]}, {"path": "Belt.Map", "name": "mergeU", "type": "let mergeU: (\n  t('k, 'v, 'id),\n  t('k, 'v2, 'id),\n  Js.Internal.fn([ `Arity_3 of 'k8 * 'v3 option * 'v20 option ], option('v3))\n) => t('k, 'v3, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v2, 'id)"], ["", "Js.Internal.fn([ `Arity_3 of 'k8 * 'v3 option * 'v20 option ], option('v3))"]]}, {"path": "Belt.Map", "name": "merge", "type": "let merge: (t('k, 'v, 'id), t('k, 'v2, 'id), ('k, option('v), option('v2)) => option('v3)) => t(\n  'k,\n  'v3,\n  'id\n)", "docs": "<p><code>merge m1 m2 f</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "t('k, 'v2, 'id)"], ["", "('k, option('v), option('v2)) => option('v3)"]]}, {"path": "Belt.Map", "name": "keepU", "type": "let keepU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k7 * 'v2 ], bool)) => t('k, 'v, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k7 * 'v2 ], bool)"]]}, {"path": "Belt.Map", "name": "keep", "type": "let keep: (t('k, 'v, 'id), ('k, 'v) => bool) => t('k, 'v, 'id)", "docs": "<p><code>keep m p</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => bool"]]}, {"path": "Belt.Map", "name": "partitionU", "type": "let partitionU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k6 * 'v1 ], bool)) => (\n  t('k, 'v, 'id),\n  t('k, 'v, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k6 * 'v1 ], bool)"]]}, {"path": "Belt.Map", "name": "partition", "type": "let partition: (t('k, 'v, 'id), ('k, 'v) => bool) => (t('k, 'v, 'id), t('k, 'v, 'id))", "docs": "<p><code>partition m p</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => bool"]]}, {"path": "Belt.Map", "name": "split", "type": "let split: (t('k, 'v, 'id), 'k) => ((t('k, 'v, 'id), t('k, 'v, 'id)), option('v))", "docs": "<p><code>split x m</code> returns a tuple <code>(l r), data</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose &#39;k is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose &#39;k is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'k"]]}, {"path": "Belt.Map", "name": "mapU", "type": "let mapU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_1 of 'v0 ], 'v2)) => t('k, 'v2, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'v0 ], 'v2)"]]}, {"path": "Belt.Map", "name": "map", "type": "let map: (t('k, 'v, 'id), 'v => 'v2) => t('k, 'v2, 'id)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "'v => 'v2"]]}, {"path": "Belt.Map", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('k, 'v, 'id), Js.Internal.fn([ `Arity_2 of 'k5 * 'v ], 'v2)) => t('k, 'v2, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k5 * 'v ], 'v2)"]]}, {"path": "Belt.Map", "name": "mapWithKey", "type": "let mapWithKey: (t('k, 'v, 'id), ('k, 'v) => 'v2) => t('k, 'v2, 'id)", "docs": "<p><code>mapWithKey m f</code></p>\n<p>The same as map except that <code>f</code> is supplied with one more argument: the key</p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"], ["", "('k, 'v) => 'v2"]]}, {"path": "Belt.Map", "name": "getData", "type": "let getData: t('k, 'v, 'id) => Belt_MapDict.t('k, 'v, 'id)", "docs": "<p><code>getData s0</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the raw data (detached from comparator), but its type is still manifested, so that user can pass identity directly without boxing</p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt.Map", "name": "getId", "type": "let getId: t('k, 'v, 'id) => id('k, 'id)", "docs": "<p><code>getId s0</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the identity of <code>s0</code></p></p>\n", "kind": "value", "args": [["", "t('k, 'v, 'id)"]]}, {"path": "Belt.Map", "name": "packIdData", "type": "let packIdData: (~id: id('k, 'id), ~data: Belt_MapDict.t('k, 'v, 'id)) => t('k, 'v, 'id)", "docs": "<p><code>packIdData ~id ~data</code></p>\n<p><strong>Advanced usage only</strong></p>\n<p>Returns: <p>the packed collection</p></p>\n", "kind": "value", "args": [["id", "id('k, 'id)"], ["data", "Belt_MapDict.t('k, 'v, 'id)"]]}, {"path": "Belt.Map", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a, 'a) => unit", "docs": "<p>/*</p>\n", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt", "name": "Map", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getData\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getId\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>packIdData\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Dict\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt.MutableSet.Int", "name": "value", "type": "type value = int", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt.MutableSet.Int", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt.MutableSet.Int", "name": "make", "type": "let make: unit => t", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt.MutableSet.Int", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.MutableSet.Int", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.MutableSet.Int", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.MutableSet.Int", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.MutableSet.Int", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.Int", "name": "add", "type": "let add: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.Int", "name": "addCheck", "type": "let addCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.Int", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt.MutableSet.Int", "name": "remove", "type": "let remove: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.Int", "name": "removeCheck", "type": "let removeCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.Int", "name": "removeMany", "type": "let removeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt.MutableSet.Int", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "subset", "type": "let subset: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "eq", "type": "let eq: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt.MutableSet.Int", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt.MutableSet.Int", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a64 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a64 * value ], 'a)"]]}, {"path": "Belt.MutableSet.Int", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt.MutableSet.Int", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.MutableSet.Int", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.MutableSet.Int", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.MutableSet.Int", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.MutableSet.Int", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.MutableSet.Int", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep s p</code> returns a fresh copy of the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.MutableSet.Int", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.MutableSet.Int", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition s p</code> returns a fresh copy pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.MutableSet.Int", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.Int", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.Int", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.Int", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.Int", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split s key</code> return a fresh copy of each</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt.MutableSet.String", "name": "value", "type": "type value = string", "docs": "<p>The type of the set elements.</p>\n", "kind": "type"}, {"path": "Belt.MutableSet.String", "name": "t", "type": "type t", "docs": "<p>The type of sets.</p>\n", "kind": "type"}, {"path": "Belt.MutableSet.String", "name": "make", "type": "let make: unit => t", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt.MutableSet.String", "name": "fromArray", "type": "let fromArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.MutableSet.String", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.MutableSet.String", "name": "ofArray", "type": "let ofArray: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.MutableSet.String", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: array(value) => t", "docs": null, "kind": "value", "args": [["", "array(value)"]]}, {"path": "Belt.MutableSet.String", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "has", "type": "let has: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.String", "name": "add", "type": "let add: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.String", "name": "addCheck", "type": "let addCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.String", "name": "mergeMany", "type": "let mergeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt.MutableSet.String", "name": "remove", "type": "let remove: (t, value) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.String", "name": "removeCheck", "type": "let removeCheck: (t, value) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.String", "name": "removeMany", "type": "let removeMany: (t, array(value)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(value)"]]}, {"path": "Belt.MutableSet.String", "name": "union", "type": "let union: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "intersect", "type": "let intersect: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "diff", "type": "let diff: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "subset", "type": "let subset: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "cmp", "type": "let cmp: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "eq", "type": "let eq: (t, t) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of value ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], unit)"]]}, {"path": "Belt.MutableSet.String", "name": "forEach", "type": "let forEach: (t, value => unit) => unit", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t"], ["", "value => unit"]]}, {"path": "Belt.MutableSet.String", "name": "reduceU", "type": "let reduceU: (t, 'a, Js.Internal.fn([ `Arity_2 of 'a63 * value ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a63 * value ], 'a)"]]}, {"path": "Belt.MutableSet.String", "name": "reduce", "type": "let reduce: (t, 'a, ('a, value) => 'a) => 'a", "docs": "<p>Iterate in increasing order.</p>\n", "kind": "value", "args": [["", "t"], ["", "'a"], ["", "('a, value) => 'a"]]}, {"path": "Belt.MutableSet.String", "name": "everyU", "type": "let everyU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.MutableSet.String", "name": "every", "type": "let every: (t, value => bool) => bool", "docs": "<p><code>every p s</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.MutableSet.String", "name": "someU", "type": "let someU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.MutableSet.String", "name": "some", "type": "let some: (t, value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>. Oder unspecified.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.MutableSet.String", "name": "keepU", "type": "let keepU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.MutableSet.String", "name": "keep", "type": "let keep: (t, value => bool) => t", "docs": "<p><code>keep s p</code> returns a fresh copy of the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.MutableSet.String", "name": "partitionU", "type": "let partitionU: (t, Js.Internal.fn([ `Arity_1 of value ], bool)) => (t, t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of value ], bool)"]]}, {"path": "Belt.MutableSet.String", "name": "partition", "type": "let partition: (t, value => bool) => (t, t)", "docs": "<p><code>partition s p</code> returns a fresh copy pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "value => bool"]]}, {"path": "Belt.MutableSet.String", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "toList", "type": "let toList: t => list(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "toArray", "type": "let toArray: t => array(value)", "docs": "<p>In increasing order with respect</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "minimum", "type": "let minimum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "minUndefined", "type": "let minUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "maximum", "type": "let maximum: t => option(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "maxUndefined", "type": "let maxUndefined: t => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet.String", "name": "get", "type": "let get: (t, value) => option(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.String", "name": "getUndefined", "type": "let getUndefined: (t, value) => Js.undefined(value)", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.String", "name": "getExn", "type": "let getExn: (t, value) => value", "docs": null, "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.String", "name": "split", "type": "let split: (t, value) => ((t, t), bool)", "docs": "<p><code>split s key</code> return a fresh copy of each</p>\n", "kind": "value", "args": [["", "t"], ["", "value"]]}, {"path": "Belt.MutableSet.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Belt.MutableSet", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>value", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt.MutableSet", "name": "t", "type": "type t('k, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.MutableSet", "name": "id", "type": "type id('k, 'id) = Belt_Id.comparable('k, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.MutableSet", "name": "make", "type": "let make: (~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["id", "id('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "fromArray", "type": "let fromArray: (array('k), ~id: id('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["id", "id('k, 'id)"]]}, {"path": "Belt.MutableSet", "name": "fromSortedArrayUnsafe", "type": "let fromSortedArrayUnsafe: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "copy", "type": "let copy: t('k, 'id) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'id)"]]}, {"path": "Belt.MutableSet", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt.MutableSet", "name": "has", "type": "let has: (t('value, 'a), 'value) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'a)"], ["", "'value"]]}, {"path": "Belt.MutableSet", "name": "add", "type": "let add: (t('value, 'id), 'value) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.MutableSet", "name": "addCheck", "type": "let addCheck: (t('value, 'id), 'value) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.MutableSet", "name": "mergeMany", "type": "let mergeMany: (t('value, 'id), array('value)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"]]}, {"path": "Belt.MutableSet", "name": "remove", "type": "let remove: (t('value, 'id), 'value) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.MutableSet", "name": "removeCheck", "type": "let removeCheck: (t('value, 'id), 'value) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.MutableSet", "name": "removeMany", "type": "let removeMany: (t('value, 'id), array('value)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "array('value)"]]}, {"path": "Belt.MutableSet", "name": "union", "type": "let union: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "intersect", "type": "let intersect: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "diff", "type": "let diff: (t('value, 'id), t('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "subset", "type": "let subset: (t('value, 'id), t('value, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "cmp", "type": "let cmp: (t('value, 'id), t('value, 'id)) => int", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "eq", "type": "let eq: (t('value, 'id), t('value, 'id)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "forEachU", "type": "let forEachU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value7 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value7 ], unit)"]]}, {"path": "Belt.MutableSet", "name": "forEach", "type": "let forEach: (t('value, 'id), 'value => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> in turn to all elements of <code>m</code>. In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => unit"]]}, {"path": "Belt.MutableSet", "name": "reduceU", "type": "let reduceU: (t('value, 'id), 'a, Js.Internal.fn([ `Arity_2 of 'a62 * 'value6 ], 'a)) => 'a", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "Js.Internal.fn([ `Arity_2 of 'a62 * 'value6 ], 'a)"]]}, {"path": "Belt.MutableSet", "name": "reduce", "type": "let reduce: (t('value, 'id), 'a, ('a, 'value) => 'a) => 'a", "docs": "<p>In increasing order.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'a"], ["", "('a, 'value) => 'a"]]}, {"path": "Belt.MutableSet", "name": "everyU", "type": "let everyU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value5 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value5 ], bool)"]]}, {"path": "Belt.MutableSet", "name": "every", "type": "let every: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>every s p</code> checks if all elements of the set satisfy the predicate <code>p</code>. Order unspecified</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.MutableSet", "name": "someU", "type": "let someU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value4 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value4 ], bool)"]]}, {"path": "Belt.MutableSet", "name": "some", "type": "let some: (t('value, 'id), 'value => bool) => bool", "docs": "<p><code>some p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.MutableSet", "name": "keepU", "type": "let keepU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value3 ], bool)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value3 ], bool)"]]}, {"path": "Belt.MutableSet", "name": "keep", "type": "let keep: (t('value, 'id), 'value => bool) => t('value, 'id)", "docs": "<p><code>keep s p</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.MutableSet", "name": "partitionU", "type": "let partitionU: (t('value, 'id), Js.Internal.fn([ `Arity_1 of 'value2 ], bool)) => (\n  t('value, 'id),\n  t('value, 'id)\n)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'value2 ], bool)"]]}, {"path": "Belt.MutableSet", "name": "partition", "type": "let partition: (t('value, 'id), 'value => bool) => (t('value, 'id), t('value, 'id))", "docs": "<p><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value => bool"]]}, {"path": "Belt.MutableSet", "name": "size", "type": "let size: t('value, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "toList", "type": "let toList: t('value, 'id) => list('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "toArray", "type": "let toArray: t('value, 'id) => array('value)", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "minimum", "type": "let minimum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "minUndefined", "type": "let minUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "maximum", "type": "let maximum: t('value, 'id) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "maxUndefined", "type": "let maxUndefined: t('value, 'id) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"]]}, {"path": "Belt.MutableSet", "name": "get", "type": "let get: (t('value, 'id), 'value) => option('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.MutableSet", "name": "getUndefined", "type": "let getUndefined: (t('value, 'id), 'value) => Js.undefined('value)", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.MutableSet", "name": "getExn", "type": "let getExn: (t('value, 'id), 'value) => 'value", "docs": null, "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.MutableSet", "name": "split", "type": "let split: (t('value, 'id), 'value) => ((t('value, 'id), t('value, 'id)), bool)", "docs": "<p><code>split s x</code> returns a triple <code>((l, r), present)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>. <code>l,r</code> are freshly made, no sharing with <code>s</code></p>\n", "kind": "value", "args": [["", "t('value, 'id)"], ["", "'value"]]}, {"path": "Belt.MutableSet", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt.MutableSet", "name": "ofArray", "type": "let ofArray: (array('k), ~id: id('k, 'id)) => t('k, 'id)", "docs": null, "kind": "value", "args": [["", "array('k)"], ["id", "id('k, 'id)"]]}, {"path": "Belt.MutableSet", "name": "ofSortedArrayUnsafe", "type": "let ofSortedArrayUnsafe: (array('value), ~id: id('value, 'id)) => t('value, 'id)", "docs": null, "kind": "value", "args": [["", "array('value)"], ["id", "id('value, 'id)"]]}, {"path": "Belt", "name": "MutableSet", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>addCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>diff\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>intersect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofSortedArrayUnsafe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partitionU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCheck\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>union\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt.MutableMap.Int", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt.MutableMap.Int", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Belt.MutableMap.Int", "name": "make", "type": "let make: unit => t('a)", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt.MutableMap.Int", "name": "clear", "type": "let clear: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "has", "type": "let has: (t('a), key) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.Int", "name": "cmpU", "type": "let cmpU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a61 * 'a61 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a61 * 'a61 ], int)"]]}, {"path": "Belt.MutableMap.Int", "name": "cmp", "type": "let cmp: (t('a), t('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt.MutableMap.Int", "name": "eqU", "type": "let eqU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a60 * 'a60 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a60 * 'a60 ], bool)"]]}, {"path": "Belt.MutableMap.Int", "name": "eq", "type": "let eq: (t('a), t('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 cmp</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt.MutableMap.Int", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a59 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a59 ], unit)"]]}, {"path": "Belt.MutableMap.Int", "name": "forEach", "type": "let forEach: (t('a), (key, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The application order of <code>f</code> is in increasing order.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => unit"]]}, {"path": "Belt.MutableMap.Int", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_3 of 'b13 * key * 'a58 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b13 * key * 'a58 ], 'b)"]]}, {"path": "Belt.MutableMap.Int", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, key, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, key, 'a) => 'b"]]}, {"path": "Belt.MutableMap.Int", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a57 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a57 ], bool)"]]}, {"path": "Belt.MutableMap.Int", "name": "every", "type": "let every: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt.MutableMap.Int", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a56 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a56 ], bool)"]]}, {"path": "Belt.MutableMap.Int", "name": "some", "type": "let some: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt.MutableMap.Int", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "toList", "type": "let toList: t('a) => list((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt.MutableMap.Int", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt.MutableMap.Int", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "minimum", "type": "let minimum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "minUndefined", "type": "let minUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "maximum", "type": "let maximum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "maxUndefined", "type": "let maxUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.Int", "name": "getUndefined", "type": "let getUndefined: (t('a), key) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.Int", "name": "getWithDefault", "type": "let getWithDefault: (t('a), key, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt.MutableMap.Int", "name": "getExn", "type": "let getExn: (t('a), key) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.Int", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.Int", "name": "removeMany", "type": "let removeMany: (t('a), array(key)) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "array(key)"]]}, {"path": "Belt.MutableMap.Int", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>add m x y</code> do the in-place modification, return <code>m</code> for chaining. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt.MutableMap.Int", "name": "updateU", "type": "let updateU: (t('a), key, Js.Internal.fn([ `Arity_1 of 'a55 option ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'a55 option ], option('a))"]]}, {"path": "Belt.MutableMap.Int", "name": "update", "type": "let update: (t('a), key, option('a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "option('a) => option('a)"]]}, {"path": "Belt.MutableMap.Int", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a54 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a54 ], 'b)"]]}, {"path": "Belt.MutableMap.Int", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt.MutableMap.Int", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a53 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a53 ], 'b)"]]}, {"path": "Belt.MutableMap.Int", "name": "mapWithKey", "type": "let mapWithKey: (t('a), (key, 'a) => 'b) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => 'b"]]}, {"path": "Belt.MutableMap", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt.MutableMap.String", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt.MutableMap.String", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Belt.MutableMap.String", "name": "make", "type": "let make: unit => t('a)", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Belt.MutableMap.String", "name": "clear", "type": "let clear: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "has", "type": "let has: (t('a), key) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.String", "name": "cmpU", "type": "let cmpU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a52 * 'a52 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a52 * 'a52 ], int)"]]}, {"path": "Belt.MutableMap.String", "name": "cmp", "type": "let cmp: (t('a), t('a), ('a, 'a) => int) => int", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => int"]]}, {"path": "Belt.MutableMap.String", "name": "eqU", "type": "let eqU: (t('a), t('a), Js.Internal.fn([ `Arity_2 of 'a51 * 'a51 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of 'a51 * 'a51 ], bool)"]]}, {"path": "Belt.MutableMap.String", "name": "eq", "type": "let eq: (t('a), t('a), ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 cmp</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt.MutableMap.String", "name": "forEachU", "type": "let forEachU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a50 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a50 ], unit)"]]}, {"path": "Belt.MutableMap.String", "name": "forEach", "type": "let forEach: (t('a), (key, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The application order of <code>f</code> is in increasing order.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => unit"]]}, {"path": "Belt.MutableMap.String", "name": "reduceU", "type": "let reduceU: (t('a), 'b, Js.Internal.fn([ `Arity_3 of 'b12 * key * 'a49 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b12 * key * 'a49 ], 'b)"]]}, {"path": "Belt.MutableMap.String", "name": "reduce", "type": "let reduce: (t('a), 'b, ('b, key, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'b"], ["", "('b, key, 'a) => 'b"]]}, {"path": "Belt.MutableMap.String", "name": "everyU", "type": "let everyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a48 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a48 ], bool)"]]}, {"path": "Belt.MutableMap.String", "name": "every", "type": "let every: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt.MutableMap.String", "name": "someU", "type": "let someU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a47 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a47 ], bool)"]]}, {"path": "Belt.MutableMap.String", "name": "some", "type": "let some: (t('a), (key, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. The application order of <code>p</code> is unspecified.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => bool"]]}, {"path": "Belt.MutableMap.String", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "toList", "type": "let toList: t('a) => list((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt.MutableMap.String", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt.MutableMap.String", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "minKey", "type": "let minKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "maxKey", "type": "let maxKey: t('a) => option(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('a) => Js.undefined(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "minimum", "type": "let minimum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "minUndefined", "type": "let minUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "maximum", "type": "let maximum: t('a) => option((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "maxUndefined", "type": "let maxUndefined: t('a) => Js.undefined((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.String", "name": "getUndefined", "type": "let getUndefined: (t('a), key) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.String", "name": "getWithDefault", "type": "let getWithDefault: (t('a), key, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt.MutableMap.String", "name": "getExn", "type": "let getExn: (t('a), key) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.String", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.MutableMap.String", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.MutableMap.String", "name": "removeMany", "type": "let removeMany: (t('a), array(key)) => unit", "docs": "<p><code>remove m x</code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "array(key)"]]}, {"path": "Belt.MutableMap.String", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>add m x y</code> do the in-place modification, return <code>m</code> for chaining. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt.MutableMap.String", "name": "updateU", "type": "let updateU: (t('a), key, Js.Internal.fn([ `Arity_1 of 'a46 option ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "Js.Internal.fn([ `Arity_1 of 'a46 option ], option('a))"]]}, {"path": "Belt.MutableMap.String", "name": "update", "type": "let update: (t('a), key, option('a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "option('a) => option('a)"]]}, {"path": "Belt.MutableMap.String", "name": "mapU", "type": "let mapU: (t('a), Js.Internal.fn([ `Arity_1 of 'a45 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a45 ], 'b)"]]}, {"path": "Belt.MutableMap.String", "name": "map", "type": "let map: (t('a), 'a => 'b) => t('b)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "'a => 'b"]]}, {"path": "Belt.MutableMap.String", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a44 ], 'b)) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a44 ], 'b)"]]}, {"path": "Belt.MutableMap.String", "name": "mapWithKey", "type": "let mapWithKey: (t('a), (key, 'a) => 'b) => t('b)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => 'b"]]}, {"path": "Belt.MutableMap", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Belt.MutableMap", "name": "t", "type": "type t('k, 'v, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.MutableMap", "name": "id", "type": "type id('key, 'id) = Belt_Id.comparable('key, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.MutableMap", "name": "make", "type": "let make: (~id: id('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["id", "id('k, 'id)"]]}, {"path": "Belt.MutableMap", "name": "clear", "type": "let clear: t('a, 'a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "isEmpty", "type": "let isEmpty: t('a, 'a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "has", "type": "let has: (t('k, 'a, 'a), 'k) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"], ["", "'k"]]}, {"path": "Belt.MutableMap", "name": "cmpU", "type": "let cmpU: (t('k, 'a, 'id), t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'a43 * 'a43 ], int)) => int", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'a43 * 'a43 ], int)"]]}, {"path": "Belt.MutableMap", "name": "cmp", "type": "let cmp: (t('k, 'a, 'id), t('k, 'a, 'id), ('a, 'a) => int) => int", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["", "('a, 'a) => int"]]}, {"path": "Belt.MutableMap", "name": "eqU", "type": "let eqU: (t('k, 'a, 'id), t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'a42 * 'a42 ], bool)) => bool", "docs": "<p><code>cmp m1 m2 cmp</code> First compare by size, if size is the same, compare by key, value pair</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'a42 * 'a42 ], bool)"]]}, {"path": "Belt.MutableMap", "name": "eq", "type": "let eq: (t('k, 'a, 'id), t('k, 'a, 'id), ('a, 'a) => bool) => bool", "docs": "<p><code>eq m1 m2 eqf</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>eqf</code> is the equality predicate used to compare the data associated with the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "t('k, 'a, 'id)"], ["", "('a, 'a) => bool"]]}, {"path": "Belt.MutableMap", "name": "forEachU", "type": "let forEachU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k4 * 'a41 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k4 * 'a41 ], unit)"]]}, {"path": "Belt.MutableMap", "name": "forEach", "type": "let forEach: (t('k, 'a, 'id), ('k, 'a) => unit) => unit", "docs": "<p><code>forEach m f</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the &#39;k as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => unit"]]}, {"path": "Belt.MutableMap", "name": "reduceU", "type": "let reduceU: (t('k, 'a, 'id), 'b, Js.Internal.fn([ `Arity_3 of 'b11 * 'k3 * 'a40 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_3 of 'b11 * 'k3 * 'a40 ], 'b)"]]}, {"path": "Belt.MutableMap", "name": "reduce", "type": "let reduce: (t('k, 'a, 'id), 'b, ('b, 'k, 'a) => 'b) => 'b", "docs": "<p><code>reduce m a f</code> computes <code>(f kN dN ... (f k1 d1 a)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'b"], ["", "('b, 'k, 'a) => 'b"]]}, {"path": "Belt.MutableMap", "name": "everyU", "type": "let everyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k2 * 'a39 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k2 * 'a39 ], bool)"]]}, {"path": "Belt.MutableMap", "name": "every", "type": "let every: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>every m p</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt.MutableMap", "name": "someU", "type": "let someU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k1 * 'a38 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k1 * 'a38 ], bool)"]]}, {"path": "Belt.MutableMap", "name": "some", "type": "let some: (t('k, 'a, 'id), ('k, 'a) => bool) => bool", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => bool"]]}, {"path": "Belt.MutableMap", "name": "size", "type": "let size: t('k, 'a, 'id) => int", "docs": "<p><code>some m p</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt.MutableMap", "name": "toList", "type": "let toList: t('k, 'a, 'id) => list(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt.MutableMap", "name": "toArray", "type": "let toArray: t('k, 'a, 'id) => array(('k, 'a))", "docs": "<p>In increasing order</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"]]}, {"path": "Belt.MutableMap", "name": "fromArray", "type": "let fromArray: (array(('k, 'a)), ~id: id('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["id", "id('k, 'id)"]]}, {"path": "Belt.MutableMap", "name": "keysToArray", "type": "let keysToArray: t('k, 'a, 'a) => array('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "valuesToArray", "type": "let valuesToArray: t('a, 'a, 'a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "minKey", "type": "let minKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "minKeyUndefined", "type": "let minKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "maxKey", "type": "let maxKey: t('k, 'a, 'a) => option('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "maxKeyUndefined", "type": "let maxKeyUndefined: t('k, 'a, 'a) => Js.undefined('k)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "minimum", "type": "let minimum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "minUndefined", "type": "let minUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "maximum", "type": "let maximum: t('k, 'a, 'a) => option(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "maxUndefined", "type": "let maxUndefined: t('k, 'a, 'a) => Js.undefined(('k, 'a))", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "get", "type": "let get: (t('k, 'a, 'id), 'k) => option('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"]]}, {"path": "Belt.MutableMap", "name": "getUndefined", "type": "let getUndefined: (t('k, 'a, 'id), 'k) => Js.undefined('a)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"]]}, {"path": "Belt.MutableMap", "name": "getWithDefault", "type": "let getWithDefault: (t('k, 'a, 'id), 'k, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "'a"]]}, {"path": "Belt.MutableMap", "name": "getExn", "type": "let getExn: (t('k, 'a, 'id), 'k) => 'a", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"]]}, {"path": "Belt.MutableMap", "name": "checkInvariantInternal", "type": "let checkInvariantInternal: t('a, 'a, 'a) => unit", "docs": "<p><strong>raise</strong> when invariant is not held</p>\n", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.MutableMap", "name": "ofArray", "type": "let ofArray: (array(('k, 'a)), ~id: id('k, 'id)) => t('k, 'a, 'id)", "docs": null, "kind": "value", "args": [["", "array(('k, 'a))"], ["id", "id('k, 'id)"]]}, {"path": "Belt.MutableMap", "name": "remove", "type": "let remove: (t('k, 'a, 'id), 'k) => unit", "docs": "<p><code>remove m x</code> do the in-place modification,</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"]]}, {"path": "Belt.MutableMap", "name": "removeMany", "type": "let removeMany: (t('k, 'a, 'id), array('k)) => unit", "docs": "<p><code>remove m x</code> do the in-place modification,</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "array('k)"]]}, {"path": "Belt.MutableMap", "name": "set", "type": "let set: (t('k, 'a, 'id), 'k, 'a) => unit", "docs": "<p><code>set m x y </code> do the in-place modification</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "'a"]]}, {"path": "Belt.MutableMap", "name": "updateU", "type": "let updateU: (t('k, 'a, 'id), 'k, Js.Internal.fn([ `Arity_1 of 'a37 option ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "Js.Internal.fn([ `Arity_1 of 'a37 option ], option('a))"]]}, {"path": "Belt.MutableMap", "name": "update", "type": "let update: (t('k, 'a, 'id), 'k, option('a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'k"], ["", "option('a) => option('a)"]]}, {"path": "Belt.MutableMap", "name": "mergeMany", "type": "let mergeMany: (t('k, 'a, 'id), array(('k, 'a))) => unit", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "array(('k, 'a))"]]}, {"path": "Belt.MutableMap", "name": "mapU", "type": "let mapU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_1 of 'a36 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'a36 ], 'b)"]]}, {"path": "Belt.MutableMap", "name": "map", "type": "let map: (t('k, 'a, 'id), 'a => 'b) => t('k, 'b, 'id)", "docs": "<p><code>map m f</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p>\n", "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "'a => 'b"]]}, {"path": "Belt.MutableMap", "name": "mapWithKeyU", "type": "let mapWithKeyU: (t('k, 'a, 'id), Js.Internal.fn([ `Arity_2 of 'k0 * 'a35 ], 'b)) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'k0 * 'a35 ], 'b)"]]}, {"path": "Belt.MutableMap", "name": "mapWithKey", "type": "let mapWithKey: (t('k, 'a, 'id), ('k, 'a) => 'b) => t('k, 'b, 'id)", "docs": null, "kind": "value", "args": [["", "t('k, 'a, 'id)"], ["", "('k, 'a) => 'b"]]}, {"path": "Belt", "name": "MutableMap", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>checkInvariantInternal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithKeyU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maximum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minKeyUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minimum\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>someU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>update\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>updateU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt.HashSet.Int", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt.HashSet.Int", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Belt.HashSet.Int", "name": "make", "type": "let make: (~hintSize: int) => t", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt.HashSet.Int", "name": "clear", "type": "let clear: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.Int", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.Int", "name": "add", "type": "let add: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt.HashSet.Int", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.Int", "name": "has", "type": "let has: (t, key) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt.HashSet.Int", "name": "remove", "type": "let remove: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt.HashSet.Int", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of key ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of key ], unit)"]]}, {"path": "Belt.HashSet.Int", "name": "forEach", "type": "let forEach: (t, key => unit) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key => unit"]]}, {"path": "Belt.HashSet.Int", "name": "reduceU", "type": "let reduceU: (t, 'c, Js.Internal.fn([ `Arity_2 of 'c5 * key ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'c5 * key ], 'c)"]]}, {"path": "Belt.HashSet.Int", "name": "reduce", "type": "let reduce: (t, 'c, ('c, key) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "('c, key) => 'c"]]}, {"path": "Belt.HashSet.Int", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.Int", "name": "logStats", "type": "let logStats: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.Int", "name": "toArray", "type": "let toArray: t => array(key)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.Int", "name": "ofArray", "type": "let ofArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt.HashSet.Int", "name": "fromArray", "type": "let fromArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt.HashSet.Int", "name": "mergeMany", "type": "let mergeMany: (t, array(key)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(key)"]]}, {"path": "Belt.HashSet.Int", "name": "getBucketHistogram", "type": "let getBucketHistogram: t => array(int)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt.HashSet.String", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt.HashSet.String", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Belt.HashSet.String", "name": "make", "type": "let make: (~hintSize: int) => t", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt.HashSet.String", "name": "clear", "type": "let clear: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.String", "name": "isEmpty", "type": "let isEmpty: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.String", "name": "add", "type": "let add: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt.HashSet.String", "name": "copy", "type": "let copy: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.String", "name": "has", "type": "let has: (t, key) => bool", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt.HashSet.String", "name": "remove", "type": "let remove: (t, key) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key"]]}, {"path": "Belt.HashSet.String", "name": "forEachU", "type": "let forEachU: (t, Js.Internal.fn([ `Arity_1 of key ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "Js.Internal.fn([ `Arity_1 of key ], unit)"]]}, {"path": "Belt.HashSet.String", "name": "forEach", "type": "let forEach: (t, key => unit) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "key => unit"]]}, {"path": "Belt.HashSet.String", "name": "reduceU", "type": "let reduceU: (t, 'c, Js.Internal.fn([ `Arity_2 of 'c4 * key ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'c4 * key ], 'c)"]]}, {"path": "Belt.HashSet.String", "name": "reduce", "type": "let reduce: (t, 'c, ('c, key) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t"], ["", "'c"], ["", "('c, key) => 'c"]]}, {"path": "Belt.HashSet.String", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.String", "name": "logStats", "type": "let logStats: t => unit", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.String", "name": "toArray", "type": "let toArray: t => array(key)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet.String", "name": "ofArray", "type": "let ofArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt.HashSet.String", "name": "fromArray", "type": "let fromArray: array(key) => t", "docs": null, "kind": "value", "args": [["", "array(key)"]]}, {"path": "Belt.HashSet.String", "name": "mergeMany", "type": "let mergeMany: (t, array(key)) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "array(key)"]]}, {"path": "Belt.HashSet.String", "name": "getBucketHistogram", "type": "let getBucketHistogram: t => array(int)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Belt.HashSet", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt.HashSet", "name": "t", "type": "type t('a, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.HashSet", "name": "id", "type": "type id('a, 'id) = Belt_Id.hashable('a, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.HashSet", "name": "make", "type": "let make: (~hintSize: int, ~id: id('a, 'id)) => t('a, 'id)", "docs": null, "kind": "value", "args": [["hintSize", "int"], ["id", "id('a, 'id)"]]}, {"path": "Belt.HashSet", "name": "clear", "type": "let clear: t('a, 'id) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"]]}, {"path": "Belt.HashSet", "name": "isEmpty", "type": "let isEmpty: t('a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt.HashSet", "name": "add", "type": "let add: (t('a, 'id), 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "'a"]]}, {"path": "Belt.HashSet", "name": "copy", "type": "let copy: t('a, 'id) => t('a, 'id)", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"]]}, {"path": "Belt.HashSet", "name": "has", "type": "let has: (t('a, 'id), 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "'a"]]}, {"path": "Belt.HashSet", "name": "remove", "type": "let remove: (t('a, 'id), 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "'a"]]}, {"path": "Belt.HashSet", "name": "forEachU", "type": "let forEachU: (t('a, 'id), Js.Internal.fn([ `Arity_1 of 'a34 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "Js.Internal.fn([ `Arity_1 of 'a34 ], unit)"]]}, {"path": "Belt.HashSet", "name": "forEach", "type": "let forEach: (t('a, 'id), 'a => unit) => unit", "docs": "<p>Order unspecified.</p>\n", "kind": "value", "args": [["", "t('a, 'id)"], ["", "'a => unit"]]}, {"path": "Belt.HashSet", "name": "reduceU", "type": "let reduceU: (t('a, 'id), 'c, Js.Internal.fn([ `Arity_2 of 'c3 * 'a33 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_2 of 'c3 * 'a33 ], 'c)"]]}, {"path": "Belt.HashSet", "name": "reduce", "type": "let reduce: (t('a, 'id), 'c, ('c, 'a) => 'c) => 'c", "docs": "<p>Order unspecified.</p>\n", "kind": "value", "args": [["", "t('a, 'id)"], ["", "'c"], ["", "('c, 'a) => 'c"]]}, {"path": "Belt.HashSet", "name": "size", "type": "let size: t('a, 'id) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"]]}, {"path": "Belt.HashSet", "name": "logStats", "type": "let logStats: t('a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt.HashSet", "name": "toArray", "type": "let toArray: t('a, 'id) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"]]}, {"path": "Belt.HashSet", "name": "ofArray", "type": "let ofArray: (array('a), ~id: id('a, 'id)) => t('a, 'id)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["id", "id('a, 'id)"]]}, {"path": "Belt.HashSet", "name": "fromArray", "type": "let fromArray: (array('a), ~id: id('a, 'id)) => t('a, 'id)", "docs": null, "kind": "value", "args": [["", "array('a)"], ["id", "id('a, 'id)"]]}, {"path": "Belt.HashSet", "name": "mergeMany", "type": "let mergeMany: (t('a, 'id), array('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'id)"], ["", "array('a)"]]}, {"path": "Belt.HashSet", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a, 'a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a, 'a)"]]}, {"path": "Belt", "name": "HashSet", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt.HashMap.Int", "name": "key", "type": "type key = int", "docs": null, "kind": "type"}, {"path": "Belt.HashMap.Int", "name": "t", "type": "type t('b)", "docs": null, "kind": "type"}, {"path": "Belt.HashMap.Int", "name": "make", "type": "let make: (~hintSize: int) => t('b)", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt.HashMap.Int", "name": "clear", "type": "let clear: t('b) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"]]}, {"path": "Belt.HashMap.Int", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.Int", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>setDone tbl k v</code> if <code>k</code> does not exist, add the binding <code>k,v</code>, otherwise, update the old value with the new <code>v</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt.HashMap.Int", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.Int", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.HashMap.Int", "name": "has", "type": "let has: (t('b), key) => bool", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "key"]]}, {"path": "Belt.HashMap.Int", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.HashMap.Int", "name": "forEachU", "type": "let forEachU: (t('b), Js.Internal.fn([ `Arity_2 of key * 'b10 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'b10 ], unit)"]]}, {"path": "Belt.HashMap.Int", "name": "forEach", "type": "let forEach: (t('b), (key, 'b) => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "(key, 'b) => unit"]]}, {"path": "Belt.HashMap.Int", "name": "reduceU", "type": "let reduceU: (t('b), 'c, Js.Internal.fn([ `Arity_3 of 'c2 * key * 'b9 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c2 * key * 'b9 ], 'c)"]]}, {"path": "Belt.HashMap.Int", "name": "reduce", "type": "let reduce: (t('b), 'c, ('c, key, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "('c, key, 'b) => 'c"]]}, {"path": "Belt.HashMap.Int", "name": "keepMapInPlaceU", "type": "let keepMapInPlaceU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a32 ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a32 ], option('a))"]]}, {"path": "Belt.HashMap.Int", "name": "keepMapInPlace", "type": "let keepMapInPlace: (t('a), (key, 'a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => option('a)"]]}, {"path": "Belt.HashMap.Int", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.Int", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.Int", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.Int", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.Int", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt.HashMap.Int", "name": "mergeMany", "type": "let mergeMany: (t('a), array((key, 'a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "array((key, 'a))"]]}, {"path": "Belt.HashMap.Int", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.Int", "name": "logStats", "type": "let logStats: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.Int", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt.HashMap", "name": "Int", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlaceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>int</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt.HashMap.String", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Belt.HashMap.String", "name": "t", "type": "type t('b)", "docs": null, "kind": "type"}, {"path": "Belt.HashMap.String", "name": "make", "type": "let make: (~hintSize: int) => t('b)", "docs": null, "kind": "value", "args": [["hintSize", "int"]]}, {"path": "Belt.HashMap.String", "name": "clear", "type": "let clear: t('b) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"]]}, {"path": "Belt.HashMap.String", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.String", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>setDone tbl k v</code> if <code>k</code> does not exist, add the binding <code>k,v</code>, otherwise, update the old value with the new <code>v</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Belt.HashMap.String", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.String", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.HashMap.String", "name": "has", "type": "let has: (t('b), key) => bool", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "key"]]}, {"path": "Belt.HashMap.String", "name": "remove", "type": "let remove: (t('a), key) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Belt.HashMap.String", "name": "forEachU", "type": "let forEachU: (t('b), Js.Internal.fn([ `Arity_2 of key * 'b8 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'b8 ], unit)"]]}, {"path": "Belt.HashMap.String", "name": "forEach", "type": "let forEach: (t('b), (key, 'b) => unit) => unit", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "(key, 'b) => unit"]]}, {"path": "Belt.HashMap.String", "name": "reduceU", "type": "let reduceU: (t('b), 'c, Js.Internal.fn([ `Arity_3 of 'c1 * key * 'b7 ], 'c)) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c1 * key * 'b7 ], 'c)"]]}, {"path": "Belt.HashMap.String", "name": "reduce", "type": "let reduce: (t('b), 'c, ('c, key, 'b) => 'c) => 'c", "docs": null, "kind": "value", "args": [["", "t('b)"], ["", "'c"], ["", "('c, key, 'b) => 'c"]]}, {"path": "Belt.HashMap.String", "name": "keepMapInPlaceU", "type": "let keepMapInPlaceU: (t('a), Js.Internal.fn([ `Arity_2 of key * 'a31 ], option('a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_2 of key * 'a31 ], option('a))"]]}, {"path": "Belt.HashMap.String", "name": "keepMapInPlace", "type": "let keepMapInPlace: (t('a), (key, 'a) => option('a)) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "(key, 'a) => option('a)"]]}, {"path": "Belt.HashMap.String", "name": "size", "type": "let size: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.String", "name": "toArray", "type": "let toArray: t('a) => array((key, 'a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.String", "name": "keysToArray", "type": "let keysToArray: t('a) => array(key)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.String", "name": "valuesToArray", "type": "let valuesToArray: t('a) => array('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.String", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt.HashMap.String", "name": "mergeMany", "type": "let mergeMany: (t('a), array((key, 'a))) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "array((key, 'a))"]]}, {"path": "Belt.HashMap.String", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.String", "name": "logStats", "type": "let logStats: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Belt.HashMap.String", "name": "ofArray", "type": "let ofArray: array((key, 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Belt.HashMap", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlaceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Specalized when key type is <code>string</code>, more efficient than the gerneic type</p>\n", "kind": "module"}, {"path": "Belt.HashMap", "name": "t", "type": "type t('key, 'value, 'id)", "docs": "<p>The type of hash tables from type <code>&#39;key</code> to type <code>&#39;value</code>.</p>\n", "kind": "type"}, {"path": "Belt.HashMap", "name": "id", "type": "type id('a, 'id) = Belt_Id.hashable('a, 'id)", "docs": null, "kind": "type"}, {"path": "Belt.HashMap", "name": "make", "type": "let make: (~hintSize: int, ~id: id('key, 'id)) => t('key, 'value, 'id)", "docs": null, "kind": "value", "args": [["hintSize", "int"], ["id", "id('key, 'id)"]]}, {"path": "Belt.HashMap", "name": "clear", "type": "let clear: t('key, 'value, 'id) => unit", "docs": "<p>Empty a hash table.</p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"]]}, {"path": "Belt.HashMap", "name": "isEmpty", "type": "let isEmpty: t('a, 'a, 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.HashMap", "name": "set", "type": "let set: (t('key, 'value, 'id), 'key, 'value) => unit", "docs": "<p><code>set tbl k v</code> if <code>k</code> does not exist, add the binding <code>k,v</code>, otherwise, update the old value with the new <code>v</code></p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'key"], ["", "'value"]]}, {"path": "Belt.HashMap", "name": "copy", "type": "let copy: t('key, 'value, 'id) => t('key, 'value, 'id)", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"]]}, {"path": "Belt.HashMap", "name": "get", "type": "let get: (t('key, 'value, 'id), 'key) => option('value)", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'key"]]}, {"path": "Belt.HashMap", "name": "has", "type": "let has: (t('key, 'value, 'id), 'key) => bool", "docs": "<p><code>has tbl x</code> checks if <code>x</code> is bound in <code>tbl</code>.</p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'key"]]}, {"path": "Belt.HashMap", "name": "remove", "type": "let remove: (t('key, 'value, 'id), 'key) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'key"]]}, {"path": "Belt.HashMap", "name": "forEachU", "type": "let forEachU: (t('key, 'value, 'id), Js.Internal.fn([ `Arity_2 of 'key1 * 'value1 ], unit)) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'key1 * 'value1 ], unit)"]]}, {"path": "Belt.HashMap", "name": "forEach", "type": "let forEach: (t('key, 'value, 'id), ('key, 'value) => unit) => unit", "docs": "<p><code>forEach tbl f</code> applies <code>f</code> to all bindings in table <code>tbl</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to <code>f</code>.</p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "('key, 'value) => unit"]]}, {"path": "Belt.HashMap", "name": "reduceU", "type": "let reduceU: (\n  t('key, 'value, 'id),\n  'c,\n  Js.Internal.fn([ `Arity_3 of 'c0 * 'key0 * 'value0 ], 'c)\n) => 'c", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'c"], ["", "Js.Internal.fn([ `Arity_3 of 'c0 * 'key0 * 'value0 ], 'c)"]]}, {"path": "Belt.HashMap", "name": "reduce", "type": "let reduce: (t('key, 'value, 'id), 'c, ('c, 'key, 'value) => 'c) => 'c", "docs": "<p><code>reduce  tbl init f</code> computes <code>(f kN dN ... (f k1 d1 init)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>tbl</code>, and <code>d1 ... dN</code> are the associated values. Each binding is presented exactly once to <code>f</code>.</p>\n<p>The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p>\n", "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "'c"], ["", "('c, 'key, 'value) => 'c"]]}, {"path": "Belt.HashMap", "name": "keepMapInPlaceU", "type": "let keepMapInPlaceU: (\n  t('key, 'value, 'id),\n  Js.Internal.fn([ `Arity_2 of 'key * 'value ], option('value))\n) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "Js.Internal.fn([ `Arity_2 of 'key * 'value ], option('value))"]]}, {"path": "Belt.HashMap", "name": "keepMapInPlace", "type": "let keepMapInPlace: (t('key, 'value, 'id), ('key, 'value) => option('value)) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "('key, 'value) => option('value)"]]}, {"path": "Belt.HashMap", "name": "size", "type": "let size: t('a, 'a, 'a) => int", "docs": "<p><code>size tbl</code> returns the number of bindings in <code>tbl</code>. It takes constant time.</p>\n", "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.HashMap", "name": "toArray", "type": "let toArray: t('key, 'value, 'id) => array(('key, 'value))", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"]]}, {"path": "Belt.HashMap", "name": "keysToArray", "type": "let keysToArray: t('key, 'a, 'a) => array('key)", "docs": null, "kind": "value", "args": [["", "t('key, 'a, 'a)"]]}, {"path": "Belt.HashMap", "name": "valuesToArray", "type": "let valuesToArray: t('a, 'value, 'a) => array('value)", "docs": null, "kind": "value", "args": [["", "t('a, 'value, 'a)"]]}, {"path": "Belt.HashMap", "name": "fromArray", "type": "let fromArray: (array(('key, 'value)), ~id: id('key, 'id)) => t('key, 'value, 'id)", "docs": null, "kind": "value", "args": [["", "array(('key, 'value))"], ["id", "id('key, 'id)"]]}, {"path": "Belt.HashMap", "name": "mergeMany", "type": "let mergeMany: (t('key, 'value, 'id), array(('key, 'value))) => unit", "docs": null, "kind": "value", "args": [["", "t('key, 'value, 'id)"], ["", "array(('key, 'value))"]]}, {"path": "Belt.HashMap", "name": "getBucketHistogram", "type": "let getBucketHistogram: t('a, 'a, 'a) => array(int)", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.HashMap", "name": "logStats", "type": "let logStats: t('a, 'a, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'a, 'a)"]]}, {"path": "Belt.HashMap", "name": "ofArray", "type": "let ofArray: (array(('key, 'value)), ~id: id('key, 'id)) => t('key, 'value, 'id)", "docs": null, "kind": "value", "args": [["", "array(('key, 'value))"], ["id", "id('key, 'id)"]]}, {"path": "Belt", "name": "HashMap", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getBucketHistogram\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>has\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keepMapInPlaceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keysToArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logStats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mergeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ofArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valuesToArray\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>id\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "Belt.Option", "name": "getExn", "type": "let getExn: option('a) => 'a", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Belt.Option", "name": "mapWithDefaultU", "type": "let mapWithDefaultU: (option('a), 'b, Js.Internal.fn([ `Arity_1 of 'a30 ], 'b)) => 'b", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'b"], ["", "Js.Internal.fn([ `Arity_1 of 'a30 ], 'b)"]]}, {"path": "Belt.Option", "name": "mapWithDefault", "type": "let mapWithDefault: (option('a), 'b, 'a => 'b) => 'b", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'b"], ["", "'a => 'b"]]}, {"path": "Belt.Option", "name": "mapU", "type": "let mapU: (option('a), Js.Internal.fn([ `Arity_1 of 'a29 ], 'b)) => option('b)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a29 ], 'b)"]]}, {"path": "Belt.Option", "name": "map", "type": "let map: (option('a), 'a => 'b) => option('b)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'a => 'b"]]}, {"path": "Belt.Option", "name": "flatMapU", "type": "let flatMapU: (option('a), Js.Internal.fn([ `Arity_1 of 'a28 ], option('b))) => option('b)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a28 ], option('b))"]]}, {"path": "Belt.Option", "name": "flatMap", "type": "let flatMap: (option('a), 'a => option('b)) => option('b)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'a => option('b)"]]}, {"path": "Belt.Option", "name": "getWithDefault", "type": "let getWithDefault: (option('a), 'a) => 'a", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "'a"]]}, {"path": "Belt.Option", "name": "isSome", "type": "let isSome: option('a) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Belt.Option", "name": "isNone", "type": "let isNone: option('a) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Belt.Option", "name": "eqU", "type": "let eqU: (option('a), option('b), Js.Internal.fn([ `Arity_2 of 'a27 * 'b6 ], bool)) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a27 * 'b6 ], bool)"]]}, {"path": "Belt.Option", "name": "eq", "type": "let eq: (option('a), option('b), ('a, 'b) => bool) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('b)"], ["", "('a, 'b) => bool"]]}, {"path": "Belt.Option", "name": "cmpU", "type": "let cmpU: (option('a), option('b), Js.Internal.fn([ `Arity_2 of 'a26 * 'b5 ], int)) => int", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('b)"], ["", "Js.Internal.fn([ `Arity_2 of 'a26 * 'b5 ], int)"]]}, {"path": "Belt.Option", "name": "cmp", "type": "let cmp: (option('a), option('b), ('a, 'b) => int) => int", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('b)"], ["", "('a, 'b) => int"]]}, {"path": "Belt", "name": "Option", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cmpU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatMapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isNone\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSome\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapU\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapWithDefaultU", "docs": null, "kind": "module"}, {"path": "", "name": "Belt", "type": "<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Array\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>HashMap\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>HashSet\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Id\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>List\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Map\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MutableMap\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MutableQueue\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MutableSet\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MutableStack\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Option\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Range\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Set\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>SortArray", "docs": null, "kind": "module"}, {"path": "Weak", "name": "t", "type": "type t('a)", "docs": "<p>The type of arrays of weak pointers (weak arrays). A weak pointer is a value that the garbage collector may erase whenever the value is not used any more (through normal pointers) by the program. Note that finalisation functions are run after the weak pointers are erased.</p>\n<p>A weak pointer is said to be full if it points to a value, empty if the value was erased by the GC.</p>\n<p>Notes:</p>\n<ul><li><p>Integers are not allocated and cannot be stored in weak arrays.</p>\n</li><li><p>Weak arrays cannot be marshaled using output_value nor the functions of the Marshal module.</p>\n</li></ul>", "kind": "type"}, {"path": "Weak", "name": "create", "type": "let create: int => t('a)", "docs": "<p><code>Weak.create n</code> returns a new weak array of length <code>n</code>. All the pointers are initially empty. Raise <code>Invalid_argument</code> if <code>n</code> is negative or greater than max_array_length<code>-1</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Weak", "name": "length", "type": "let length: t('a) => int", "docs": "<p><code>Weak.length ar</code> returns the length (number of elements) of <code>ar</code>.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Weak", "name": "set", "type": "let set: (t('a), int, option('a)) => unit", "docs": "<p><code>Weak.set ar n (Some el)</code> sets the <code>n</code>th cell of <code>ar</code> to be a (full) pointer to <code>el</code>; <code>Weak.set ar n None</code> sets the <code>n</code>th cell of <code>ar</code> to empty. Raise <code>Invalid_argument &quot;Weak.set&quot;</code> if <code>n</code> is not in the range 0 to length<code> a - 1</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"], ["", "option('a)"]]}, {"path": "Weak", "name": "get", "type": "let get: (t('a), int) => option('a)", "docs": "<p><code>Weak.get ar n</code> returns None if the <code>n</code>th cell of <code>ar</code> is empty, <code>Some x</code> (where <code>x</code> is the value) if it is full. Raise <code>Invalid_argument &quot;Weak.get&quot;</code> if <code>n</code> is not in the range 0 to length<code> a - 1</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Weak", "name": "get_copy", "type": "let get_copy: (t('a), int) => option('a)", "docs": "<p><code>Weak.get_copy ar n</code> returns None if the <code>n</code>th cell of <code>ar</code> is empty, <code>Some x</code> (where <code>x</code> is a (shallow) copy of the value) if it is full. In addition to pitfalls with mutable values, the interesting difference with <code>get</code> is that <code>get_copy</code> does not prevent the incremental GC from erasing the value in its current cycle (<code>get</code> may delay the erasure to the next GC cycle). Raise <code>Invalid_argument &quot;Weak.get&quot;</code> if <code>n</code> is not in the range 0 to length<code> a - 1</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Weak", "name": "check", "type": "let check: (t('a), int) => bool", "docs": "<p><code>Weak.check ar n</code> returns <code>true</code> if the <code>n</code>th cell of <code>ar</code> is full, <code>false</code> if it is empty. Note that even if <code>Weak.check ar n</code> returns <code>true</code>, a subsequent get<code> ar n</code> can return <code>None</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Weak", "name": "fill", "type": "let fill: (t('a), int, int, option('a)) => unit", "docs": "<p><code>Weak.fill ar ofs len el</code> sets to <code>el</code> all pointers of <code>ar</code> from <code>ofs</code> to <code>ofs + len - 1</code>. Raise <code>Invalid_argument &quot;Weak.fill&quot;</code> if <code>ofs</code> and <code>len</code> do not designate a valid subarray of <code>a</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"], ["", "int"], ["", "option('a)"]]}, {"path": "Weak", "name": "blit", "type": "let blit: (t('a), int, t('a), int, int) => unit", "docs": "<p><code>Weak.blit ar1 off1 ar2 off2 len</code> copies <code>len</code> weak pointers from <code>ar1</code> (starting at <code>off1</code>) to <code>ar2</code> (starting at <code>off2</code>). It works correctly even if <code>ar1</code> and <code>ar2</code> are the same. Raise <code>Invalid_argument &quot;Weak.blit&quot;</code> if <code>off1</code> and <code>len</code> do not designate a valid subarray of <code>ar1</code>, or if <code>off2</code> and <code>len</code> do not designate a valid subarray of <code>ar2</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"], ["", "t('a)"], ["", "int"], ["", "int"]]}, {"path": "Weak", "name": "Make", "type": "", "docs": null, "kind": "module"}, {"path": "", "name": "Weak", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>check\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Make", "docs": null, "kind": "module"}, {"path": "UnixLabels", "name": "error", "type": "type error = \n  | E2BIG\n  | EACCES\n  | EAGAIN\n  | EBADF\n  | EBUSY\n  | ECHILD\n  | EDEADLK\n  | EDOM\n  | EEXIST\n  | EFAULT\n  | EFBIG\n  | EINTR\n  | EINVAL\n  | EIO\n  | EISDIR\n  | EMFILE\n  | EMLINK\n  | ENAMETOOLONG\n  | ENFILE\n  | ENODEV\n  | ENOENT\n  | ENOEXEC\n  | ENOLCK\n  | ENOMEM\n  | ENOSPC\n  | ENOSYS\n  | ENOTDIR\n  | ENOTEMPTY\n  | ENOTTY\n  | ENXIO\n  | EPERM\n  | EPIPE\n  | ERANGE\n  | EROFS\n  | ESPIPE\n  | ESRCH\n  | EXDEV\n  | EWOULDBLOCK\n  | EINPROGRESS\n  | EALREADY\n  | ENOTSOCK\n  | EDESTADDRREQ\n  | EMSGSIZE\n  | EPROTOTYPE\n  | ENOPROTOOPT\n  | EPROTONOSUPPORT\n  | ESOCKTNOSUPPORT\n  | EOPNOTSUPP\n  | EPFNOSUPPORT\n  | EAFNOSUPPORT\n  | EADDRINUSE\n  | EADDRNOTAVAIL\n  | ENETDOWN\n  | ENETUNREACH\n  | ENETRESET\n  | ECONNABORTED\n  | ECONNRESET\n  | ENOBUFS\n  | EISCONN\n  | ENOTCONN\n  | ESHUTDOWN\n  | ETOOMANYREFS\n  | ETIMEDOUT\n  | ECONNREFUSED\n  | EHOSTDOWN\n  | EHOSTUNREACH\n  | ELOOP\n  | EOVERFLOW\n  | EUNKNOWNERR(int)\n = Unix.error", "docs": "<p>The type of error codes. Errors defined in the POSIX standard and additional errors from UNIX98 and BSD. All other errors are mapped to EUNKNOWNERR.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "error_message", "type": "let error_message: error => string", "docs": "<p>Return a string describing the given error code.</p>\n", "kind": "value", "args": [["", "error"]]}, {"path": "UnixLabels", "name": "handle_unix_error", "type": "let handle_unix_error: ('a => 'b, 'a) => 'b", "docs": "<p><code>handle_unix_error f x</code> applies <code>f</code> to <code>x</code> and returns the result. If the exception <code>Unix_error</code> is raised, it prints a message describing the error and exits with code 2.</p>\n", "kind": "value", "args": [["", "'a => 'b"], ["", "'a"]]}, {"path": "UnixLabels", "name": "environment", "type": "let environment: unit => array(string)", "docs": "<p>Return the process environment, as an array of strings with the format ``variable=value&#39;&#39;.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "getenv", "type": "let getenv: string => string", "docs": "<p>Return the value associated to a variable in the process environment. Raise <code>Not_found</code> if the variable is unbound. (This function is identical to <code>Sys.getenv</code>.)</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "putenv", "type": "let putenv: (string, string) => unit", "docs": "<p><code>Unix.putenv name value</code> sets the value associated to a variable in the process environment. <code>name</code> is the name of the environment variable, and <code>value</code> its new associated value.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "UnixLabels", "name": "process_status", "type": "type process_status = | WEXITED(int) | WSIGNALED(int) | WSTOPPED(int)\n = Unix.process_status", "docs": "<p>The termination status of a process. See module Sys for the definitions of the standard signal numbers. Note that they are not the numbers used by the OS.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "wait_flag", "type": "type wait_flag = | WNOHANG | WUNTRACED\n = Unix.wait_flag", "docs": "<p>Flags for waitpid.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "execv", "type": "let execv: (~prog: string, ~args: array(string)) => 'a", "docs": "<p><code>execv prog args</code> execute the program in file <code>prog</code>, with the arguments <code>args</code>, and the current process environment. These <code>execv*</code> functions never return: on success, the current program is replaced by the new one; on failure, a Unix_error exception is raised.</p>\n", "kind": "value", "args": [["prog", "string"], ["args", "array(string)"]]}, {"path": "UnixLabels", "name": "execve", "type": "let execve: (~prog: string, ~args: array(string), ~env: array(string)) => 'a", "docs": "<p>Same as execv, except that the third argument provides the environment to the program executed.</p>\n", "kind": "value", "args": [["prog", "string"], ["args", "array(string)"], ["env", "array(string)"]]}, {"path": "UnixLabels", "name": "execvp", "type": "let execvp: (~prog: string, ~args: array(string)) => 'a", "docs": "<p>Same as execv, except that the program is searched in the path.</p>\n", "kind": "value", "args": [["prog", "string"], ["args", "array(string)"]]}, {"path": "UnixLabels", "name": "execvpe", "type": "let execvpe: (~prog: string, ~args: array(string), ~env: array(string)) => 'a", "docs": "<p>Same as execve, except that the program is searched in the path.</p>\n", "kind": "value", "args": [["prog", "string"], ["args", "array(string)"], ["env", "array(string)"]]}, {"path": "UnixLabels", "name": "fork", "type": "let fork: unit => int", "docs": "<p>Fork a new process. The returned integer is 0 for the child process, the pid of the child process for the parent process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "wait", "type": "let wait: unit => (int, process_status)", "docs": "<p>Wait until one of the children processes die, and return its pid and termination status.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "waitpid", "type": "let waitpid: (~mode: list(wait_flag), int) => (int, process_status)", "docs": "<p>Same as wait, but waits for the child process whose pid is given. A pid of <code>-1</code> means wait for any child. A pid of <code>0</code> means wait for any child in the same process group as the current process. Negative pid arguments represent process groups. The list of options indicates whether <code>waitpid</code> should return immediately without waiting, or also report stopped children.</p>\n", "kind": "value", "args": [["mode", "list(wait_flag)"], ["", "int"]]}, {"path": "UnixLabels", "name": "system", "type": "let system: string => process_status", "docs": "<p>Execute the given command, wait until it terminates, and return its termination status. The string is interpreted by the shell <code>/bin/sh</code> and therefore can contain redirections, quotes, variables, etc. The result <code>WEXITED 127</code> indicates that the shell couldn&#39;t be executed.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "getpid", "type": "let getpid: unit => int", "docs": "<p>Return the pid of the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "getppid", "type": "let getppid: unit => int", "docs": "<p>Return the pid of the parent process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "nice", "type": "let nice: int => int", "docs": "<p>Change the process priority. The integer argument is added to the ``nice&#39;&#39; value. (Higher values of the ``nice&#39;&#39; value mean lower priorities.) Return the new nice value.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "UnixLabels", "name": "file_descr", "type": "type file_descr = Unix.file_descr", "docs": "<p>The abstract type of file descriptors.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "stdin", "type": "let stdin: file_descr", "docs": "<p>File descriptor for standard input.</p>\n", "kind": "value"}, {"path": "UnixLabels", "name": "stdout", "type": "let stdout: file_descr", "docs": "<p>File descriptor for standard output.</p>\n", "kind": "value"}, {"path": "UnixLabels", "name": "stderr", "type": "let stderr: file_descr", "docs": "<p>File descriptor for standard error.</p>\n", "kind": "value"}, {"path": "UnixLabels", "name": "open_flag", "type": "type open_flag = \n  | O_RDONLY\n  | O_WRONLY\n  | O_RDWR\n  | O_NONBLOCK\n  | O_APPEND\n  | O_CREAT\n  | O_TRUNC\n  | O_EXCL\n  | O_NOCTTY\n  | O_DSYNC\n  | O_SYNC\n  | O_RSYNC\n  | O_SHARE_DELETE\n  | O_CLOEXEC\n = Unix.open_flag", "docs": "<p>The flags to openfile.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "file_perm", "type": "type file_perm = int", "docs": "<p>The type of file access rights, e.g. <code>0o640</code> is read and write for user, read for group, none for others</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "openfile", "type": "let openfile: (string, ~mode: list(open_flag), ~perm: file_perm) => file_descr", "docs": "<p>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created. Return a file descriptor on the named file.</p>\n", "kind": "value", "args": [["", "string"], ["mode", "list(open_flag)"], ["perm", "file_perm"]]}, {"path": "UnixLabels", "name": "close", "type": "let close: file_descr => unit", "docs": "<p>Close a file descriptor.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "read", "type": "let read: (file_descr, ~buf: bytes, ~pos: int, ~len: int) => int", "docs": "<p><code>read fd buff ofs len</code> reads <code>len</code> bytes from descriptor <code>fd</code>, storing them in byte sequence <code>buff</code>, starting at position <code>ofs</code> in <code>buff</code>. Return the number of bytes actually read.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "bytes"], ["pos", "int"], ["len", "int"]]}, {"path": "UnixLabels", "name": "write", "type": "let write: (file_descr, ~buf: bytes, ~pos: int, ~len: int) => int", "docs": "<p><code>write fd buff ofs len</code> writes <code>len</code> bytes to descriptor <code>fd</code>, taking them from byte sequence <code>buff</code>, starting at position <code>ofs</code> in <code>buff</code>. Return the number of bytes actually written. <code>write</code> repeats the writing operation until all bytes have been written or an error occurs.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "bytes"], ["pos", "int"], ["len", "int"]]}, {"path": "UnixLabels", "name": "single_write", "type": "let single_write: (file_descr, ~buf: bytes, ~pos: int, ~len: int) => int", "docs": "<p>Same as <code>write</code>, but attempts to write only once. Thus, if an error occurs, <code>single_write</code> guarantees that no data has been written.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "bytes"], ["pos", "int"], ["len", "int"]]}, {"path": "UnixLabels", "name": "write_substring", "type": "let write_substring: (file_descr, ~buf: string, ~pos: int, ~len: int) => int", "docs": "<p>Same as <code>write</code>, but take the data from a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "string"], ["pos", "int"], ["len", "int"]]}, {"path": "UnixLabels", "name": "single_write_substring", "type": "let single_write_substring: (file_descr, ~buf: string, ~pos: int, ~len: int) => int", "docs": "<p>Same as <code>single_write</code>, but take the data from a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "string"], ["pos", "int"], ["len", "int"]]}, {"path": "UnixLabels", "name": "in_channel_of_descr", "type": "let in_channel_of_descr: file_descr => Pervasives.in_channel", "docs": "<p>Create an input channel reading from the given descriptor. The channel is initially in binary mode; use <code>set_binary_mode_in ic false</code> if text mode is desired.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "out_channel_of_descr", "type": "let out_channel_of_descr: file_descr => Pervasives.out_channel", "docs": "<p>Create an output channel writing on the given descriptor. The channel is initially in binary mode; use <code>set_binary_mode_out oc false</code> if text mode is desired.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "descr_of_in_channel", "type": "let descr_of_in_channel: Pervasives.in_channel => file_descr", "docs": "<p>Return the descriptor corresponding to an input channel.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "UnixLabels", "name": "descr_of_out_channel", "type": "let descr_of_out_channel: Pervasives.out_channel => file_descr", "docs": "<p>Return the descriptor corresponding to an output channel.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"]]}, {"path": "UnixLabels", "name": "seek_command", "type": "type seek_command = | SEEK_SET | SEEK_CUR | SEEK_END\n = Unix.seek_command", "docs": "<p>Positioning modes for lseek.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "lseek", "type": "let lseek: (file_descr, int, ~mode: seek_command) => int", "docs": "<p>Set the current position for a file descriptor, and return the resulting offset (from the beginning of the file).</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "int"], ["mode", "seek_command"]]}, {"path": "UnixLabels", "name": "truncate", "type": "let truncate: (string, ~len: int) => unit", "docs": "<p>Truncates the named file to the given size.</p>\n", "kind": "value", "args": [["", "string"], ["len", "int"]]}, {"path": "UnixLabels", "name": "ftruncate", "type": "let ftruncate: (file_descr, ~len: int) => unit", "docs": "<p>Truncates the file corresponding to the given descriptor to the given size.</p>\n", "kind": "value", "args": [["", "file_descr"], ["len", "int"]]}, {"path": "UnixLabels", "name": "file_kind", "type": "type file_kind = | S_REG | S_DIR | S_CHR | S_BLK | S_LNK | S_FIFO | S_SOCK\n = Unix.file_kind", "docs": null, "kind": "type"}, {"path": "UnixLabels", "name": "stats", "type": "type stats = {\n  st_dev: int,\n  st_ino: int,\n  st_kind: file_kind,\n  st_perm: file_perm,\n  st_nlink: int,\n  st_uid: int,\n  st_gid: int,\n  st_rdev: int,\n  st_size: int,\n  st_atime: float,\n  st_mtime: float,\n  st_ctime: float\n} = Unix.stats", "docs": "<p>The information returned by the stat calls.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "stat", "type": "let stat: string => stats", "docs": "<p>Return the information for the named file.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "lstat", "type": "let lstat: string => stats", "docs": "<p>Same as stat, but in case the file is a symbolic link, return the information for the link itself.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "fstat", "type": "let fstat: file_descr => stats", "docs": "<p>Return the information for the file associated with the given descriptor.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "isatty", "type": "let isatty: file_descr => bool", "docs": "<p>Return <code>true</code> if the given file descriptor refers to a terminal or console window, <code>false</code> otherwise.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels.LargeFile", "name": "lseek", "type": "let lseek: (file_descr, int64, ~mode: seek_command) => int64", "docs": null, "kind": "value", "args": [["", "file_descr"], ["", "int64"], ["mode", "seek_command"]]}, {"path": "UnixLabels.LargeFile", "name": "truncate", "type": "let truncate: (string, ~len: int64) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["len", "int64"]]}, {"path": "UnixLabels.LargeFile", "name": "ftruncate", "type": "let ftruncate: (file_descr, ~len: int64) => unit", "docs": null, "kind": "value", "args": [["", "file_descr"], ["len", "int64"]]}, {"path": "UnixLabels.LargeFile", "name": "stats", "type": "type stats = {\n  st_dev: int,\n  st_ino: int,\n  st_kind: file_kind,\n  st_perm: file_perm,\n  st_nlink: int,\n  st_uid: int,\n  st_gid: int,\n  st_rdev: int,\n  st_size: int64,\n  st_atime: float,\n  st_mtime: float,\n  st_ctime: float\n} = Unix.LargeFile.stats", "docs": null, "kind": "type"}, {"path": "UnixLabels.LargeFile", "name": "stat", "type": "let stat: string => stats", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels.LargeFile", "name": "lstat", "type": "let lstat: string => stats", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels.LargeFile", "name": "fstat", "type": "let fstat: file_descr => stats", "docs": null, "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "LargeFile", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fstat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ftruncate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lseek\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lstat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncate\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>stats", "docs": "<p>File operations on large files. This sub-module provides 64-bit variants of the functions lseek (for positioning a file descriptor), truncate and ftruncate (for changing the size of a file), and stat, lstat and fstat (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type <code>int64</code>) instead of regular integers (type <code>int</code>), thus allowing operating on files whose sizes are greater than <code>max_int</code>.</p>\n", "kind": "module"}, {"path": "UnixLabels", "name": "unlink", "type": "let unlink: string => unit", "docs": "<p>Removes the named file</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "rename", "type": "let rename: (~src: string, ~dst: string) => unit", "docs": "<p><code>rename old new</code> changes the name of a file from <code>old</code> to <code>new</code>.</p>\n", "kind": "value", "args": [["src", "string"], ["dst", "string"]]}, {"path": "UnixLabels", "name": "link", "type": "let link: (~src: string, ~dst: string) => unit", "docs": "<p><code>link source dest</code> creates a hard link named <code>dest</code> to the file named <code>source</code>.</p>\n", "kind": "value", "args": [["src", "string"], ["dst", "string"]]}, {"path": "UnixLabels", "name": "access_permission", "type": "type access_permission = | R_OK | W_OK | X_OK | F_OK\n = Unix.access_permission", "docs": "<p>Flags for the access call.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "chmod", "type": "let chmod: (string, ~perm: file_perm) => unit", "docs": "<p>Change the permissions of the named file.</p>\n", "kind": "value", "args": [["", "string"], ["perm", "file_perm"]]}, {"path": "UnixLabels", "name": "fchmod", "type": "let fchmod: (file_descr, ~perm: file_perm) => unit", "docs": "<p>Change the permissions of an opened file.</p>\n", "kind": "value", "args": [["", "file_descr"], ["perm", "file_perm"]]}, {"path": "UnixLabels", "name": "chown", "type": "let chown: (string, ~uid: int, ~gid: int) => unit", "docs": "<p>Change the owner uid and owner gid of the named file.</p>\n", "kind": "value", "args": [["", "string"], ["uid", "int"], ["gid", "int"]]}, {"path": "UnixLabels", "name": "fchown", "type": "let fchown: (file_descr, ~uid: int, ~gid: int) => unit", "docs": "<p>Change the owner uid and owner gid of an opened file.</p>\n", "kind": "value", "args": [["", "file_descr"], ["uid", "int"], ["gid", "int"]]}, {"path": "UnixLabels", "name": "umask", "type": "let umask: int => int", "docs": "<p>Set the process&#39;s file mode creation mask, and return the previous mask.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "UnixLabels", "name": "access", "type": "let access: (string, ~perm: list(access_permission)) => unit", "docs": "<p>Check that the process has the given permissions over the named file. Raise <code>Unix_error</code> otherwise.</p>\n", "kind": "value", "args": [["", "string"], ["perm", "list(access_permission)"]]}, {"path": "UnixLabels", "name": "dup", "type": "let dup: file_descr => file_descr", "docs": "<p>Return a new file descriptor referencing the same file as the given descriptor.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "dup2", "type": "let dup2: (~src: file_descr, ~dst: file_descr) => unit", "docs": "<p><code>dup2 fd1 fd2</code> duplicates <code>fd1</code> to <code>fd2</code>, closing <code>fd2</code> if already opened.</p>\n", "kind": "value", "args": [["src", "file_descr"], ["dst", "file_descr"]]}, {"path": "UnixLabels", "name": "set_nonblock", "type": "let set_nonblock: file_descr => unit", "docs": "<p>Set the ``non-blocking&#39;&#39; flag on the given descriptor. When the non-blocking flag is set, reading on a descriptor on which there is temporarily no data available raises the <code>EAGAIN</code> or <code>EWOULDBLOCK</code> error instead of blocking; writing on a descriptor on which there is temporarily no room for writing also raises <code>EAGAIN</code> or <code>EWOULDBLOCK</code>.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "clear_nonblock", "type": "let clear_nonblock: file_descr => unit", "docs": "<p>Clear the ``non-blocking&#39;&#39; flag on the given descriptor. See set_nonblock.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "set_close_on_exec", "type": "let set_close_on_exec: file_descr => unit", "docs": "<p>Set the ``close-on-exec&#39;&#39; flag on the given descriptor. A descriptor with the close-on-exec flag is automatically closed when the current process starts another program with one of the <code>exec</code> functions.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "clear_close_on_exec", "type": "let clear_close_on_exec: file_descr => unit", "docs": "<p>Clear the ``close-on-exec&#39;&#39; flag on the given descriptor. See set_close_on_exec.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "mkdir", "type": "let mkdir: (string, ~perm: file_perm) => unit", "docs": "<p>Create a directory with the given permissions.</p>\n", "kind": "value", "args": [["", "string"], ["perm", "file_perm"]]}, {"path": "UnixLabels", "name": "rmdir", "type": "let rmdir: string => unit", "docs": "<p>Remove an empty directory.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "chdir", "type": "let chdir: string => unit", "docs": "<p>Change the process working directory.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "getcwd", "type": "let getcwd: unit => string", "docs": "<p>Return the name of the current working directory.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "chroot", "type": "let chroot: string => unit", "docs": "<p>Change the process root directory.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "dir_handle", "type": "type dir_handle = Unix.dir_handle", "docs": "<p>The type of descriptors over opened directories.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "opendir", "type": "let opendir: string => dir_handle", "docs": "<p>Open a descriptor on a directory</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "readdir", "type": "let readdir: dir_handle => string", "docs": "<p>Return the next entry in a directory.</p>\n<p>Raises: End_of_file<p>when the end of the directory has been reached.</p></p>\n", "kind": "value", "args": [["", "dir_handle"]]}, {"path": "UnixLabels", "name": "rewinddir", "type": "let rewinddir: dir_handle => unit", "docs": "<p>Reposition the descriptor to the beginning of the directory</p>\n", "kind": "value", "args": [["", "dir_handle"]]}, {"path": "UnixLabels", "name": "closedir", "type": "let closedir: dir_handle => unit", "docs": "<p>Close a directory descriptor.</p>\n", "kind": "value", "args": [["", "dir_handle"]]}, {"path": "UnixLabels", "name": "pipe", "type": "let pipe: unit => (file_descr, file_descr)", "docs": "<p>Create a pipe. The first component of the result is opened for reading, that&#39;s the exit to the pipe. The second component is opened for writing, that&#39;s the entrance to the pipe.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "mkfifo", "type": "let mkfifo: (string, ~perm: file_perm) => unit", "docs": "<p>Create a named pipe with the given permissions.</p>\n", "kind": "value", "args": [["", "string"], ["perm", "file_perm"]]}, {"path": "UnixLabels", "name": "create_process", "type": "let create_process: (\n  ~prog: string,\n  ~args: array(string),\n  ~stdin: file_descr,\n  ~stdout: file_descr,\n  ~stderr: file_descr\n) => int", "docs": "<p><code>create_process prog args new_stdin new_stdout new_stderr</code> forks a new process that executes the program in file <code>prog</code>, with arguments <code>args</code>. The pid of the new process is returned immediately; the new process executes concurrently with the current process. The standard input and outputs of the new process are connected to the descriptors <code>new_stdin</code>, <code>new_stdout</code> and <code>new_stderr</code>. Passing e.g. <code>stdout</code> for <code>new_stdout</code> prevents the redirection and causes the new process to have the same standard output as the current process. The executable file <code>prog</code> is searched in the path. The new process has the same environment as the current process.</p>\n", "kind": "value", "args": [["prog", "string"], ["args", "array(string)"], ["stdin", "file_descr"], ["stdout", "file_descr"], ["stderr", "file_descr"]]}, {"path": "UnixLabels", "name": "create_process_env", "type": "let create_process_env: (\n  ~prog: string,\n  ~args: array(string),\n  ~env: array(string),\n  ~stdin: file_descr,\n  ~stdout: file_descr,\n  ~stderr: file_descr\n) => int", "docs": "<p><code>create_process_env prog args env new_stdin new_stdout new_stderr</code> works as create_process, except that the extra argument <code>env</code> specifies the environment passed to the program.</p>\n", "kind": "value", "args": [["prog", "string"], ["args", "array(string)"], ["env", "array(string)"], ["stdin", "file_descr"], ["stdout", "file_descr"], ["stderr", "file_descr"]]}, {"path": "UnixLabels", "name": "open_process_in", "type": "let open_process_in: string => Pervasives.in_channel", "docs": "<p>High-level pipe and process management. This function runs the given command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel. The command is interpreted by the shell <code>/bin/sh</code> (cf. <code>system</code>).</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "open_process_out", "type": "let open_process_out: string => Pervasives.out_channel", "docs": "<p>Same as open_process_in, but redirect the standard input of the command to a pipe. Data written to the returned output channel is sent to the standard input of the command. Warning: writes on output channels are buffered, hence be careful to call flush at the right times to ensure correct synchronization.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "open_process", "type": "let open_process: string => (Pervasives.in_channel, Pervasives.out_channel)", "docs": "<p>Same as open_process_out, but redirects both the standard input and standard output of the command to pipes connected to the two returned channels. The input channel is connected to the output of the command, and the output channel to the input of the command.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "open_process_full", "type": "let open_process_full: (string, ~env: array(string)) => (\n  Pervasives.in_channel,\n  Pervasives.out_channel,\n  Pervasives.in_channel\n)", "docs": "<p>Similar to open_process, but the second argument specifies the environment passed to the command. The result is a triple of channels connected respectively to the standard output, standard input, and standard error of the command.</p>\n", "kind": "value", "args": [["", "string"], ["env", "array(string)"]]}, {"path": "UnixLabels", "name": "close_process_in", "type": "let close_process_in: Pervasives.in_channel => process_status", "docs": "<p>Close channels opened by open_process_in, wait for the associated command to terminate, and return its termination status.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "UnixLabels", "name": "close_process_out", "type": "let close_process_out: Pervasives.out_channel => process_status", "docs": "<p>Close channels opened by open_process_out, wait for the associated command to terminate, and return its termination status.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"]]}, {"path": "UnixLabels", "name": "close_process", "type": "let close_process: (Pervasives.in_channel, Pervasives.out_channel) => process_status", "docs": "<p>Close channels opened by open_process, wait for the associated command to terminate, and return its termination status.</p>\n", "kind": "value", "args": [["", "(Pervasives.in_channel, Pervasives.out_channel)"]]}, {"path": "UnixLabels", "name": "close_process_full", "type": "let close_process_full: (\n  Pervasives.in_channel,\n  Pervasives.out_channel,\n  Pervasives.in_channel\n) => process_status", "docs": "<p>Close channels opened by open_process_full, wait for the associated command to terminate, and return its termination status.</p>\n", "kind": "value", "args": [["", "(Pervasives.in_channel, Pervasives.out_channel, Pervasives.in_channel)"]]}, {"path": "UnixLabels", "name": "symlink", "type": "let symlink: (~src: string, ~dst: string) => unit", "docs": "<p><code>symlink source dest</code> creates the file <code>dest</code> as a symbolic link to the file <code>source</code>.</p>\n", "kind": "value", "args": [["src", "string"], ["dst", "string"]]}, {"path": "UnixLabels", "name": "readlink", "type": "let readlink: string => string", "docs": "<p>Read the contents of a link.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "select", "type": "let select: (\n  ~read: list(file_descr),\n  ~write: list(file_descr),\n  ~except: list(file_descr),\n  ~timeout: float\n) => (list(file_descr), list(file_descr), list(file_descr))", "docs": "<p>Wait until some input/output operations become possible on some channels. The three list arguments are, respectively, a set of descriptors to check for reading (first argument), for writing (second argument), or for exceptional conditions (third argument). The fourth argument is the maximal timeout, in seconds; a negative fourth argument means no timeout (unbounded wait). The result is composed of three sets of descriptors: those ready for reading (first component), ready for writing (second component), and over which an exceptional condition is pending (third component).</p>\n", "kind": "value", "args": [["read", "list(file_descr)"], ["write", "list(file_descr)"], ["except", "list(file_descr)"], ["timeout", "float"]]}, {"path": "UnixLabels", "name": "lock_command", "type": "type lock_command = | F_ULOCK | F_LOCK | F_TLOCK | F_TEST | F_RLOCK | F_TRLOCK\n = Unix.lock_command", "docs": "<p>Commands for lockf.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "lockf", "type": "let lockf: (file_descr, ~mode: lock_command, ~len: int) => unit", "docs": "<p><code>lockf fd cmd size</code> puts a lock on a region of the file opened as <code>fd</code>. The region starts at the current read/write position for <code>fd</code> (as set by lseek), and extends <code>size</code> bytes forward if <code>size</code> is positive, <code>size</code> bytes backwards if <code>size</code> is negative, or to the end of the file if <code>size</code> is zero. A write lock prevents any other process from acquiring a read or write lock on the region. A read lock prevents any other process from acquiring a write lock on the region, but lets other processes acquire read locks on it.</p>\n<p>The <code>F_LOCK</code> and <code>F_TLOCK</code> commands attempts to put a write lock on the specified region. The <code>F_RLOCK</code> and <code>F_TRLOCK</code> commands attempts to put a read lock on the specified region. If one or several locks put by another process prevent the current process from acquiring the lock, <code>F_LOCK</code> and <code>F_RLOCK</code> block until these locks are removed, while <code>F_TLOCK</code> and <code>F_TRLOCK</code> fail immediately with an exception. The <code>F_ULOCK</code> removes whatever locks the current process has on the specified region. Finally, the <code>F_TEST</code> command tests whether a write lock can be acquired on the specified region, without actually putting a lock. It returns immediately if successful, or fails otherwise.</p>\n", "kind": "value", "args": [["", "file_descr"], ["mode", "lock_command"], ["len", "int"]]}, {"path": "UnixLabels", "name": "kill", "type": "let kill: (~pid: int, ~signal: int) => unit", "docs": "<p><code>kill pid sig</code> sends signal number <code>sig</code> to the process with id <code>pid</code>.</p>\n", "kind": "value", "args": [["pid", "int"], ["signal", "int"]]}, {"path": "UnixLabels", "name": "sigprocmask_command", "type": "type sigprocmask_command = | SIG_SETMASK | SIG_BLOCK | SIG_UNBLOCK\n = Unix.sigprocmask_command", "docs": null, "kind": "type"}, {"path": "UnixLabels", "name": "sigprocmask", "type": "let sigprocmask: (~mode: sigprocmask_command, list(int)) => list(int)", "docs": "<p><code>sigprocmask cmd sigs</code> changes the set of blocked signals. If <code>cmd</code> is <code>SIG_SETMASK</code>, blocked signals are set to those in the list <code>sigs</code>. If <code>cmd</code> is <code>SIG_BLOCK</code>, the signals in <code>sigs</code> are added to the set of blocked signals. If <code>cmd</code> is <code>SIG_UNBLOCK</code>, the signals in <code>sigs</code> are removed from the set of blocked signals. <code>sigprocmask</code> returns the set of previously blocked signals.</p>\n", "kind": "value", "args": [["mode", "sigprocmask_command"], ["", "list(int)"]]}, {"path": "UnixLabels", "name": "sigpending", "type": "let sigpending: unit => list(int)", "docs": "<p>Return the set of blocked signals that are currently pending.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "sigsuspend", "type": "let sigsuspend: list(int) => unit", "docs": "<p><code>sigsuspend sigs</code> atomically sets the blocked signals to <code>sigs</code> and waits for a non-ignored, non-blocked signal to be delivered. On return, the blocked signals are reset to their initial value.</p>\n", "kind": "value", "args": [["", "list(int)"]]}, {"path": "UnixLabels", "name": "pause", "type": "let pause: unit => unit", "docs": "<p>Wait until a non-ignored, non-blocked signal is delivered.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "process_times", "type": "type process_times = {\n  tms_utime: float,\n  tms_stime: float,\n  tms_cutime: float,\n  tms_cstime: float\n} = Unix.process_times", "docs": "<p>The execution times (CPU times) of a process.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "tm", "type": "type tm = {\n  tm_sec: int,\n  tm_min: int,\n  tm_hour: int,\n  tm_mday: int,\n  tm_mon: int,\n  tm_year: int,\n  tm_wday: int,\n  tm_yday: int,\n  tm_isdst: bool\n} = Unix.tm", "docs": "<p>The type representing wallclock time and calendar date.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "time", "type": "let time: unit => float", "docs": "<p>Return the current time since 00:00:00 GMT, Jan. 1, 1970, in seconds.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "gettimeofday", "type": "let gettimeofday: unit => float", "docs": "<p>Same as time, but with resolution better than 1 second.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "gmtime", "type": "let gmtime: float => tm", "docs": "<p>Convert a time in seconds, as returned by time, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "UnixLabels", "name": "localtime", "type": "let localtime: float => tm", "docs": "<p>Convert a time in seconds, as returned by time, into a date and a time. Assumes the local time zone.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "UnixLabels", "name": "mktime", "type": "let mktime: tm => (float, tm)", "docs": "<p>Convert a date and time, specified by the <code>tm</code> argument, into a time in seconds, as returned by time. The <code>tm_isdst</code>, <code>tm_wday</code> and <code>tm_yday</code> fields of <code>tm</code> are ignored. Also return a normalized copy of the given <code>tm</code> record, with the <code>tm_wday</code>, <code>tm_yday</code>, and <code>tm_isdst</code> fields recomputed from the other fields, and the other fields normalized (so that, e.g., 40 October is changed into 9 November). The <code>tm</code> argument is interpreted in the local time zone.</p>\n", "kind": "value", "args": [["", "tm"]]}, {"path": "UnixLabels", "name": "alarm", "type": "let alarm: int => int", "docs": "<p>Schedule a <code>SIGALRM</code> signal after the given number of seconds.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "UnixLabels", "name": "sleep", "type": "let sleep: int => unit", "docs": "<p>Stop execution for the given number of seconds.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "UnixLabels", "name": "times", "type": "let times: unit => process_times", "docs": "<p>Return the execution times of the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "utimes", "type": "let utimes: (string, ~access: float, ~modif: float) => unit", "docs": "<p>Set the last access time (second arg) and last modification time (third arg) for a file. Times are expressed in seconds from 00:00:00 GMT, Jan. 1, 1970. A time of <code>0.0</code> is interpreted as the current time.</p>\n", "kind": "value", "args": [["", "string"], ["access", "float"], ["modif", "float"]]}, {"path": "UnixLabels", "name": "interval_timer", "type": "type interval_timer = | ITIMER_REAL | ITIMER_VIRTUAL | ITIMER_PROF\n = Unix.interval_timer", "docs": "<p>The three kinds of interval timers.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "interval_timer_status", "type": "type interval_timer_status = {it_interval: float, it_value: float} = Unix.interval_timer_status", "docs": "<p>The type describing the status of an interval timer</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "getitimer", "type": "let getitimer: interval_timer => interval_timer_status", "docs": "<p>Return the current status of the given interval timer.</p>\n", "kind": "value", "args": [["", "interval_timer"]]}, {"path": "UnixLabels", "name": "setitimer", "type": "let setitimer: (interval_timer, interval_timer_status) => interval_timer_status", "docs": "<p><code>setitimer t s</code> sets the interval timer <code>t</code> and returns its previous status. The <code>s</code> argument is interpreted as follows: <code>s.it_value</code>, if nonzero, is the time to the next timer expiration; <code>s.it_interval</code>, if nonzero, specifies a value to be used in reloading it_value when the timer expires. Setting <code>s.it_value</code> to zero disable the timer. Setting <code>s.it_interval</code> to zero causes the timer to be disabled after its next expiration.</p>\n", "kind": "value", "args": [["", "interval_timer"], ["", "interval_timer_status"]]}, {"path": "UnixLabels", "name": "getuid", "type": "let getuid: unit => int", "docs": "<p>Return the user id of the user executing the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "geteuid", "type": "let geteuid: unit => int", "docs": "<p>Return the effective user id under which the process runs.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "setuid", "type": "let setuid: int => unit", "docs": "<p>Set the real user id and effective user id for the process.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "UnixLabels", "name": "getgid", "type": "let getgid: unit => int", "docs": "<p>Return the group id of the user executing the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "getegid", "type": "let getegid: unit => int", "docs": "<p>Return the effective group id under which the process runs.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "setgid", "type": "let setgid: int => unit", "docs": "<p>Set the real group id and effective group id for the process.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "UnixLabels", "name": "getgroups", "type": "let getgroups: unit => array(int)", "docs": "<p>Return the list of groups to which the user executing the process belongs.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "setgroups", "type": "let setgroups: array(int) => unit", "docs": "<p><code>setgroups groups</code> sets the supplementary group IDs for the calling process. Appropriate privileges are required.</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "UnixLabels", "name": "initgroups", "type": "let initgroups: (string, int) => unit", "docs": "<p><code>initgroups user group</code> initializes the group access list by reading the group database /etc/group and using all groups of which <code>user</code> is a member. The additional group <code>group</code> is also added to the list.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "UnixLabels", "name": "passwd_entry", "type": "type passwd_entry = {\n  pw_name: string,\n  pw_passwd: string,\n  pw_uid: int,\n  pw_gid: int,\n  pw_gecos: string,\n  pw_dir: string,\n  pw_shell: string\n} = Unix.passwd_entry", "docs": "<p>Structure of entries in the <code>passwd</code> database.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "group_entry", "type": "type group_entry = {\n  gr_name: string,\n  gr_passwd: string,\n  gr_gid: int,\n  gr_mem: array(string)\n} = Unix.group_entry", "docs": "<p>Structure of entries in the <code>groups</code> database.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "getlogin", "type": "let getlogin: unit => string", "docs": "<p>Return the login name of the user executing the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "getpwnam", "type": "let getpwnam: string => passwd_entry", "docs": "<p>Find an entry in <code>passwd</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "getgrnam", "type": "let getgrnam: string => group_entry", "docs": "<p>Find an entry in <code>group</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "getpwuid", "type": "let getpwuid: int => passwd_entry", "docs": "<p>Find an entry in <code>passwd</code> with the given user id, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "UnixLabels", "name": "getgrgid", "type": "let getgrgid: int => group_entry", "docs": "<p>Find an entry in <code>group</code> with the given group id, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "UnixLabels", "name": "inet_addr", "type": "type inet_addr = Unix.inet_addr", "docs": "<p>The abstract type of Internet addresses.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "inet_addr_of_string", "type": "let inet_addr_of_string: string => inet_addr", "docs": "<p>Conversion from the printable representation of an Internet address to its internal representation. The argument string consists of 4 numbers separated by periods (<code>XXX.YYY.ZZZ.TTT</code>) for IPv4 addresses, and up to 8 numbers separated by colons for IPv6 addresses. Raise <code>Failure</code> when given a string that does not match these formats.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "string_of_inet_addr", "type": "let string_of_inet_addr: inet_addr => string", "docs": "<p>Return the printable representation of the given Internet address. See inet_addr_of_string for a description of the printable representation.</p>\n", "kind": "value", "args": [["", "inet_addr"]]}, {"path": "UnixLabels", "name": "inet_addr_any", "type": "let inet_addr_any: inet_addr", "docs": "<p>A special IPv4 address, for use only with <code>bind</code>, representing all the Internet addresses that the host machine possesses.</p>\n", "kind": "value"}, {"path": "UnixLabels", "name": "inet_addr_loopback", "type": "let inet_addr_loopback: inet_addr", "docs": "<p>A special IPv4 address representing the host machine (<code>127.0.0.1</code>).</p>\n", "kind": "value"}, {"path": "UnixLabels", "name": "inet6_addr_any", "type": "let inet6_addr_any: inet_addr", "docs": "<p>A special IPv6 address, for use only with <code>bind</code>, representing all the Internet addresses that the host machine possesses.</p>\n", "kind": "value"}, {"path": "UnixLabels", "name": "inet6_addr_loopback", "type": "let inet6_addr_loopback: inet_addr", "docs": "<p>A special IPv6 address representing the host machine (<code>::1</code>).</p>\n", "kind": "value"}, {"path": "UnixLabels", "name": "socket_domain", "type": "type socket_domain = | PF_UNIX | PF_INET | PF_INET6\n = Unix.socket_domain", "docs": "<p>The type of socket domains. Not all platforms support IPv6 sockets (type <code>PF_INET6</code>).</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "socket_type", "type": "type socket_type = | SOCK_STREAM | SOCK_DGRAM | SOCK_RAW | SOCK_SEQPACKET\n = Unix.socket_type", "docs": "<p>The type of socket kinds, specifying the semantics of communications.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "sockaddr", "type": "type sockaddr = | ADDR_UNIX(string) | ADDR_INET(inet_addr, int)\n = Unix.sockaddr", "docs": null, "kind": "type"}, {"path": "UnixLabels", "name": "socket", "type": "let socket: (~domain: socket_domain, ~kind: socket_type, ~protocol: int) => file_descr", "docs": "<p>Create a new socket in the given domain, and with the given kind. The third argument is the protocol type; 0 selects the default protocol for that kind of sockets.</p>\n", "kind": "value", "args": [["domain", "socket_domain"], ["kind", "socket_type"], ["protocol", "int"]]}, {"path": "UnixLabels", "name": "domain_of_sockaddr", "type": "let domain_of_sockaddr: sockaddr => socket_domain", "docs": "<p>Return the socket domain adequate for the given socket address.</p>\n", "kind": "value", "args": [["", "sockaddr"]]}, {"path": "UnixLabels", "name": "socketpair", "type": "let socketpair: (~domain: socket_domain, ~kind: socket_type, ~protocol: int) => (\n  file_descr,\n  file_descr\n)", "docs": "<p>Create a pair of unnamed sockets, connected together.</p>\n", "kind": "value", "args": [["domain", "socket_domain"], ["kind", "socket_type"], ["protocol", "int"]]}, {"path": "UnixLabels", "name": "accept", "type": "let accept: file_descr => (file_descr, sockaddr)", "docs": "<p>Accept connections on the given socket. The returned descriptor is a socket connected to the client; the returned address is the address of the connecting client.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "bind", "type": "let bind: (file_descr, ~addr: sockaddr) => unit", "docs": "<p>Bind a socket to an address.</p>\n", "kind": "value", "args": [["", "file_descr"], ["addr", "sockaddr"]]}, {"path": "UnixLabels", "name": "connect", "type": "let connect: (file_descr, ~addr: sockaddr) => unit", "docs": "<p>Connect a socket to an address.</p>\n", "kind": "value", "args": [["", "file_descr"], ["addr", "sockaddr"]]}, {"path": "UnixLabels", "name": "listen", "type": "let listen: (file_descr, ~max: int) => unit", "docs": "<p>Set up a socket for receiving connection requests. The integer argument is the maximal number of pending requests.</p>\n", "kind": "value", "args": [["", "file_descr"], ["max", "int"]]}, {"path": "UnixLabels", "name": "shutdown_command", "type": "type shutdown_command = | SHUTDOWN_RECEIVE | SHUTDOWN_SEND | SHUTDOWN_ALL\n = Unix.shutdown_command", "docs": "<p>The type of commands for <code>shutdown</code>.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "shutdown", "type": "let shutdown: (file_descr, ~mode: shutdown_command) => unit", "docs": "<p>Shutdown a socket connection. <code>SHUTDOWN_SEND</code> as second argument causes reads on the other end of the connection to return an end-of-file condition. <code>SHUTDOWN_RECEIVE</code> causes writes on the other end of the connection to return a closed pipe condition (<code>SIGPIPE</code> signal).</p>\n", "kind": "value", "args": [["", "file_descr"], ["mode", "shutdown_command"]]}, {"path": "UnixLabels", "name": "getsockname", "type": "let getsockname: file_descr => sockaddr", "docs": "<p>Return the address of the given socket.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "getpeername", "type": "let getpeername: file_descr => sockaddr", "docs": "<p>Return the address of the host connected to the given socket.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "msg_flag", "type": "type msg_flag = | MSG_OOB | MSG_DONTROUTE | MSG_PEEK\n = Unix.msg_flag", "docs": null, "kind": "type"}, {"path": "UnixLabels", "name": "recv", "type": "let recv: (file_descr, ~buf: bytes, ~pos: int, ~len: int, ~mode: list(msg_flag)) => int", "docs": "<p>Receive data from a connected socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "bytes"], ["pos", "int"], ["len", "int"], ["mode", "list(msg_flag)"]]}, {"path": "UnixLabels", "name": "recvfrom", "type": "let recvfrom: (file_descr, ~buf: bytes, ~pos: int, ~len: int, ~mode: list(msg_flag)) => (\n  int,\n  sockaddr\n)", "docs": "<p>Receive data from an unconnected socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "bytes"], ["pos", "int"], ["len", "int"], ["mode", "list(msg_flag)"]]}, {"path": "UnixLabels", "name": "send", "type": "let send: (file_descr, ~buf: bytes, ~pos: int, ~len: int, ~mode: list(msg_flag)) => int", "docs": "<p>Send data over a connected socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "bytes"], ["pos", "int"], ["len", "int"], ["mode", "list(msg_flag)"]]}, {"path": "UnixLabels", "name": "send_substring", "type": "let send_substring: (file_descr, ~buf: string, ~pos: int, ~len: int, ~mode: list(msg_flag)) => int", "docs": "<p>Same as <code>send</code>, but take the data from a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "string"], ["pos", "int"], ["len", "int"], ["mode", "list(msg_flag)"]]}, {"path": "UnixLabels", "name": "sendto", "type": "let sendto: (\n  file_descr,\n  ~buf: bytes,\n  ~pos: int,\n  ~len: int,\n  ~mode: list(msg_flag),\n  ~addr: sockaddr\n) => int", "docs": "<p>Send data over an unconnected socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["buf", "bytes"], ["pos", "int"], ["len", "int"], ["mode", "list(msg_flag)"], ["addr", "sockaddr"]]}, {"path": "UnixLabels", "name": "sendto_substring", "type": "let sendto_substring: (\n  file_descr,\n  ~bug: string,\n  ~pos: int,\n  ~len: int,\n  ~mode: list(msg_flag),\n  sockaddr\n) => int", "docs": "<p>Same as <code>sendto</code>, but take the data from a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "file_descr"], ["bug", "string"], ["pos", "int"], ["len", "int"], ["mode", "list(msg_flag)"], ["", "sockaddr"]]}, {"path": "UnixLabels", "name": "socket_bool_option", "type": "type socket_bool_option = \n  | SO_DEBUG\n  | SO_BROADCAST\n  | SO_REUSEADDR\n  | SO_KEEPALIVE\n  | SO_DONTROUTE\n  | SO_OOBINLINE\n  | SO_ACCEPTCONN\n  | TCP_NODELAY\n  | IPV6_ONLY\n", "docs": "<p>The socket options that can be consulted with getsockopt and modified with setsockopt. These options have a boolean (<code>true</code>/<code>false</code>) value.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "socket_int_option", "type": "type socket_int_option = | SO_SNDBUF | SO_RCVBUF | SO_ERROR | SO_TYPE | SO_RCVLOWAT | SO_SNDLOWAT\n", "docs": "<p>The socket options that can be consulted with getsockopt_int and modified with setsockopt_int. These options have an integer value.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "socket_optint_option", "type": "type socket_optint_option = | SO_LINGER\n", "docs": "<p>The socket options that can be consulted with getsockopt_optint and modified with setsockopt_optint. These options have a value of type <code>int option</code>, with <code>None</code> meaning ``disabled&#39;&#39;.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "socket_float_option", "type": "type socket_float_option = | SO_RCVTIMEO | SO_SNDTIMEO\n", "docs": "<p>The socket options that can be consulted with getsockopt_float and modified with setsockopt_float. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "getsockopt", "type": "let getsockopt: (file_descr, socket_bool_option) => bool", "docs": "<p>Return the current status of a boolean-valued option in the given socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_bool_option"]]}, {"path": "UnixLabels", "name": "setsockopt", "type": "let setsockopt: (file_descr, socket_bool_option, bool) => unit", "docs": "<p>Set or clear a boolean-valued option in the given socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_bool_option"], ["", "bool"]]}, {"path": "UnixLabels", "name": "getsockopt_int", "type": "let getsockopt_int: (file_descr, socket_int_option) => int", "docs": "<p>Same as getsockopt for an integer-valued socket option.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_int_option"]]}, {"path": "UnixLabels", "name": "setsockopt_int", "type": "let setsockopt_int: (file_descr, socket_int_option, int) => unit", "docs": "<p>Same as setsockopt for an integer-valued socket option.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_int_option"], ["", "int"]]}, {"path": "UnixLabels", "name": "getsockopt_optint", "type": "let getsockopt_optint: (file_descr, socket_optint_option) => option(int)", "docs": "<p>Same as getsockopt for a socket option whose value is an <code>int option</code>.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_optint_option"]]}, {"path": "UnixLabels", "name": "setsockopt_optint", "type": "let setsockopt_optint: (file_descr, socket_optint_option, option(int)) => unit", "docs": "<p>Same as setsockopt for a socket option whose value is an <code>int option</code>.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_optint_option"], ["", "option(int)"]]}, {"path": "UnixLabels", "name": "getsockopt_float", "type": "let getsockopt_float: (file_descr, socket_float_option) => float", "docs": "<p>Same as getsockopt for a socket option whose value is a floating-point number.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_float_option"]]}, {"path": "UnixLabels", "name": "setsockopt_float", "type": "let setsockopt_float: (file_descr, socket_float_option, float) => unit", "docs": "<p>Same as setsockopt for a socket option whose value is a floating-point number.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_float_option"], ["", "float"]]}, {"path": "UnixLabels", "name": "getsockopt_error", "type": "let getsockopt_error: file_descr => option(error)", "docs": "<p>Return the error condition associated with the given socket, and clear it.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "open_connection", "type": "let open_connection: sockaddr => (Pervasives.in_channel, Pervasives.out_channel)", "docs": "<p>Connect to a server at the given address. Return a pair of buffered channels connected to the server. Remember to call flush on the output channel at the right times to ensure correct synchronization.</p>\n", "kind": "value", "args": [["", "sockaddr"]]}, {"path": "UnixLabels", "name": "shutdown_connection", "type": "let shutdown_connection: Pervasives.in_channel => unit", "docs": "<p>``Shut down&#39;&#39; a connection established with open_connection; that is, transmit an end-of-file condition to the server reading on the other side of the connection.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "UnixLabels", "name": "establish_server", "type": "let establish_server: (\n  (Pervasives.in_channel, Pervasives.out_channel) => unit,\n  ~addr: sockaddr\n) => unit", "docs": "<p>Establish a server on the given address. The function given as first argument is called for each connection with two buffered channels connected to the client. A new process is created for each connection. The function establish_server never returns normally.</p>\n", "kind": "value", "args": [["", "(Pervasives.in_channel, Pervasives.out_channel) => unit"], ["addr", "sockaddr"]]}, {"path": "UnixLabels", "name": "host_entry", "type": "type host_entry = {\n  h_name: string,\n  h_aliases: array(string),\n  h_addrtype: socket_domain,\n  h_addr_list: array(inet_addr)\n} = Unix.host_entry", "docs": "<p>Structure of entries in the <code>hosts</code> database.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "protocol_entry", "type": "type protocol_entry = {p_name: string, p_aliases: array(string), p_proto: int} = Unix.protocol_entry", "docs": "<p>Structure of entries in the <code>protocols</code> database.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "service_entry", "type": "type service_entry = {\n  s_name: string,\n  s_aliases: array(string),\n  s_port: int,\n  s_proto: string\n} = Unix.service_entry", "docs": "<p>Structure of entries in the <code>services</code> database.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "gethostname", "type": "let gethostname: unit => string", "docs": "<p>Return the name of the local host.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "UnixLabels", "name": "gethostbyname", "type": "let gethostbyname: string => host_entry", "docs": "<p>Find an entry in <code>hosts</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "gethostbyaddr", "type": "let gethostbyaddr: inet_addr => host_entry", "docs": "<p>Find an entry in <code>hosts</code> with the given address, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "inet_addr"]]}, {"path": "UnixLabels", "name": "getprotobyname", "type": "let getprotobyname: string => protocol_entry", "docs": "<p>Find an entry in <code>protocols</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "UnixLabels", "name": "getprotobynumber", "type": "let getprotobynumber: int => protocol_entry", "docs": "<p>Find an entry in <code>protocols</code> with the given protocol number, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "UnixLabels", "name": "getservbyname", "type": "let getservbyname: (string, ~protocol: string) => service_entry", "docs": "<p>Find an entry in <code>services</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"], ["protocol", "string"]]}, {"path": "UnixLabels", "name": "getservbyport", "type": "let getservbyport: (int, ~protocol: string) => service_entry", "docs": "<p>Find an entry in <code>services</code> with the given service number, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "int"], ["protocol", "string"]]}, {"path": "UnixLabels", "name": "addr_info", "type": "type addr_info = {\n  ai_family: socket_domain,\n  ai_socktype: socket_type,\n  ai_protocol: int,\n  ai_addr: sockaddr,\n  ai_canonname: string\n}", "docs": "<p>Address information returned by getaddrinfo.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "getaddrinfo_option", "type": "type getaddrinfo_option = \n  | AI_FAMILY(socket_domain)\n  | AI_SOCKTYPE(socket_type)\n  | AI_PROTOCOL(int)\n  | AI_NUMERICHOST\n  | AI_CANONNAME\n  | AI_PASSIVE\n", "docs": "<p>Options to getaddrinfo.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "getaddrinfo", "type": "let getaddrinfo: (string, string, list(getaddrinfo_option)) => list(addr_info)", "docs": "<p><code>getaddrinfo host service opts</code> returns a list of addr_info records describing socket parameters and addresses suitable for communicating with the given host and service. The empty list is returned if the host or service names are unknown, or the constraints expressed in <code>opts</code> cannot be satisfied.</p>\n<p><code>host</code> is either a host name or the string representation of an IP address. <code>host</code> can be given as the empty string; in this case, the ``any&#39;&#39; address or the ``loopback&#39;&#39; address are used, depending whether <code>opts</code> contains <code>AI_PASSIVE</code>. <code>service</code> is either a service name or the string representation of a port number. <code>service</code> can be given as the empty string; in this case, the port field of the returned addresses is set to 0. <code>opts</code> is a possibly empty list of options that allows the caller to force a particular socket domain (e.g. IPv6 only or IPv4 only) or a particular socket type (e.g. TCP only or UDP only).</p>\n", "kind": "value", "args": [["", "string"], ["", "string"], ["", "list(getaddrinfo_option)"]]}, {"path": "UnixLabels", "name": "name_info", "type": "type name_info = {ni_hostname: string, ni_service: string}", "docs": "<p>Name of service or port number</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "getnameinfo_option", "type": "type getnameinfo_option = | NI_NOFQDN | NI_NUMERICHOST | NI_NAMEREQD | NI_NUMERICSERV | NI_DGRAM\n", "docs": "<p>Options to getnameinfo.</p>\n", "kind": "type"}, {"path": "UnixLabels", "name": "getnameinfo", "type": "let getnameinfo: (sockaddr, list(getnameinfo_option)) => name_info", "docs": "<p><code>getnameinfo addr opts</code> returns the host name and service name corresponding to the socket address <code>addr</code>. <code>opts</code> is a possibly empty list of options that governs how these names are obtained. Raise <code>Not_found</code> if an error occurs.</p>\n", "kind": "value", "args": [["", "sockaddr"], ["", "list(getnameinfo_option)"]]}, {"path": "UnixLabels", "name": "terminal_io", "type": "type terminal_io = {\n  mut c_ignbrk: bool,\n  mut c_brkint: bool,\n  mut c_ignpar: bool,\n  mut c_parmrk: bool,\n  mut c_inpck: bool,\n  mut c_istrip: bool,\n  mut c_inlcr: bool,\n  mut c_igncr: bool,\n  mut c_icrnl: bool,\n  mut c_ixon: bool,\n  mut c_ixoff: bool,\n  mut c_opost: bool,\n  mut c_obaud: int,\n  mut c_ibaud: int,\n  mut c_csize: int,\n  mut c_cstopb: int,\n  mut c_cread: bool,\n  mut c_parenb: bool,\n  mut c_parodd: bool,\n  mut c_hupcl: bool,\n  mut c_clocal: bool,\n  mut c_isig: bool,\n  mut c_icanon: bool,\n  mut c_noflsh: bool,\n  mut c_echo: bool,\n  mut c_echoe: bool,\n  mut c_echok: bool,\n  mut c_echonl: bool,\n  mut c_vintr: char,\n  mut c_vquit: char,\n  mut c_verase: char,\n  mut c_vkill: char,\n  mut c_veof: char,\n  mut c_veol: char,\n  mut c_vmin: int,\n  mut c_vtime: int,\n  mut c_vstart: char,\n  mut c_vstop: char\n} = Unix.terminal_io", "docs": null, "kind": "type"}, {"path": "UnixLabels", "name": "tcgetattr", "type": "let tcgetattr: file_descr => terminal_io", "docs": "<p>Return the status of the terminal referred to by the given file descriptor.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "setattr_when", "type": "type setattr_when = | TCSANOW | TCSADRAIN | TCSAFLUSH\n = Unix.setattr_when", "docs": null, "kind": "type"}, {"path": "UnixLabels", "name": "tcsetattr", "type": "let tcsetattr: (file_descr, ~mode: setattr_when, terminal_io) => unit", "docs": "<p>Set the status of the terminal referred to by the given file descriptor. The second argument indicates when the status change takes place: immediately (<code>TCSANOW</code>), when all pending output has been transmitted (<code>TCSADRAIN</code>), or after flushing all input that has been received but not read (<code>TCSAFLUSH</code>). <code>TCSADRAIN</code> is recommended when changing the output parameters; <code>TCSAFLUSH</code>, when changing the input parameters.</p>\n", "kind": "value", "args": [["", "file_descr"], ["mode", "setattr_when"], ["", "terminal_io"]]}, {"path": "UnixLabels", "name": "tcsendbreak", "type": "let tcsendbreak: (file_descr, ~duration: int) => unit", "docs": "<p>Send a break condition on the given file descriptor. The second argument is the duration of the break, in 0.1s units; 0 means standard duration (0.25s).</p>\n", "kind": "value", "args": [["", "file_descr"], ["duration", "int"]]}, {"path": "UnixLabels", "name": "tcdrain", "type": "let tcdrain: file_descr => unit", "docs": "<p>Waits until all output written on the given file descriptor has been transmitted.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "UnixLabels", "name": "flush_queue", "type": "type flush_queue = | TCIFLUSH | TCOFLUSH | TCIOFLUSH\n = Unix.flush_queue", "docs": null, "kind": "type"}, {"path": "UnixLabels", "name": "tcflush", "type": "let tcflush: (file_descr, ~mode: flush_queue) => unit", "docs": "<p>Discard data written on the given file descriptor but not yet transmitted, or data received but not yet read, depending on the second argument: <code>TCIFLUSH</code> flushes data received but not read, <code>TCOFLUSH</code> flushes data written but not transmitted, and <code>TCIOFLUSH</code> flushes both.</p>\n", "kind": "value", "args": [["", "file_descr"], ["mode", "flush_queue"]]}, {"path": "UnixLabels", "name": "flow_action", "type": "type flow_action = | TCOOFF | TCOON | TCIOFF | TCION\n = Unix.flow_action", "docs": null, "kind": "type"}, {"path": "UnixLabels", "name": "tcflow", "type": "let tcflow: (file_descr, ~mode: flow_action) => unit", "docs": "<p>Suspend or restart reception or transmission of data on the given file descriptor, depending on the second argument: <code>TCOOFF</code> suspends output, <code>TCOON</code> restarts output, <code>TCIOFF</code> transmits a STOP character to suspend input, and <code>TCION</code> transmits a START character to restart input.</p>\n", "kind": "value", "args": [["", "file_descr"], ["mode", "flow_action"]]}, {"path": "UnixLabels", "name": "setsid", "type": "let setsid: unit => int", "docs": "<p>Put the calling process in a new session and detach it from its controlling terminal.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "", "name": "UnixLabels", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>accept\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>access\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>alarm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bind\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chmod\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chown\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chroot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear_close_on_exec\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear_nonblock\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_process\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_process_full\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_process_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_process_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>closedir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>connect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_process\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_process_env\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>descr_of_in_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>descr_of_out_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>domain_of_sockaddr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dup\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dup2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>environment\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>error_message\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>establish_server\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execve\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execvp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execvpe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fchmod\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fchown\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fork\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fstat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ftruncate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getaddrinfo\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getcwd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getegid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getenv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>geteuid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getgid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getgrgid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getgrnam\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getgroups\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gethostbyaddr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gethostbyname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gethostname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getitimer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getlogin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getnameinfo\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getpeername\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getpid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getppid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getprotobyname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getprotobynumber\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getpwnam\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getpwuid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getservbyname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getservbyport\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt_error\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt_optint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gettimeofday\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getuid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gmtime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>handle_unix_error\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>in_channel_of_descr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet6_addr_any\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet6_addr_loopback\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet_addr_any\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet_addr_loopback\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet_addr_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>initgroups\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isatty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>link\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>listen\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>localtime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lockf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lseek\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lstat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mkdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mkfifo\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mktime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_connection\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_process\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_process_full\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_process_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_process_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>opendir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>openfile\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>out_channel_of_descr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pause\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pipe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>putenv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>read\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readlink\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>recv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>recvfrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rename\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rewinddir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rmdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>select\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>send\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>send_substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sendto\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sendto_substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_close_on_exec\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_nonblock\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setgid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setgroups\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setitimer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsockopt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsockopt_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsockopt_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsockopt_optint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setuid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shutdown\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shutdown_connection\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigpending\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigprocmask\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigsuspend\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>single_write\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>single_write_substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sleep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>socket\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>socketpair\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stderr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stdin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stdout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_inet_addr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>symlink\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>system\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcdrain\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcflow\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcflush\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcgetattr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcsendbreak\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcsetattr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>time\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>times\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>umask\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unlink\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utimes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>wait\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>waitpid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>write\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>write_substring\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>access_permission\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>addr_info\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>dir_handle\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>error\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>file_descr\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>file_kind\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>file_perm\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>flow_action\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>flush_queue\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>getaddrinfo_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>getnameinfo_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>group_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>host_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>inet_addr\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>interval_timer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>interval_timer_status\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>lock_command\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>msg_flag\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>name_info\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>open_flag\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>passwd_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>process_status\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>process_times\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>protocol_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>seek_command\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>service_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>setattr_when\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>shutdown_command\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>sigprocmask_command\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>sockaddr\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_bool_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_domain\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_float_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_int_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_optint_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_type\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>stats\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>terminal_io\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>tm\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>wait_flag\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>LargeFile", "docs": null, "kind": "module"}, {"path": "Unix", "name": "error", "type": "type error = \n  | E2BIG\n  | EACCES\n  | EAGAIN\n  | EBADF\n  | EBUSY\n  | ECHILD\n  | EDEADLK\n  | EDOM\n  | EEXIST\n  | EFAULT\n  | EFBIG\n  | EINTR\n  | EINVAL\n  | EIO\n  | EISDIR\n  | EMFILE\n  | EMLINK\n  | ENAMETOOLONG\n  | ENFILE\n  | ENODEV\n  | ENOENT\n  | ENOEXEC\n  | ENOLCK\n  | ENOMEM\n  | ENOSPC\n  | ENOSYS\n  | ENOTDIR\n  | ENOTEMPTY\n  | ENOTTY\n  | ENXIO\n  | EPERM\n  | EPIPE\n  | ERANGE\n  | EROFS\n  | ESPIPE\n  | ESRCH\n  | EXDEV\n  | EWOULDBLOCK\n  | EINPROGRESS\n  | EALREADY\n  | ENOTSOCK\n  | EDESTADDRREQ\n  | EMSGSIZE\n  | EPROTOTYPE\n  | ENOPROTOOPT\n  | EPROTONOSUPPORT\n  | ESOCKTNOSUPPORT\n  | EOPNOTSUPP\n  | EPFNOSUPPORT\n  | EAFNOSUPPORT\n  | EADDRINUSE\n  | EADDRNOTAVAIL\n  | ENETDOWN\n  | ENETUNREACH\n  | ENETRESET\n  | ECONNABORTED\n  | ECONNRESET\n  | ENOBUFS\n  | EISCONN\n  | ENOTCONN\n  | ESHUTDOWN\n  | ETOOMANYREFS\n  | ETIMEDOUT\n  | ECONNREFUSED\n  | EHOSTDOWN\n  | EHOSTUNREACH\n  | ELOOP\n  | EOVERFLOW\n  | EUNKNOWNERR(int)\n", "docs": "<p>The type of error codes. Errors defined in the POSIX standard and additional errors from UNIX98 and BSD. All other errors are mapped to EUNKNOWNERR.</p>\n", "kind": "type"}, {"path": "Unix", "name": "error_message", "type": "let error_message: error => string", "docs": "<p>Return a string describing the given error code.</p>\n", "kind": "value", "args": [["", "error"]]}, {"path": "Unix", "name": "handle_unix_error", "type": "let handle_unix_error: ('a => 'b, 'a) => 'b", "docs": "<p><code>handle_unix_error f x</code> applies <code>f</code> to <code>x</code> and returns the result. If the exception <code>Unix_error</code> is raised, it prints a message describing the error and exits with code 2.</p>\n", "kind": "value", "args": [["", "'a => 'b"], ["", "'a"]]}, {"path": "Unix", "name": "environment", "type": "let environment: unit => array(string)", "docs": "<p>Return the process environment, as an array of strings with the format ``variable=value&#39;&#39;.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "getenv", "type": "let getenv: string => string", "docs": "<p>Return the value associated to a variable in the process environment. Raise <code>Not_found</code> if the variable is unbound. (This function is identical to getenv.)</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "putenv", "type": "let putenv: (string, string) => unit", "docs": "<p><code>Unix.putenv name value</code> sets the value associated to a variable in the process environment. <code>name</code> is the name of the environment variable, and <code>value</code> its new associated value.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Unix", "name": "process_status", "type": "type process_status = | WEXITED(int) | WSIGNALED(int) | WSTOPPED(int)\n", "docs": "<p>The termination status of a process. See module Sys for the definitions of the standard signal numbers. Note that they are not the numbers used by the OS.</p>\n", "kind": "type"}, {"path": "Unix", "name": "wait_flag", "type": "type wait_flag = | WNOHANG | WUNTRACED\n", "docs": "<p>Flags for waitpid.</p>\n", "kind": "type"}, {"path": "Unix", "name": "execv", "type": "let execv: (string, array(string)) => 'a", "docs": "<p><code>execv prog args</code> execute the program in file <code>prog</code>, with the arguments <code>args</code>, and the current process environment. These <code>execv*</code> functions never return: on success, the current program is replaced by the new one; on failure, a Unix_error exception is raised.</p>\n", "kind": "value", "args": [["", "string"], ["", "array(string)"]]}, {"path": "Unix", "name": "execve", "type": "let execve: (string, array(string), array(string)) => 'a", "docs": "<p>Same as execv, except that the third argument provides the environment to the program executed.</p>\n", "kind": "value", "args": [["", "string"], ["", "array(string)"], ["", "array(string)"]]}, {"path": "Unix", "name": "execvp", "type": "let execvp: (string, array(string)) => 'a", "docs": "<p>Same as execv, except that the program is searched in the path.</p>\n", "kind": "value", "args": [["", "string"], ["", "array(string)"]]}, {"path": "Unix", "name": "execvpe", "type": "let execvpe: (string, array(string), array(string)) => 'a", "docs": "<p>Same as execve, except that the program is searched in the path.</p>\n", "kind": "value", "args": [["", "string"], ["", "array(string)"], ["", "array(string)"]]}, {"path": "Unix", "name": "fork", "type": "let fork: unit => int", "docs": "<p>Fork a new process. The returned integer is 0 for the child process, the pid of the child process for the parent process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "wait", "type": "let wait: unit => (int, process_status)", "docs": "<p>Wait until one of the children processes die, and return its pid and termination status.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "waitpid", "type": "let waitpid: (list(wait_flag), int) => (int, process_status)", "docs": "<p>Same as wait, but waits for the child process whose pid is given. A pid of <code>-1</code> means wait for any child. A pid of <code>0</code> means wait for any child in the same process group as the current process. Negative pid arguments represent process groups. The list of options indicates whether <code>waitpid</code> should return immediately without waiting, and whether it should report stopped children.</p>\n", "kind": "value", "args": [["", "list(wait_flag)"], ["", "int"]]}, {"path": "Unix", "name": "system", "type": "let system: string => process_status", "docs": "<p>Execute the given command, wait until it terminates, and return its termination status. The string is interpreted by the shell <code>/bin/sh</code> and therefore can contain redirections, quotes, variables, etc. The result <code>WEXITED 127</code> indicates that the shell couldn&#39;t be executed.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "getpid", "type": "let getpid: unit => int", "docs": "<p>Return the pid of the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "getppid", "type": "let getppid: unit => int", "docs": "<p>Return the pid of the parent process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "nice", "type": "let nice: int => int", "docs": "<p>Change the process priority. The integer argument is added to the ``nice&#39;&#39; value. (Higher values of the ``nice&#39;&#39; value mean lower priorities.) Return the new nice value.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Unix", "name": "file_descr", "type": "type file_descr", "docs": "<p>The abstract type of file descriptors.</p>\n", "kind": "type"}, {"path": "Unix", "name": "stdin", "type": "let stdin: file_descr", "docs": "<p>File descriptor for standard input.</p>\n", "kind": "value"}, {"path": "Unix", "name": "stdout", "type": "let stdout: file_descr", "docs": "<p>File descriptor for standard output.</p>\n", "kind": "value"}, {"path": "Unix", "name": "stderr", "type": "let stderr: file_descr", "docs": "<p>File descriptor for standard error.</p>\n", "kind": "value"}, {"path": "Unix", "name": "open_flag", "type": "type open_flag = \n  | O_RDONLY\n  | O_WRONLY\n  | O_RDWR\n  | O_NONBLOCK\n  | O_APPEND\n  | O_CREAT\n  | O_TRUNC\n  | O_EXCL\n  | O_NOCTTY\n  | O_DSYNC\n  | O_SYNC\n  | O_RSYNC\n  | O_SHARE_DELETE\n  | O_CLOEXEC\n", "docs": "<p>The flags to openfile.</p>\n", "kind": "type"}, {"path": "Unix", "name": "file_perm", "type": "type file_perm = int", "docs": "<p>The type of file access rights, e.g. <code>0o640</code> is read and write for user, read for group, none for others</p>\n", "kind": "type"}, {"path": "Unix", "name": "openfile", "type": "let openfile: (string, list(open_flag), file_perm) => file_descr", "docs": "<p>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created (see umask). Return a file descriptor on the named file.</p>\n", "kind": "value", "args": [["", "string"], ["", "list(open_flag)"], ["", "file_perm"]]}, {"path": "Unix", "name": "close", "type": "let close: file_descr => unit", "docs": "<p>Close a file descriptor.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "read", "type": "let read: (file_descr, bytes, int, int) => int", "docs": "<p><code>read fd buff ofs len</code> reads <code>len</code> bytes from descriptor <code>fd</code>, storing them in byte sequence <code>buff</code>, starting at position <code>ofs</code> in <code>buff</code>. Return the number of bytes actually read.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Unix", "name": "write", "type": "let write: (file_descr, bytes, int, int) => int", "docs": "<p><code>write fd buff ofs len</code> writes <code>len</code> bytes to descriptor <code>fd</code>, taking them from byte sequence <code>buff</code>, starting at position <code>ofs</code> in <code>buff</code>. Return the number of bytes actually written. <code>write</code> repeats the writing operation until all bytes have been written or an error occurs.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Unix", "name": "single_write", "type": "let single_write: (file_descr, bytes, int, int) => int", "docs": "<p>Same as <code>write</code>, but attempts to write only once. Thus, if an error occurs, <code>single_write</code> guarantees that no data has been written.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Unix", "name": "write_substring", "type": "let write_substring: (file_descr, string, int, int) => int", "docs": "<p>Same as <code>write</code>, but take the data from a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "string"], ["", "int"], ["", "int"]]}, {"path": "Unix", "name": "single_write_substring", "type": "let single_write_substring: (file_descr, string, int, int) => int", "docs": "<p>Same as <code>single_write</code>, but take the data from a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "string"], ["", "int"], ["", "int"]]}, {"path": "Unix", "name": "in_channel_of_descr", "type": "let in_channel_of_descr: file_descr => Pervasives.in_channel", "docs": "<p>Create an input channel reading from the given descriptor. The channel is initially in binary mode; use <code>set_binary_mode_in ic false</code> if text mode is desired.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "out_channel_of_descr", "type": "let out_channel_of_descr: file_descr => Pervasives.out_channel", "docs": "<p>Create an output channel writing on the given descriptor. The channel is initially in binary mode; use <code>set_binary_mode_out oc false</code> if text mode is desired.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "descr_of_in_channel", "type": "let descr_of_in_channel: Pervasives.in_channel => file_descr", "docs": "<p>Return the descriptor corresponding to an input channel.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "Unix", "name": "descr_of_out_channel", "type": "let descr_of_out_channel: Pervasives.out_channel => file_descr", "docs": "<p>Return the descriptor corresponding to an output channel.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"]]}, {"path": "Unix", "name": "seek_command", "type": "type seek_command = | SEEK_SET | SEEK_CUR | SEEK_END\n", "docs": "<p>Positioning modes for lseek.</p>\n", "kind": "type"}, {"path": "Unix", "name": "lseek", "type": "let lseek: (file_descr, int, seek_command) => int", "docs": "<p>Set the current position for a file descriptor, and return the resulting offset (from the beginning of the file).</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "int"], ["", "seek_command"]]}, {"path": "Unix", "name": "truncate", "type": "let truncate: (string, int) => unit", "docs": "<p>Truncates the named file to the given size.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "Unix", "name": "ftruncate", "type": "let ftruncate: (file_descr, int) => unit", "docs": "<p>Truncates the file corresponding to the given descriptor to the given size.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "int"]]}, {"path": "Unix", "name": "file_kind", "type": "type file_kind = | S_REG | S_DIR | S_CHR | S_BLK | S_LNK | S_FIFO | S_SOCK\n", "docs": null, "kind": "type"}, {"path": "Unix", "name": "stats", "type": "type stats = {\n  st_dev: int,\n  st_ino: int,\n  st_kind: file_kind,\n  st_perm: file_perm,\n  st_nlink: int,\n  st_uid: int,\n  st_gid: int,\n  st_rdev: int,\n  st_size: int,\n  st_atime: float,\n  st_mtime: float,\n  st_ctime: float\n}", "docs": "<p>The information returned by the stat calls.</p>\n", "kind": "type"}, {"path": "Unix", "name": "stat", "type": "let stat: string => stats", "docs": "<p>Return the information for the named file.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "lstat", "type": "let lstat: string => stats", "docs": "<p>Same as stat, but in case the file is a symbolic link, return the information for the link itself.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "fstat", "type": "let fstat: file_descr => stats", "docs": "<p>Return the information for the file associated with the given descriptor.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "isatty", "type": "let isatty: file_descr => bool", "docs": "<p>Return <code>true</code> if the given file descriptor refers to a terminal or console window, <code>false</code> otherwise.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix.LargeFile", "name": "lseek", "type": "let lseek: (file_descr, int64, seek_command) => int64", "docs": null, "kind": "value", "args": [["", "file_descr"], ["", "int64"], ["", "seek_command"]]}, {"path": "Unix.LargeFile", "name": "truncate", "type": "let truncate: (string, int64) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "int64"]]}, {"path": "Unix.LargeFile", "name": "ftruncate", "type": "let ftruncate: (file_descr, int64) => unit", "docs": null, "kind": "value", "args": [["", "file_descr"], ["", "int64"]]}, {"path": "Unix.LargeFile", "name": "stats", "type": "type stats = {\n  st_dev: int,\n  st_ino: int,\n  st_kind: file_kind,\n  st_perm: file_perm,\n  st_nlink: int,\n  st_uid: int,\n  st_gid: int,\n  st_rdev: int,\n  st_size: int64,\n  st_atime: float,\n  st_mtime: float,\n  st_ctime: float\n}", "docs": null, "kind": "type"}, {"path": "Unix.LargeFile", "name": "stat", "type": "let stat: string => stats", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Unix.LargeFile", "name": "lstat", "type": "let lstat: string => stats", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Unix.LargeFile", "name": "fstat", "type": "let fstat: file_descr => stats", "docs": null, "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "LargeFile", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fstat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ftruncate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lseek\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lstat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncate\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>stats", "docs": "<p>File operations on large files. This sub-module provides 64-bit variants of the functions lseek (for positioning a file descriptor), truncate and ftruncate (for changing the size of a file), and stat, lstat and fstat (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type <code>int64</code>) instead of regular integers (type <code>int</code>), thus allowing operating on files whose sizes are greater than <code>max_int</code>.</p>\n", "kind": "module"}, {"path": "Unix", "name": "unlink", "type": "let unlink: string => unit", "docs": "<p>Removes the named file</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "rename", "type": "let rename: (string, string) => unit", "docs": "<p><code>rename old new</code> changes the name of a file from <code>old</code> to <code>new</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Unix", "name": "link", "type": "let link: (string, string) => unit", "docs": "<p><code>link source dest</code> creates a hard link named <code>dest</code> to the file named <code>source</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Unix", "name": "access_permission", "type": "type access_permission = | R_OK | W_OK | X_OK | F_OK\n", "docs": "<p>Flags for the access call.</p>\n", "kind": "type"}, {"path": "Unix", "name": "chmod", "type": "let chmod: (string, file_perm) => unit", "docs": "<p>Change the permissions of the named file.</p>\n", "kind": "value", "args": [["", "string"], ["", "file_perm"]]}, {"path": "Unix", "name": "fchmod", "type": "let fchmod: (file_descr, file_perm) => unit", "docs": "<p>Change the permissions of an opened file.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "file_perm"]]}, {"path": "Unix", "name": "chown", "type": "let chown: (string, int, int) => unit", "docs": "<p>Change the owner uid and owner gid of the named file.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "int"]]}, {"path": "Unix", "name": "fchown", "type": "let fchown: (file_descr, int, int) => unit", "docs": "<p>Change the owner uid and owner gid of an opened file.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "int"], ["", "int"]]}, {"path": "Unix", "name": "umask", "type": "let umask: int => int", "docs": "<p>Set the process&#39;s file mode creation mask, and return the previous mask.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Unix", "name": "access", "type": "let access: (string, list(access_permission)) => unit", "docs": "<p>Check that the process has the given permissions over the named file. Raise <code>Unix_error</code> otherwise.</p>\n", "kind": "value", "args": [["", "string"], ["", "list(access_permission)"]]}, {"path": "Unix", "name": "dup", "type": "let dup: file_descr => file_descr", "docs": "<p>Return a new file descriptor referencing the same file as the given descriptor.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "dup2", "type": "let dup2: (file_descr, file_descr) => unit", "docs": "<p><code>dup2 fd1 fd2</code> duplicates <code>fd1</code> to <code>fd2</code>, closing <code>fd2</code> if already opened.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "file_descr"]]}, {"path": "Unix", "name": "set_nonblock", "type": "let set_nonblock: file_descr => unit", "docs": "<p>Set the ``non-blocking&#39;&#39; flag on the given descriptor. When the non-blocking flag is set, reading on a descriptor on which there is temporarily no data available raises the <code>EAGAIN</code> or <code>EWOULDBLOCK</code> error instead of blocking; writing on a descriptor on which there is temporarily no room for writing also raises <code>EAGAIN</code> or <code>EWOULDBLOCK</code>.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "clear_nonblock", "type": "let clear_nonblock: file_descr => unit", "docs": "<p>Clear the ``non-blocking&#39;&#39; flag on the given descriptor. See set_nonblock.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "set_close_on_exec", "type": "let set_close_on_exec: file_descr => unit", "docs": "<p>Set the ``close-on-exec&#39;&#39; flag on the given descriptor. A descriptor with the close-on-exec flag is automatically closed when the current process starts another program with one of the <code>exec</code> functions.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "clear_close_on_exec", "type": "let clear_close_on_exec: file_descr => unit", "docs": "<p>Clear the ``close-on-exec&#39;&#39; flag on the given descriptor. See set_close_on_exec.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "mkdir", "type": "let mkdir: (string, file_perm) => unit", "docs": "<p>Create a directory with the given permissions (see umask).</p>\n", "kind": "value", "args": [["", "string"], ["", "file_perm"]]}, {"path": "Unix", "name": "rmdir", "type": "let rmdir: string => unit", "docs": "<p>Remove an empty directory.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "chdir", "type": "let chdir: string => unit", "docs": "<p>Change the process working directory.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "getcwd", "type": "let getcwd: unit => string", "docs": "<p>Return the name of the current working directory.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "chroot", "type": "let chroot: string => unit", "docs": "<p>Change the process root directory.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "dir_handle", "type": "type dir_handle", "docs": "<p>The type of descriptors over opened directories.</p>\n", "kind": "type"}, {"path": "Unix", "name": "opendir", "type": "let opendir: string => dir_handle", "docs": "<p>Open a descriptor on a directory</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "readdir", "type": "let readdir: dir_handle => string", "docs": "<p>Return the next entry in a directory.</p>\n<p>Raises: End_of_file<p>when the end of the directory has been reached.</p></p>\n", "kind": "value", "args": [["", "dir_handle"]]}, {"path": "Unix", "name": "rewinddir", "type": "let rewinddir: dir_handle => unit", "docs": "<p>Reposition the descriptor to the beginning of the directory</p>\n", "kind": "value", "args": [["", "dir_handle"]]}, {"path": "Unix", "name": "closedir", "type": "let closedir: dir_handle => unit", "docs": "<p>Close a directory descriptor.</p>\n", "kind": "value", "args": [["", "dir_handle"]]}, {"path": "Unix", "name": "pipe", "type": "let pipe: unit => (file_descr, file_descr)", "docs": "<p>Create a pipe. The first component of the result is opened for reading, that&#39;s the exit to the pipe. The second component is opened for writing, that&#39;s the entrance to the pipe.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "mkfifo", "type": "let mkfifo: (string, file_perm) => unit", "docs": "<p>Create a named pipe with the given permissions (see umask).</p>\n", "kind": "value", "args": [["", "string"], ["", "file_perm"]]}, {"path": "Unix", "name": "create_process", "type": "let create_process: (string, array(string), file_descr, file_descr, file_descr) => int", "docs": "<p><code>create_process prog args new_stdin new_stdout new_stderr</code> forks a new process that executes the program in file <code>prog</code>, with arguments <code>args</code>. The pid of the new process is returned immediately; the new process executes concurrently with the current process. The standard input and outputs of the new process are connected to the descriptors <code>new_stdin</code>, <code>new_stdout</code> and <code>new_stderr</code>. Passing e.g. <code>stdout</code> for <code>new_stdout</code> prevents the redirection and causes the new process to have the same standard output as the current process. The executable file <code>prog</code> is searched in the path. The new process has the same environment as the current process.</p>\n", "kind": "value", "args": [["", "string"], ["", "array(string)"], ["", "file_descr"], ["", "file_descr"], ["", "file_descr"]]}, {"path": "Unix", "name": "create_process_env", "type": "let create_process_env: (\n  string,\n  array(string),\n  array(string),\n  file_descr,\n  file_descr,\n  file_descr\n) => int", "docs": "<p><code>create_process_env prog args env new_stdin new_stdout new_stderr</code> works as create_process, except that the extra argument <code>env</code> specifies the environment passed to the program.</p>\n", "kind": "value", "args": [["", "string"], ["", "array(string)"], ["", "array(string)"], ["", "file_descr"], ["", "file_descr"], ["", "file_descr"]]}, {"path": "Unix", "name": "open_process_in", "type": "let open_process_in: string => Pervasives.in_channel", "docs": "<p>High-level pipe and process management. This function runs the given command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel. The command is interpreted by the shell <code>/bin/sh</code> (cf. <code>system</code>).</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "open_process_out", "type": "let open_process_out: string => Pervasives.out_channel", "docs": "<p>Same as open_process_in, but redirect the standard input of the command to a pipe. Data written to the returned output channel is sent to the standard input of the command. Warning: writes on output channels are buffered, hence be careful to call flush at the right times to ensure correct synchronization.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "open_process", "type": "let open_process: string => (Pervasives.in_channel, Pervasives.out_channel)", "docs": "<p>Same as open_process_out, but redirects both the standard input and standard output of the command to pipes connected to the two returned channels. The input channel is connected to the output of the command, and the output channel to the input of the command.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "open_process_full", "type": "let open_process_full: (string, array(string)) => (\n  Pervasives.in_channel,\n  Pervasives.out_channel,\n  Pervasives.in_channel\n)", "docs": "<p>Similar to open_process, but the second argument specifies the environment passed to the command. The result is a triple of channels connected respectively to the standard output, standard input, and standard error of the command.</p>\n", "kind": "value", "args": [["", "string"], ["", "array(string)"]]}, {"path": "Unix", "name": "close_process_in", "type": "let close_process_in: Pervasives.in_channel => process_status", "docs": "<p>Close channels opened by open_process_in, wait for the associated command to terminate, and return its termination status.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "Unix", "name": "close_process_out", "type": "let close_process_out: Pervasives.out_channel => process_status", "docs": "<p>Close channels opened by open_process_out, wait for the associated command to terminate, and return its termination status.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"]]}, {"path": "Unix", "name": "close_process", "type": "let close_process: (Pervasives.in_channel, Pervasives.out_channel) => process_status", "docs": "<p>Close channels opened by open_process, wait for the associated command to terminate, and return its termination status.</p>\n", "kind": "value", "args": [["", "(Pervasives.in_channel, Pervasives.out_channel)"]]}, {"path": "Unix", "name": "close_process_full", "type": "let close_process_full: (\n  Pervasives.in_channel,\n  Pervasives.out_channel,\n  Pervasives.in_channel\n) => process_status", "docs": "<p>Close channels opened by open_process_full, wait for the associated command to terminate, and return its termination status.</p>\n", "kind": "value", "args": [["", "(Pervasives.in_channel, Pervasives.out_channel, Pervasives.in_channel)"]]}, {"path": "Unix", "name": "symlink", "type": "let symlink: (string, string) => unit", "docs": "<p><code>symlink source dest</code> creates the file <code>dest</code> as a symbolic link to the file <code>source</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Unix", "name": "readlink", "type": "let readlink: string => string", "docs": "<p>Read the contents of a link.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "select", "type": "let select: (list(file_descr), list(file_descr), list(file_descr), float) => (\n  list(file_descr),\n  list(file_descr),\n  list(file_descr)\n)", "docs": "<p>Wait until some input/output operations become possible on some channels. The three list arguments are, respectively, a set of descriptors to check for reading (first argument), for writing (second argument), or for exceptional conditions (third argument). The fourth argument is the maximal timeout, in seconds; a negative fourth argument means no timeout (unbounded wait). The result is composed of three sets of descriptors: those ready for reading (first component), ready for writing (second component), and over which an exceptional condition is pending (third component).</p>\n", "kind": "value", "args": [["", "list(file_descr)"], ["", "list(file_descr)"], ["", "list(file_descr)"], ["", "float"]]}, {"path": "Unix", "name": "lock_command", "type": "type lock_command = | F_ULOCK | F_LOCK | F_TLOCK | F_TEST | F_RLOCK | F_TRLOCK\n", "docs": "<p>Commands for lockf.</p>\n", "kind": "type"}, {"path": "Unix", "name": "lockf", "type": "let lockf: (file_descr, lock_command, int) => unit", "docs": "<p><code>lockf fd cmd size</code> puts a lock on a region of the file opened as <code>fd</code>. The region starts at the current read/write position for <code>fd</code> (as set by lseek), and extends <code>size</code> bytes forward if <code>size</code> is positive, <code>size</code> bytes backwards if <code>size</code> is negative, or to the end of the file if <code>size</code> is zero. A write lock prevents any other process from acquiring a read or write lock on the region. A read lock prevents any other process from acquiring a write lock on the region, but lets other processes acquire read locks on it.</p>\n<p>The <code>F_LOCK</code> and <code>F_TLOCK</code> commands attempts to put a write lock on the specified region. The <code>F_RLOCK</code> and <code>F_TRLOCK</code> commands attempts to put a read lock on the specified region. If one or several locks put by another process prevent the current process from acquiring the lock, <code>F_LOCK</code> and <code>F_RLOCK</code> block until these locks are removed, while <code>F_TLOCK</code> and <code>F_TRLOCK</code> fail immediately with an exception. The <code>F_ULOCK</code> removes whatever locks the current process has on the specified region. Finally, the <code>F_TEST</code> command tests whether a write lock can be acquired on the specified region, without actually putting a lock. It returns immediately if successful, or fails otherwise.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "lock_command"], ["", "int"]]}, {"path": "Unix", "name": "kill", "type": "let kill: (int, int) => unit", "docs": "<p><code>kill pid sig</code> sends signal number <code>sig</code> to the process with id <code>pid</code>. Under Windows, only the <code>Sys.sigkill</code> signal is emulated.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Unix", "name": "sigprocmask_command", "type": "type sigprocmask_command = | SIG_SETMASK | SIG_BLOCK | SIG_UNBLOCK\n", "docs": null, "kind": "type"}, {"path": "Unix", "name": "sigprocmask", "type": "let sigprocmask: (sigprocmask_command, list(int)) => list(int)", "docs": "<p><code>sigprocmask cmd sigs</code> changes the set of blocked signals. If <code>cmd</code> is <code>SIG_SETMASK</code>, blocked signals are set to those in the list <code>sigs</code>. If <code>cmd</code> is <code>SIG_BLOCK</code>, the signals in <code>sigs</code> are added to the set of blocked signals. If <code>cmd</code> is <code>SIG_UNBLOCK</code>, the signals in <code>sigs</code> are removed from the set of blocked signals. <code>sigprocmask</code> returns the set of previously blocked signals.</p>\n", "kind": "value", "args": [["", "sigprocmask_command"], ["", "list(int)"]]}, {"path": "Unix", "name": "sigpending", "type": "let sigpending: unit => list(int)", "docs": "<p>Return the set of blocked signals that are currently pending.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "sigsuspend", "type": "let sigsuspend: list(int) => unit", "docs": "<p><code>sigsuspend sigs</code> atomically sets the blocked signals to <code>sigs</code> and waits for a non-ignored, non-blocked signal to be delivered. On return, the blocked signals are reset to their initial value.</p>\n", "kind": "value", "args": [["", "list(int)"]]}, {"path": "Unix", "name": "pause", "type": "let pause: unit => unit", "docs": "<p>Wait until a non-ignored, non-blocked signal is delivered.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "process_times", "type": "type process_times = {tms_utime: float, tms_stime: float, tms_cutime: float, tms_cstime: float}", "docs": "<p>The execution times (CPU times) of a process.</p>\n", "kind": "type"}, {"path": "Unix", "name": "tm", "type": "type tm = {\n  tm_sec: int,\n  tm_min: int,\n  tm_hour: int,\n  tm_mday: int,\n  tm_mon: int,\n  tm_year: int,\n  tm_wday: int,\n  tm_yday: int,\n  tm_isdst: bool\n}", "docs": "<p>The type representing wallclock time and calendar date.</p>\n", "kind": "type"}, {"path": "Unix", "name": "time", "type": "let time: unit => float", "docs": "<p>Return the current time since 00:00:00 GMT, Jan. 1, 1970, in seconds.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "gettimeofday", "type": "let gettimeofday: unit => float", "docs": "<p>Same as time, but with resolution better than 1 second.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "gmtime", "type": "let gmtime: float => tm", "docs": "<p>Convert a time in seconds, as returned by time, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Unix", "name": "localtime", "type": "let localtime: float => tm", "docs": "<p>Convert a time in seconds, as returned by time, into a date and a time. Assumes the local time zone.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Unix", "name": "mktime", "type": "let mktime: tm => (float, tm)", "docs": "<p>Convert a date and time, specified by the <code>tm</code> argument, into a time in seconds, as returned by time. The <code>tm_isdst</code>, <code>tm_wday</code> and <code>tm_yday</code> fields of <code>tm</code> are ignored. Also return a normalized copy of the given <code>tm</code> record, with the <code>tm_wday</code>, <code>tm_yday</code>, and <code>tm_isdst</code> fields recomputed from the other fields, and the other fields normalized (so that, e.g., 40 October is changed into 9 November). The <code>tm</code> argument is interpreted in the local time zone.</p>\n", "kind": "value", "args": [["", "tm"]]}, {"path": "Unix", "name": "alarm", "type": "let alarm: int => int", "docs": "<p>Schedule a <code>SIGALRM</code> signal after the given number of seconds.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Unix", "name": "sleep", "type": "let sleep: int => unit", "docs": "<p>Stop execution for the given number of seconds.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Unix", "name": "times", "type": "let times: unit => process_times", "docs": "<p>Return the execution times of the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "utimes", "type": "let utimes: (string, float, float) => unit", "docs": "<p>Set the last access time (second arg) and last modification time (third arg) for a file. Times are expressed in seconds from 00:00:00 GMT, Jan. 1, 1970. A time of <code>0.0</code> is interpreted as the current time.</p>\n", "kind": "value", "args": [["", "string"], ["", "float"], ["", "float"]]}, {"path": "Unix", "name": "interval_timer", "type": "type interval_timer = | ITIMER_REAL | ITIMER_VIRTUAL | ITIMER_PROF\n", "docs": "<p>The three kinds of interval timers.</p>\n", "kind": "type"}, {"path": "Unix", "name": "interval_timer_status", "type": "type interval_timer_status = {it_interval: float, it_value: float}", "docs": "<p>The type describing the status of an interval timer</p>\n", "kind": "type"}, {"path": "Unix", "name": "getitimer", "type": "let getitimer: interval_timer => interval_timer_status", "docs": "<p>Return the current status of the given interval timer.</p>\n", "kind": "value", "args": [["", "interval_timer"]]}, {"path": "Unix", "name": "setitimer", "type": "let setitimer: (interval_timer, interval_timer_status) => interval_timer_status", "docs": "<p><code>setitimer t s</code> sets the interval timer <code>t</code> and returns its previous status. The <code>s</code> argument is interpreted as follows: <code>s.it_value</code>, if nonzero, is the time to the next timer expiration; <code>s.it_interval</code>, if nonzero, specifies a value to be used in reloading <code>it_value</code> when the timer expires. Setting <code>s.it_value</code> to zero disables the timer. Setting <code>s.it_interval</code> to zero causes the timer to be disabled after its next expiration.</p>\n", "kind": "value", "args": [["", "interval_timer"], ["", "interval_timer_status"]]}, {"path": "Unix", "name": "getuid", "type": "let getuid: unit => int", "docs": "<p>Return the user id of the user executing the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "geteuid", "type": "let geteuid: unit => int", "docs": "<p>Return the effective user id under which the process runs.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "setuid", "type": "let setuid: int => unit", "docs": "<p>Set the real user id and effective user id for the process.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Unix", "name": "getgid", "type": "let getgid: unit => int", "docs": "<p>Return the group id of the user executing the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "getegid", "type": "let getegid: unit => int", "docs": "<p>Return the effective group id under which the process runs.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "setgid", "type": "let setgid: int => unit", "docs": "<p>Set the real group id and effective group id for the process.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Unix", "name": "getgroups", "type": "let getgroups: unit => array(int)", "docs": "<p>Return the list of groups to which the user executing the process belongs.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "setgroups", "type": "let setgroups: array(int) => unit", "docs": "<p><code>setgroups groups</code> sets the supplementary group IDs for the calling process. Appropriate privileges are required.</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "Unix", "name": "initgroups", "type": "let initgroups: (string, int) => unit", "docs": "<p><code>initgroups user group</code> initializes the group access list by reading the group database /etc/group and using all groups of which <code>user</code> is a member. The additional group <code>group</code> is also added to the list.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "Unix", "name": "passwd_entry", "type": "type passwd_entry = {\n  pw_name: string,\n  pw_passwd: string,\n  pw_uid: int,\n  pw_gid: int,\n  pw_gecos: string,\n  pw_dir: string,\n  pw_shell: string\n}", "docs": "<p>Structure of entries in the <code>passwd</code> database.</p>\n", "kind": "type"}, {"path": "Unix", "name": "group_entry", "type": "type group_entry = {gr_name: string, gr_passwd: string, gr_gid: int, gr_mem: array(string)}", "docs": "<p>Structure of entries in the <code>groups</code> database.</p>\n", "kind": "type"}, {"path": "Unix", "name": "getlogin", "type": "let getlogin: unit => string", "docs": "<p>Return the login name of the user executing the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "getpwnam", "type": "let getpwnam: string => passwd_entry", "docs": "<p>Find an entry in <code>passwd</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "getgrnam", "type": "let getgrnam: string => group_entry", "docs": "<p>Find an entry in <code>group</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "getpwuid", "type": "let getpwuid: int => passwd_entry", "docs": "<p>Find an entry in <code>passwd</code> with the given user id, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Unix", "name": "getgrgid", "type": "let getgrgid: int => group_entry", "docs": "<p>Find an entry in <code>group</code> with the given group id, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Unix", "name": "inet_addr", "type": "type inet_addr", "docs": "<p>The abstract type of Internet addresses.</p>\n", "kind": "type"}, {"path": "Unix", "name": "inet_addr_of_string", "type": "let inet_addr_of_string: string => inet_addr", "docs": "<p>Conversion from the printable representation of an Internet address to its internal representation. The argument string consists of 4 numbers separated by periods (<code>XXX.YYY.ZZZ.TTT</code>) for IPv4 addresses, and up to 8 numbers separated by colons for IPv6 addresses. Raise <code>Failure</code> when given a string that does not match these formats.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "string_of_inet_addr", "type": "let string_of_inet_addr: inet_addr => string", "docs": "<p>Return the printable representation of the given Internet address. See inet_addr_of_string for a description of the printable representation.</p>\n", "kind": "value", "args": [["", "inet_addr"]]}, {"path": "Unix", "name": "inet_addr_any", "type": "let inet_addr_any: inet_addr", "docs": "<p>A special IPv4 address, for use only with <code>bind</code>, representing all the Internet addresses that the host machine possesses.</p>\n", "kind": "value"}, {"path": "Unix", "name": "inet_addr_loopback", "type": "let inet_addr_loopback: inet_addr", "docs": "<p>A special IPv4 address representing the host machine (<code>127.0.0.1</code>).</p>\n", "kind": "value"}, {"path": "Unix", "name": "inet6_addr_any", "type": "let inet6_addr_any: inet_addr", "docs": "<p>A special IPv6 address, for use only with <code>bind</code>, representing all the Internet addresses that the host machine possesses.</p>\n", "kind": "value"}, {"path": "Unix", "name": "inet6_addr_loopback", "type": "let inet6_addr_loopback: inet_addr", "docs": "<p>A special IPv6 address representing the host machine (<code>::1</code>).</p>\n", "kind": "value"}, {"path": "Unix", "name": "socket_domain", "type": "type socket_domain = | PF_UNIX | PF_INET | PF_INET6\n", "docs": "<p>The type of socket domains. Not all platforms support IPv6 sockets (type <code>PF_INET6</code>).</p>\n", "kind": "type"}, {"path": "Unix", "name": "socket_type", "type": "type socket_type = | SOCK_STREAM | SOCK_DGRAM | SOCK_RAW | SOCK_SEQPACKET\n", "docs": "<p>The type of socket kinds, specifying the semantics of communications.</p>\n", "kind": "type"}, {"path": "Unix", "name": "sockaddr", "type": "type sockaddr = | ADDR_UNIX(string) | ADDR_INET(inet_addr, int)\n", "docs": null, "kind": "type"}, {"path": "Unix", "name": "socket", "type": "let socket: (socket_domain, socket_type, int) => file_descr", "docs": "<p>Create a new socket in the given domain, and with the given kind. The third argument is the protocol type; 0 selects the default protocol for that kind of sockets.</p>\n", "kind": "value", "args": [["", "socket_domain"], ["", "socket_type"], ["", "int"]]}, {"path": "Unix", "name": "domain_of_sockaddr", "type": "let domain_of_sockaddr: sockaddr => socket_domain", "docs": "<p>Return the socket domain adequate for the given socket address.</p>\n", "kind": "value", "args": [["", "sockaddr"]]}, {"path": "Unix", "name": "socketpair", "type": "let socketpair: (socket_domain, socket_type, int) => (file_descr, file_descr)", "docs": "<p>Create a pair of unnamed sockets, connected together.</p>\n", "kind": "value", "args": [["", "socket_domain"], ["", "socket_type"], ["", "int"]]}, {"path": "Unix", "name": "accept", "type": "let accept: file_descr => (file_descr, sockaddr)", "docs": "<p>Accept connections on the given socket. The returned descriptor is a socket connected to the client; the returned address is the address of the connecting client.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "bind", "type": "let bind: (file_descr, sockaddr) => unit", "docs": "<p>Bind a socket to an address.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "sockaddr"]]}, {"path": "Unix", "name": "connect", "type": "let connect: (file_descr, sockaddr) => unit", "docs": "<p>Connect a socket to an address.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "sockaddr"]]}, {"path": "Unix", "name": "listen", "type": "let listen: (file_descr, int) => unit", "docs": "<p>Set up a socket for receiving connection requests. The integer argument is the maximal number of pending requests.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "int"]]}, {"path": "Unix", "name": "shutdown_command", "type": "type shutdown_command = | SHUTDOWN_RECEIVE | SHUTDOWN_SEND | SHUTDOWN_ALL\n", "docs": "<p>The type of commands for <code>shutdown</code>.</p>\n", "kind": "type"}, {"path": "Unix", "name": "shutdown", "type": "let shutdown: (file_descr, shutdown_command) => unit", "docs": "<p>Shutdown a socket connection. <code>SHUTDOWN_SEND</code> as second argument causes reads on the other end of the connection to return an end-of-file condition. <code>SHUTDOWN_RECEIVE</code> causes writes on the other end of the connection to return a closed pipe condition (<code>SIGPIPE</code> signal).</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "shutdown_command"]]}, {"path": "Unix", "name": "getsockname", "type": "let getsockname: file_descr => sockaddr", "docs": "<p>Return the address of the given socket.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "getpeername", "type": "let getpeername: file_descr => sockaddr", "docs": "<p>Return the address of the host connected to the given socket.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "msg_flag", "type": "type msg_flag = | MSG_OOB | MSG_DONTROUTE | MSG_PEEK\n", "docs": null, "kind": "type"}, {"path": "Unix", "name": "recv", "type": "let recv: (file_descr, bytes, int, int, list(msg_flag)) => int", "docs": "<p>Receive data from a connected socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "bytes"], ["", "int"], ["", "int"], ["", "list(msg_flag)"]]}, {"path": "Unix", "name": "recvfrom", "type": "let recvfrom: (file_descr, bytes, int, int, list(msg_flag)) => (int, sockaddr)", "docs": "<p>Receive data from an unconnected socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "bytes"], ["", "int"], ["", "int"], ["", "list(msg_flag)"]]}, {"path": "Unix", "name": "send", "type": "let send: (file_descr, bytes, int, int, list(msg_flag)) => int", "docs": "<p>Send data over a connected socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "bytes"], ["", "int"], ["", "int"], ["", "list(msg_flag)"]]}, {"path": "Unix", "name": "send_substring", "type": "let send_substring: (file_descr, string, int, int, list(msg_flag)) => int", "docs": "<p>Same as <code>send</code>, but take the data from a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "string"], ["", "int"], ["", "int"], ["", "list(msg_flag)"]]}, {"path": "Unix", "name": "sendto", "type": "let sendto: (file_descr, bytes, int, int, list(msg_flag), sockaddr) => int", "docs": "<p>Send data over an unconnected socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "bytes"], ["", "int"], ["", "int"], ["", "list(msg_flag)"], ["", "sockaddr"]]}, {"path": "Unix", "name": "sendto_substring", "type": "let sendto_substring: (file_descr, string, int, int, list(msg_flag), sockaddr) => int", "docs": "<p>Same as <code>sendto</code>, but take the data from a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "string"], ["", "int"], ["", "int"], ["", "list(msg_flag)"], ["", "sockaddr"]]}, {"path": "Unix", "name": "socket_bool_option", "type": "type socket_bool_option = \n  | SO_DEBUG\n  | SO_BROADCAST\n  | SO_REUSEADDR\n  | SO_KEEPALIVE\n  | SO_DONTROUTE\n  | SO_OOBINLINE\n  | SO_ACCEPTCONN\n  | TCP_NODELAY\n  | IPV6_ONLY\n", "docs": "<p>The socket options that can be consulted with getsockopt and modified with setsockopt. These options have a boolean (<code>true</code>/<code>false</code>) value.</p>\n", "kind": "type"}, {"path": "Unix", "name": "socket_int_option", "type": "type socket_int_option = | SO_SNDBUF | SO_RCVBUF | SO_ERROR | SO_TYPE | SO_RCVLOWAT | SO_SNDLOWAT\n", "docs": "<p>The socket options that can be consulted with getsockopt_int and modified with setsockopt_int. These options have an integer value.</p>\n", "kind": "type"}, {"path": "Unix", "name": "socket_optint_option", "type": "type socket_optint_option = | SO_LINGER\n", "docs": "<p>The socket options that can be consulted with getsockopt_optint and modified with setsockopt_optint. These options have a value of type <code>int option</code>, with <code>None</code> meaning ``disabled&#39;&#39;.</p>\n", "kind": "type"}, {"path": "Unix", "name": "socket_float_option", "type": "type socket_float_option = | SO_RCVTIMEO | SO_SNDTIMEO\n", "docs": "<p>The socket options that can be consulted with getsockopt_float and modified with setsockopt_float. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</p>\n", "kind": "type"}, {"path": "Unix", "name": "getsockopt", "type": "let getsockopt: (file_descr, socket_bool_option) => bool", "docs": "<p>Return the current status of a boolean-valued option in the given socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_bool_option"]]}, {"path": "Unix", "name": "setsockopt", "type": "let setsockopt: (file_descr, socket_bool_option, bool) => unit", "docs": "<p>Set or clear a boolean-valued option in the given socket.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_bool_option"], ["", "bool"]]}, {"path": "Unix", "name": "getsockopt_int", "type": "let getsockopt_int: (file_descr, socket_int_option) => int", "docs": "<p>Same as getsockopt for an integer-valued socket option.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_int_option"]]}, {"path": "Unix", "name": "setsockopt_int", "type": "let setsockopt_int: (file_descr, socket_int_option, int) => unit", "docs": "<p>Same as setsockopt for an integer-valued socket option.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_int_option"], ["", "int"]]}, {"path": "Unix", "name": "getsockopt_optint", "type": "let getsockopt_optint: (file_descr, socket_optint_option) => option(int)", "docs": "<p>Same as getsockopt for a socket option whose value is an <code>int option</code>.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_optint_option"]]}, {"path": "Unix", "name": "setsockopt_optint", "type": "let setsockopt_optint: (file_descr, socket_optint_option, option(int)) => unit", "docs": "<p>Same as setsockopt for a socket option whose value is an <code>int option</code>.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_optint_option"], ["", "option(int)"]]}, {"path": "Unix", "name": "getsockopt_float", "type": "let getsockopt_float: (file_descr, socket_float_option) => float", "docs": "<p>Same as getsockopt for a socket option whose value is a floating-point number.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_float_option"]]}, {"path": "Unix", "name": "setsockopt_float", "type": "let setsockopt_float: (file_descr, socket_float_option, float) => unit", "docs": "<p>Same as setsockopt for a socket option whose value is a floating-point number.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "socket_float_option"], ["", "float"]]}, {"path": "Unix", "name": "getsockopt_error", "type": "let getsockopt_error: file_descr => option(error)", "docs": "<p>Return the error condition associated with the given socket, and clear it.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "open_connection", "type": "let open_connection: sockaddr => (Pervasives.in_channel, Pervasives.out_channel)", "docs": "<p>Connect to a server at the given address. Return a pair of buffered channels connected to the server. Remember to call flush on the output channel at the right times to ensure correct synchronization.</p>\n", "kind": "value", "args": [["", "sockaddr"]]}, {"path": "Unix", "name": "shutdown_connection", "type": "let shutdown_connection: Pervasives.in_channel => unit", "docs": "<p>``Shut down&#39;&#39; a connection established with open_connection; that is, transmit an end-of-file condition to the server reading on the other side of the connection. This does not fully close the file descriptor associated with the channel, which you must remember to free via close_in.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "Unix", "name": "establish_server", "type": "let establish_server: ((Pervasives.in_channel, Pervasives.out_channel) => unit, sockaddr) => unit", "docs": "<p>Establish a server on the given address. The function given as first argument is called for each connection with two buffered channels connected to the client. A new process is created for each connection. The function establish_server never returns normally.</p>\n", "kind": "value", "args": [["", "(Pervasives.in_channel, Pervasives.out_channel) => unit"], ["", "sockaddr"]]}, {"path": "Unix", "name": "host_entry", "type": "type host_entry = {\n  h_name: string,\n  h_aliases: array(string),\n  h_addrtype: socket_domain,\n  h_addr_list: array(inet_addr)\n}", "docs": "<p>Structure of entries in the <code>hosts</code> database.</p>\n", "kind": "type"}, {"path": "Unix", "name": "protocol_entry", "type": "type protocol_entry = {p_name: string, p_aliases: array(string), p_proto: int}", "docs": "<p>Structure of entries in the <code>protocols</code> database.</p>\n", "kind": "type"}, {"path": "Unix", "name": "service_entry", "type": "type service_entry = {s_name: string, s_aliases: array(string), s_port: int, s_proto: string}", "docs": "<p>Structure of entries in the <code>services</code> database.</p>\n", "kind": "type"}, {"path": "Unix", "name": "gethostname", "type": "let gethostname: unit => string", "docs": "<p>Return the name of the local host.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Unix", "name": "gethostbyname", "type": "let gethostbyname: string => host_entry", "docs": "<p>Find an entry in <code>hosts</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "gethostbyaddr", "type": "let gethostbyaddr: inet_addr => host_entry", "docs": "<p>Find an entry in <code>hosts</code> with the given address, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "inet_addr"]]}, {"path": "Unix", "name": "getprotobyname", "type": "let getprotobyname: string => protocol_entry", "docs": "<p>Find an entry in <code>protocols</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Unix", "name": "getprotobynumber", "type": "let getprotobynumber: int => protocol_entry", "docs": "<p>Find an entry in <code>protocols</code> with the given protocol number, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Unix", "name": "getservbyname", "type": "let getservbyname: (string, string) => service_entry", "docs": "<p>Find an entry in <code>services</code> with the given name, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Unix", "name": "getservbyport", "type": "let getservbyport: (int, string) => service_entry", "docs": "<p>Find an entry in <code>services</code> with the given service number, or raise <code>Not_found</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "string"]]}, {"path": "Unix", "name": "addr_info", "type": "type addr_info = {\n  ai_family: socket_domain,\n  ai_socktype: socket_type,\n  ai_protocol: int,\n  ai_addr: sockaddr,\n  ai_canonname: string\n}", "docs": "<p>Address information returned by getaddrinfo.</p>\n", "kind": "type"}, {"path": "Unix", "name": "getaddrinfo_option", "type": "type getaddrinfo_option = \n  | AI_FAMILY(socket_domain)\n  | AI_SOCKTYPE(socket_type)\n  | AI_PROTOCOL(int)\n  | AI_NUMERICHOST\n  | AI_CANONNAME\n  | AI_PASSIVE\n", "docs": "<p>Options to getaddrinfo.</p>\n", "kind": "type"}, {"path": "Unix", "name": "getaddrinfo", "type": "let getaddrinfo: (string, string, list(getaddrinfo_option)) => list(addr_info)", "docs": "<p><code>getaddrinfo host service opts</code> returns a list of addr_info records describing socket parameters and addresses suitable for communicating with the given host and service. The empty list is returned if the host or service names are unknown, or the constraints expressed in <code>opts</code> cannot be satisfied.</p>\n<p><code>host</code> is either a host name or the string representation of an IP address. <code>host</code> can be given as the empty string; in this case, the ``any&#39;&#39; address or the ``loopback&#39;&#39; address are used, depending whether <code>opts</code> contains <code>AI_PASSIVE</code>. <code>service</code> is either a service name or the string representation of a port number. <code>service</code> can be given as the empty string; in this case, the port field of the returned addresses is set to 0. <code>opts</code> is a possibly empty list of options that allows the caller to force a particular socket domain (e.g. IPv6 only or IPv4 only) or a particular socket type (e.g. TCP only or UDP only).</p>\n", "kind": "value", "args": [["", "string"], ["", "string"], ["", "list(getaddrinfo_option)"]]}, {"path": "Unix", "name": "name_info", "type": "type name_info = {ni_hostname: string, ni_service: string}", "docs": "<p>Name of service or port number</p>\n", "kind": "type"}, {"path": "Unix", "name": "getnameinfo_option", "type": "type getnameinfo_option = | NI_NOFQDN | NI_NUMERICHOST | NI_NAMEREQD | NI_NUMERICSERV | NI_DGRAM\n", "docs": "<p>Options to getnameinfo.</p>\n", "kind": "type"}, {"path": "Unix", "name": "getnameinfo", "type": "let getnameinfo: (sockaddr, list(getnameinfo_option)) => name_info", "docs": "<p><code>getnameinfo addr opts</code> returns the host name and service name corresponding to the socket address <code>addr</code>. <code>opts</code> is a possibly empty list of options that governs how these names are obtained. Raise <code>Not_found</code> if an error occurs.</p>\n", "kind": "value", "args": [["", "sockaddr"], ["", "list(getnameinfo_option)"]]}, {"path": "Unix", "name": "terminal_io", "type": "type terminal_io = {\n  mut c_ignbrk: bool,\n  mut c_brkint: bool,\n  mut c_ignpar: bool,\n  mut c_parmrk: bool,\n  mut c_inpck: bool,\n  mut c_istrip: bool,\n  mut c_inlcr: bool,\n  mut c_igncr: bool,\n  mut c_icrnl: bool,\n  mut c_ixon: bool,\n  mut c_ixoff: bool,\n  mut c_opost: bool,\n  mut c_obaud: int,\n  mut c_ibaud: int,\n  mut c_csize: int,\n  mut c_cstopb: int,\n  mut c_cread: bool,\n  mut c_parenb: bool,\n  mut c_parodd: bool,\n  mut c_hupcl: bool,\n  mut c_clocal: bool,\n  mut c_isig: bool,\n  mut c_icanon: bool,\n  mut c_noflsh: bool,\n  mut c_echo: bool,\n  mut c_echoe: bool,\n  mut c_echok: bool,\n  mut c_echonl: bool,\n  mut c_vintr: char,\n  mut c_vquit: char,\n  mut c_verase: char,\n  mut c_vkill: char,\n  mut c_veof: char,\n  mut c_veol: char,\n  mut c_vmin: int,\n  mut c_vtime: int,\n  mut c_vstart: char,\n  mut c_vstop: char\n}", "docs": null, "kind": "type"}, {"path": "Unix", "name": "tcgetattr", "type": "let tcgetattr: file_descr => terminal_io", "docs": "<p>Return the status of the terminal referred to by the given file descriptor.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "setattr_when", "type": "type setattr_when = | TCSANOW | TCSADRAIN | TCSAFLUSH\n", "docs": null, "kind": "type"}, {"path": "Unix", "name": "tcsetattr", "type": "let tcsetattr: (file_descr, setattr_when, terminal_io) => unit", "docs": "<p>Set the status of the terminal referred to by the given file descriptor. The second argument indicates when the status change takes place: immediately (<code>TCSANOW</code>), when all pending output has been transmitted (<code>TCSADRAIN</code>), or after flushing all input that has been received but not read (<code>TCSAFLUSH</code>). <code>TCSADRAIN</code> is recommended when changing the output parameters; <code>TCSAFLUSH</code>, when changing the input parameters.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "setattr_when"], ["", "terminal_io"]]}, {"path": "Unix", "name": "tcsendbreak", "type": "let tcsendbreak: (file_descr, int) => unit", "docs": "<p>Send a break condition on the given file descriptor. The second argument is the duration of the break, in 0.1s units; 0 means standard duration (0.25s).</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "int"]]}, {"path": "Unix", "name": "tcdrain", "type": "let tcdrain: file_descr => unit", "docs": "<p>Waits until all output written on the given file descriptor has been transmitted.</p>\n", "kind": "value", "args": [["", "file_descr"]]}, {"path": "Unix", "name": "flush_queue", "type": "type flush_queue = | TCIFLUSH | TCOFLUSH | TCIOFLUSH\n", "docs": null, "kind": "type"}, {"path": "Unix", "name": "tcflush", "type": "let tcflush: (file_descr, flush_queue) => unit", "docs": "<p>Discard data written on the given file descriptor but not yet transmitted, or data received but not yet read, depending on the second argument: <code>TCIFLUSH</code> flushes data received but not read, <code>TCOFLUSH</code> flushes data written but not transmitted, and <code>TCIOFLUSH</code> flushes both.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "flush_queue"]]}, {"path": "Unix", "name": "flow_action", "type": "type flow_action = | TCOOFF | TCOON | TCIOFF | TCION\n", "docs": null, "kind": "type"}, {"path": "Unix", "name": "tcflow", "type": "let tcflow: (file_descr, flow_action) => unit", "docs": "<p>Suspend or restart reception or transmission of data on the given file descriptor, depending on the second argument: <code>TCOOFF</code> suspends output, <code>TCOON</code> restarts output, <code>TCIOFF</code> transmits a STOP character to suspend input, and <code>TCION</code> transmits a START character to restart input.</p>\n", "kind": "value", "args": [["", "file_descr"], ["", "flow_action"]]}, {"path": "Unix", "name": "setsid", "type": "let setsid: unit => int", "docs": "<p>Put the calling process in a new session and detach it from its controlling terminal.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "", "name": "Unix", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>accept\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>access\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>alarm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bind\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chmod\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chown\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chroot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear_close_on_exec\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear_nonblock\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_process\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_process_full\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_process_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_process_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>closedir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>connect\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_process\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_process_env\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>descr_of_in_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>descr_of_out_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>domain_of_sockaddr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dup\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dup2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>environment\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>error_message\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>establish_server\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execve\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execvp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>execvpe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fchmod\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fchown\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fork\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fstat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ftruncate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getaddrinfo\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getcwd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getegid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getenv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>geteuid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getgid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getgrgid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getgrnam\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getgroups\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gethostbyaddr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gethostbyname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gethostname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getitimer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getlogin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getnameinfo\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getpeername\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getpid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getppid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getprotobyname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getprotobynumber\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getpwnam\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getpwuid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getservbyname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getservbyport\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt_error\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getsockopt_optint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gettimeofday\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getuid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>gmtime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>handle_unix_error\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>in_channel_of_descr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet6_addr_any\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet6_addr_loopback\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet_addr_any\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet_addr_loopback\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inet_addr_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>initgroups\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isatty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>link\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>listen\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>localtime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lockf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lseek\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lstat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mkdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mkfifo\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mktime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_connection\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_process\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_process_full\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_process_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_process_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>opendir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>openfile\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>out_channel_of_descr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pause\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pipe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>putenv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>read\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readlink\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>recv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>recvfrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rename\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rewinddir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rmdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>select\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>send\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>send_substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sendto\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sendto_substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_close_on_exec\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_nonblock\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setgid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setgroups\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setitimer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsockopt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsockopt_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsockopt_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setsockopt_optint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setuid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shutdown\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shutdown_connection\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigpending\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigprocmask\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigsuspend\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>single_write\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>single_write_substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sleep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>socket\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>socketpair\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stderr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stdin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stdout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_inet_addr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>symlink\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>system\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcdrain\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcflow\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcflush\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcgetattr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcsendbreak\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tcsetattr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>time\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>times\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>umask\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unlink\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utimes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>wait\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>waitpid\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>write\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>write_substring\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>access_permission\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>addr_info\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>dir_handle\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>error\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>file_descr\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>file_kind\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>file_perm\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>flow_action\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>flush_queue\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>getaddrinfo_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>getnameinfo_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>group_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>host_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>inet_addr\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>interval_timer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>interval_timer_status\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>lock_command\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>msg_flag\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>name_info\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>open_flag\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>passwd_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>process_status\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>process_times\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>protocol_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>seek_command\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>service_entry\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>setattr_when\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>shutdown_command\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>sigprocmask_command\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>sockaddr\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_bool_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_domain\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_float_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_int_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_optint_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>socket_type\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>stats\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>terminal_io\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>tm\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>wait_flag\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>LargeFile", "docs": null, "kind": "module"}, {"path": "Sys", "name": "argv", "type": "let argv: array(string)", "docs": "<p>The command line arguments given to the process. The first element is the command name used to invoke the program. The following elements are the command-line arguments given to the program.</p>\n", "kind": "value"}, {"path": "Sys", "name": "executable_name", "type": "let executable_name: string", "docs": "<p>The name of the file containing the executable currently running.</p>\n", "kind": "value"}, {"path": "Sys", "name": "file_exists", "type": "let file_exists: string => bool", "docs": "<p>Test if a file with the given name exists.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Sys", "name": "is_directory", "type": "let is_directory: string => bool", "docs": "<p>Returns <code>true</code> if the given name refers to a directory, <code>false</code> if it refers to another kind of file. Raise <code>Sys_error</code> if no file exists with the given name.</p>\nSince: 3.10.0", "kind": "value", "args": [["", "string"]]}, {"path": "Sys", "name": "remove", "type": "let remove: string => unit", "docs": "<p>Remove the given file name from the file system.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Sys", "name": "rename", "type": "let rename: (string, string) => unit", "docs": "<p>Rename a file. The first argument is the old name and the second is the new name. If there is already another file under the new name, <code>rename</code> may replace it, or raise an exception, depending on your operating system.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Sys", "name": "getenv", "type": "let getenv: string => string", "docs": "<p>Return the value associated to a variable in the process environment. Raise <code>Not_found</code> if the variable is unbound.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Sys", "name": "command", "type": "let command: string => int", "docs": "<p>Execute the given shell command and return its exit code.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Sys", "name": "time", "type": "let time: unit => float", "docs": "<p>Return the processor time, in seconds, used by the program since the beginning of execution.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Sys", "name": "chdir", "type": "let chdir: string => unit", "docs": "<p>Change the current working directory of the process.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Sys", "name": "getcwd", "type": "let getcwd: unit => string", "docs": "<p>Return the current working directory of the process.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Sys", "name": "readdir", "type": "let readdir: string => array(string)", "docs": "<p>Return the names of all files present in the given directory. Names denoting the current directory and the parent directory (<code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> in Unix) are not returned. Each string in the result is a file name rather than a complete path. There is no guarantee that the name strings in the resulting array will appear in any specific order; they are not, in particular, guaranteed to appear in alphabetical order.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Sys", "name": "interactive", "type": "let interactive: Pervasives.ref(bool)", "docs": "<p>This reference is initially set to <code>false</code> in standalone programs and to <code>true</code> if the code is being executed under the interactive toplevel system <code>ocaml</code>.</p>\n", "kind": "value"}, {"path": "Sys", "name": "os_type", "type": "let os_type: string", "docs": "<p>Operating system currently executing the OCaml program. One of</p>\n<ul><li><p><code>&quot;Unix&quot;</code> (for all Unix versions, including Linux and Mac OS X),</p>\n</li><li><p><code>&quot;Win32&quot;</code> (for MS-Windows, OCaml compiled with MSVC++ or Mingw),</p>\n</li><li><p><code>&quot;Cygwin&quot;</code> (for MS-Windows, OCaml compiled with Cygwin).</p>\n</li></ul>", "kind": "value"}, {"path": "Sys", "name": "unix", "type": "let unix: bool", "docs": "<p>True if <code>Sys.os_type = &quot;Unix&quot;</code>.</p>\nSince: 4.01.0", "kind": "value"}, {"path": "Sys", "name": "win32", "type": "let win32: bool", "docs": "<p>True if <code>Sys.os_type = &quot;Win32&quot;</code>.</p>\nSince: 4.01.0", "kind": "value"}, {"path": "Sys", "name": "cygwin", "type": "let cygwin: bool", "docs": "<p>True if <code>Sys.os_type = &quot;Cygwin&quot;</code>.</p>\nSince: 4.01.0", "kind": "value"}, {"path": "Sys", "name": "word_size", "type": "let word_size: int", "docs": "<p>Size of one word on the machine currently executing the OCaml program, in bits: 32 or 64.</p>\n", "kind": "value"}, {"path": "Sys", "name": "big_endian", "type": "let big_endian: bool", "docs": "<p>Whether the machine currently executing the Caml program is big-endian.</p>\nSince: 4.00.0", "kind": "value"}, {"path": "Sys", "name": "is_js", "type": "let is_js: bool", "docs": "<p>True if compiled against Javascript backend</p>\nSince: 4.03.0", "kind": "value"}, {"path": "Sys", "name": "max_string_length", "type": "let max_string_length: int", "docs": "<p>True if compiled against Javascript backend</p>\nSince: 4.03.0", "kind": "value"}, {"path": "Sys", "name": "max_array_length", "type": "let max_array_length: int", "docs": "<p>Maximum length of a normal array. The maximum length of a float array is <code>max_array_length/2</code> on 32-bit machines and <code>max_array_length</code> on 64-bit machines.</p>\n", "kind": "value"}, {"path": "Sys", "name": "signal_behavior", "type": "type signal_behavior = | Signal_default | Signal_ignore | Signal_handle(int => unit)\n", "docs": "<p>What to do when receiving a signal:</p>\n<ul><li><p><code>Signal_default</code>: take the default behavior (usually: abort the program)</p>\n</li><li><p><code>Signal_ignore</code>: ignore the signal</p>\n</li><li><p><code>Signal_handle f</code>: call function <code>f</code>, giving it the signal number as argument.</p>\n</li></ul>", "kind": "type"}, {"path": "Sys", "name": "signal", "type": "let signal: (int, signal_behavior) => signal_behavior", "docs": "<p>Set the behavior of the system on receipt of a given signal. The first argument is the signal number. Return the behavior previously associated with the signal. If the signal number is invalid (or not available on your system), an <code>Invalid_argument</code> exception is raised.</p>\n", "kind": "value", "args": [["", "int"], ["", "signal_behavior"]]}, {"path": "Sys", "name": "set_signal", "type": "let set_signal: (int, signal_behavior) => unit", "docs": "<p>Same as signal but return value is ignored.</p>\n", "kind": "value", "args": [["", "int"], ["", "signal_behavior"]]}, {"path": "Sys", "name": "sigabrt", "type": "let sigabrt: int", "docs": "<p>Abnormal termination</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigalrm", "type": "let sigalrm: int", "docs": "<p>Timeout</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigfpe", "type": "let sigfpe: int", "docs": "<p>Arithmetic exception</p>\n", "kind": "value"}, {"path": "Sys", "name": "sighup", "type": "let sighup: int", "docs": "<p>Hangup on controlling terminal</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigill", "type": "let sigill: int", "docs": "<p>Invalid hardware instruction</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigint", "type": "let sigint: int", "docs": "<p>Interactive interrupt (ctrl-C)</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigkill", "type": "let sigkill: int", "docs": "<p>Termination (cannot be ignored)</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigpipe", "type": "let sigpipe: int", "docs": "<p>Broken pipe</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigquit", "type": "let sigquit: int", "docs": "<p>Interactive termination</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigsegv", "type": "let sigsegv: int", "docs": "<p>Invalid memory reference</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigterm", "type": "let sigterm: int", "docs": "<p>Termination</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigusr1", "type": "let sigusr1: int", "docs": "<p>Application-defined signal 1</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigusr2", "type": "let sigusr2: int", "docs": "<p>Application-defined signal 2</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigchld", "type": "let sigchld: int", "docs": "<p>Child process terminated</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigcont", "type": "let sigcont: int", "docs": "<p>Continue</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigstop", "type": "let sigstop: int", "docs": "<p>Stop</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigtstp", "type": "let sigtstp: int", "docs": "<p>Interactive stop</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigttin", "type": "let sigttin: int", "docs": "<p>Terminal read from background process</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigttou", "type": "let sigttou: int", "docs": "<p>Terminal write from background process</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigvtalrm", "type": "let sigvtalrm: int", "docs": "<p>Timeout in virtual time</p>\n", "kind": "value"}, {"path": "Sys", "name": "sigprof", "type": "let sigprof: int", "docs": "<p>Profiling interrupt</p>\n", "kind": "value"}, {"path": "Sys", "name": "catch_break", "type": "let catch_break: bool => unit", "docs": "<p><code>catch_break</code> governs whether interactive interrupt (ctrl-C) terminates the program or raises the <code>Break</code> exception. Call <code>catch_break true</code> to enable raising <code>Break</code>, and <code>catch_break false</code> to let the system terminate the program on user interrupt.</p>\n", "kind": "value", "args": [["", "bool"]]}, {"path": "Sys", "name": "ocaml_version", "type": "let ocaml_version: string", "docs": null, "kind": "value"}, {"path": "", "name": "Sys", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>argv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>big_endian\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>catch_break\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>command\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cygwin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>executable_name\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>file_exists\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getcwd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getenv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>interactive\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_directory\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_js\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_array_length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_string_length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ocaml_version\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>os_type\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>readdir\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rename\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_signal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigabrt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigalrm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigchld\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigcont\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigfpe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sighup\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigkill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>signal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigpipe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigprof\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigquit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigsegv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigstop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigterm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigtstp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigttin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigttou\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigusr1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigusr2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sigvtalrm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>time\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unix\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>win32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>word_size\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>signal_behavior", "docs": null, "kind": "module"}, {"path": "StringLabels", "name": "length", "type": "let length: string => int", "docs": "<p>Return the length (number of characters) of the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StringLabels", "name": "get", "type": "let get: (string, int) => char", "docs": "<p><code>String.get s n</code> returns the character at index <code>n</code> in string <code>s</code>. You can also write <code>s.[n]</code> instead of <code>String.get s n</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> not a valid index in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "StringLabels", "name": "set", "type": "let set: (bytes, int, char) => unit", "docs": "<p><code>String.set s n c</code> modifies byte sequence <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>. You can also write <code>s.[n] &lt;- c</code> instead of <code>String.set s n c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p>\n<p>Deprecated: <p>This is a deprecated alias of set.</p></p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StringLabels", "name": "create", "type": "let create: int => bytes", "docs": "<p><code>String.create n</code> returns a fresh byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n<p>Deprecated: <p>This is a deprecated alias of create.</p></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "StringLabels", "name": "make", "type": "let make: (int, char) => string", "docs": "<p><code>String.make n c</code> returns a fresh string of length <code>n</code>, filled with the character <code>c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["", "char"]]}, {"path": "StringLabels", "name": "init", "type": "let init: (int, ~f: int => char) => string", "docs": "<p><code>init n f</code> returns a string of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["f", "int => char"]]}, {"path": "StringLabels", "name": "copy", "type": "let copy: string => string", "docs": "<p>Return a copy of the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StringLabels", "name": "sub", "type": "let sub: (string, ~pos: int, ~len: int) => string", "docs": "<p><code>String.sub s start len</code> returns a fresh string of length <code>len</code>, containing the substring of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid substring of <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["pos", "int"], ["len", "int"]]}, {"path": "StringLabels", "name": "fill", "type": "let fill: (bytes, ~pos: int, ~len: int, char) => unit", "docs": "<p><code>String.fill s start len c</code> modifies byte sequence <code>s</code> in place, replacing <code>len</code> bytes by <code>c</code>, starting at <code>start</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid substring of <code>s</code>.</p>\n<p>Deprecated: <p>This is a deprecated alias of fill.</p></p>\n", "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"], ["", "char"]]}, {"path": "StringLabels", "name": "blit", "type": "let blit: (~src: string, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit", "docs": "<p><code>String.blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from the string <code>src</code>, starting at index <code>srcoff</code>, to byte sequence <code>dst</code>, starting at character number <code>dstoff</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p>\n", "kind": "value", "args": [["src", "string"], ["src_pos", "int"], ["dst", "bytes"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "StringLabels", "name": "concat", "type": "let concat: (~sep: string, list(string)) => string", "docs": "<p><code>String.concat sep sl</code> concatenates the list of strings <code>sl</code>, inserting the separator string <code>sep</code> between each.</p>\n", "kind": "value", "args": [["sep", "string"], ["", "list(string)"]]}, {"path": "StringLabels", "name": "iter", "type": "let iter: (~f: char => unit, string) => unit", "docs": "<p><code>String.iter f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code>. It is equivalent to <code>f s.[0]; f s.[1]; ...; f s.[String.length s - 1]; ()</code>.</p>\n", "kind": "value", "args": [["f", "char => unit"], ["", "string"]]}, {"path": "StringLabels", "name": "iteri", "type": "let iteri: (~f: (int, char) => unit, string) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the element as first argument (counting from 0), and the character itself as second argument.</p>\nSince: 4.00.0", "kind": "value", "args": [["f", "(int, char) => unit"], ["", "string"]]}, {"path": "StringLabels", "name": "map", "type": "let map: (~f: char => char, string) => string", "docs": "<p><code>String.map f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code> and stores the results in a new string that is returned.</p>\nSince: 4.00.0", "kind": "value", "args": [["f", "char => char"], ["", "string"]]}, {"path": "StringLabels", "name": "mapi", "type": "let mapi: (~f: (int, char) => char, string) => string", "docs": "<p><code>String.mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the results in a new string that is returned.</p>\nSince: 4.02.0", "kind": "value", "args": [["f", "(int, char) => char"], ["", "string"]]}, {"path": "StringLabels", "name": "trim", "type": "let trim: string => string", "docs": "<p>Return a copy of the argument, without leading and trailing whitespace. The characters regarded as whitespace are: <code>&#39; &#39;</code>, <code>&#39;\\012&#39;</code>, <code>&#39;\\n&#39;</code>, <code>&#39;\\r&#39;</code>, and <code>&#39;\\t&#39;</code>. If there is no leading nor trailing whitespace character in the argument, return the original string itself, not a copy.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "string"]]}, {"path": "StringLabels", "name": "escaped", "type": "let escaped: string => string", "docs": "<p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. If there is no special character in the argument, return the original string itself, not a copy. Its inverse function is Scanf.unescaped.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StringLabels", "name": "index", "type": "let index: (string, char) => int", "docs": "<p><code>String.index s c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "char"]]}, {"path": "StringLabels", "name": "rindex", "type": "let rindex: (string, char) => int", "docs": "<p><code>String.rindex s c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "char"]]}, {"path": "StringLabels", "name": "index_from", "type": "let index_from: (string, int, char) => int", "docs": "<p><code>String.index_from s i c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code> after position <code>i</code>. <code>String.index s c</code> is equivalent to <code>String.index_from s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "StringLabels", "name": "rindex_from", "type": "let rindex_from: (string, int, char) => int", "docs": "<p><code>String.rindex_from s i c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code> before position <code>i+1</code>. <code>String.rindex s c</code> is equivalent to <code>String.rindex_from s (String.length s - 1) c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "StringLabels", "name": "contains", "type": "let contains: (string, char) => bool", "docs": "<p><code>String.contains s c</code> tests if character <code>c</code> appears in the string <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "char"]]}, {"path": "StringLabels", "name": "contains_from", "type": "let contains_from: (string, int, char) => bool", "docs": "<p><code>String.contains_from s start c</code> tests if character <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>String.contains s c</code> is equivalent to <code>String.contains_from s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "StringLabels", "name": "rcontains_from", "type": "let rcontains_from: (string, int, char) => bool", "docs": "<p><code>String.rcontains_from s stop c</code> tests if character <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "StringLabels", "name": "uppercase", "type": "let uppercase: string => string", "docs": "<p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StringLabels", "name": "lowercase", "type": "let lowercase: string => string", "docs": "<p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StringLabels", "name": "capitalize", "type": "let capitalize: string => string", "docs": "<p>Return a copy of the argument, with the first character set to uppercase.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StringLabels", "name": "uncapitalize", "type": "let uncapitalize: string => string", "docs": "<p>Return a copy of the argument, with the first character set to lowercase.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StringLabels", "name": "t", "type": "type t = string", "docs": "<p>An alias for the type of strings.</p>\n", "kind": "type"}, {"path": "StringLabels", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for strings, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>String</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "StringLabels", "name": "unsafe_get", "type": "let unsafe_get: (string, int) => char", "docs": null, "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "StringLabels", "name": "unsafe_set", "type": "let unsafe_set: (bytes, int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StringLabels", "name": "unsafe_blit", "type": "let unsafe_blit: (~src: string, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit", "docs": null, "kind": "value", "args": [["src", "string"], ["src_pos", "int"], ["dst", "bytes"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "StringLabels", "name": "unsafe_fill", "type": "let unsafe_fill: (bytes, ~pos: int, ~len: int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"], ["", "char"]]}, {"path": "", "name": "StringLabels", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>capitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>escaped\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lowercase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rcontains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uncapitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uppercase\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "String", "name": "length", "type": "let length: string => int", "docs": "<p>Return the length (number of characters) of the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "String", "name": "get", "type": "let get: (string, int) => char", "docs": "<p><code>String.get s n</code> returns the character at index <code>n</code> in string <code>s</code>. You can also write <code>s.[n]</code> instead of <code>String.get s n</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> not a valid index in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "String", "name": "set", "type": "let set: (bytes, int, char) => unit", "docs": "<p><code>String.set s n c</code> modifies byte sequence <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>. You can also write <code>s.[n] &lt;- c</code> instead of <code>String.set s n c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p>\n<p>Deprecated: <p>This is a deprecated alias of set.<code> </code></p></p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "String", "name": "create", "type": "let create: int => bytes", "docs": "<p><code>String.create n</code> returns a fresh byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n<p>Deprecated: <p>This is a deprecated alias of create.<code> </code></p></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "String", "name": "make", "type": "let make: (int, char) => string", "docs": "<p><code>String.make n c</code> returns a fresh string of length <code>n</code>, filled with the character <code>c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["", "char"]]}, {"path": "String", "name": "init", "type": "let init: (int, int => char) => string", "docs": "<p><code>String.init n f</code> returns a string of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code> (called in increasing index order).</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "int"], ["", "int => char"]]}, {"path": "String", "name": "copy", "type": "let copy: string => string", "docs": "<p>Return a copy of the given string.</p>\n<p>Deprecated: <p>Because strings are immutable, it doesn&#39;t make much sense to make identical copies of them.</p></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "String", "name": "sub", "type": "let sub: (string, int, int) => string", "docs": "<p><code>String.sub s start len</code> returns a fresh string of length <code>len</code>, containing the substring of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid substring of <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "int"]]}, {"path": "String", "name": "fill", "type": "let fill: (bytes, int, int, char) => unit", "docs": "<p><code>String.fill s start len c</code> modifies byte sequence <code>s</code> in place, replacing <code>len</code> bytes with <code>c</code>, starting at <code>start</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p>\n<p>Deprecated: <p>This is a deprecated alias of fill.<code> </code></p></p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"], ["", "char"]]}, {"path": "String", "name": "blit", "type": "let blit: (string, int, bytes, int, int) => unit", "docs": "<p>Same as blit_string.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "String", "name": "concat", "type": "let concat: (string, list(string)) => string", "docs": "<p><code>String.concat sep sl</code> concatenates the list of strings <code>sl</code>, inserting the separator string <code>sep</code> between each.</p>\n<p>Raise <code>Invalid_argument</code> if the result is longer than max_string_length bytes.</p>\n", "kind": "value", "args": [["", "string"], ["", "list(string)"]]}, {"path": "String", "name": "iter", "type": "let iter: (char => unit, string) => unit", "docs": "<p><code>String.iter f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code>. It is equivalent to <code>f s.[0]; f s.[1]; ...; f s.[String.length s - 1]; ()</code>.</p>\n", "kind": "value", "args": [["", "char => unit"], ["", "string"]]}, {"path": "String", "name": "iteri", "type": "let iteri: ((int, char) => unit, string) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the element as first argument (counting from 0), and the character itself as second argument.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "(int, char) => unit"], ["", "string"]]}, {"path": "String", "name": "map", "type": "let map: (char => char, string) => string", "docs": "<p><code>String.map f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code> (in increasing index order) and stores the results in a new string that is returned.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "char => char"], ["", "string"]]}, {"path": "String", "name": "mapi", "type": "let mapi: ((int, char) => char, string) => string", "docs": "<p><code>String.mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the results in a new string that is returned.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "(int, char) => char"], ["", "string"]]}, {"path": "String", "name": "trim", "type": "let trim: string => string", "docs": "<p>Return a copy of the argument, without leading and trailing whitespace. The characters regarded as whitespace are: <code>&#39; &#39;</code>, <code>&#39;\\012&#39;</code>, <code>&#39;\\n&#39;</code>, <code>&#39;\\r&#39;</code>, and <code>&#39;\\t&#39;</code>. If there is neither leading nor trailing whitespace character in the argument, return the original string itself, not a copy.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "string"]]}, {"path": "String", "name": "escaped", "type": "let escaped: string => string", "docs": "<p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. If there is no special character in the argument, return the original string itself, not a copy. Its inverse function is Scanf.unescaped.</p>\n<p>Raise <code>Invalid_argument</code> if the result is longer than max_string_length bytes.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "String", "name": "index", "type": "let index: (string, char) => int", "docs": "<p><code>String.index s c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "char"]]}, {"path": "String", "name": "rindex", "type": "let rindex: (string, char) => int", "docs": "<p><code>String.rindex s c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "char"]]}, {"path": "String", "name": "index_from", "type": "let index_from: (string, int, char) => int", "docs": "<p><code>String.index_from s i c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code> after position <code>i</code>. <code>String.index s c</code> is equivalent to <code>String.index_from s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "String", "name": "rindex_from", "type": "let rindex_from: (string, int, char) => int", "docs": "<p><code>String.rindex_from s i c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code> before position <code>i+1</code>. <code>String.rindex s c</code> is equivalent to <code>String.rindex_from s (String.length s - 1) c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "String", "name": "contains", "type": "let contains: (string, char) => bool", "docs": "<p><code>String.contains s c</code> tests if character <code>c</code> appears in the string <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "char"]]}, {"path": "String", "name": "contains_from", "type": "let contains_from: (string, int, char) => bool", "docs": "<p><code>String.contains_from s start c</code> tests if character <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>String.contains s c</code> is equivalent to <code>String.contains_from s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "String", "name": "rcontains_from", "type": "let rcontains_from: (string, int, char) => bool", "docs": "<p><code>String.rcontains_from s stop c</code> tests if character <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "String", "name": "uppercase", "type": "let uppercase: string => string", "docs": "<p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "String", "name": "lowercase", "type": "let lowercase: string => string", "docs": "<p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "String", "name": "capitalize", "type": "let capitalize: string => string", "docs": "<p>Return a copy of the argument, with the first character set to uppercase.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "String", "name": "uncapitalize", "type": "let uncapitalize: string => string", "docs": "<p>Return a copy of the argument, with the first character set to lowercase.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "String", "name": "t", "type": "type t = string", "docs": "<p>An alias for the type of strings.</p>\n", "kind": "type"}, {"path": "String", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for strings, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>String</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "String", "name": "unsafe_get", "type": "let unsafe_get: (string, int) => char", "docs": null, "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "String", "name": "unsafe_set", "type": "let unsafe_set: (bytes, int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "String", "name": "unsafe_blit", "type": "let unsafe_blit: (string, int, bytes, int, int) => unit", "docs": null, "kind": "value", "args": [["", "string"], ["", "int"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "String", "name": "unsafe_fill", "type": "let unsafe_fill: (bytes, int, int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"], ["", "char"]]}, {"path": "", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>capitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>escaped\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lowercase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rcontains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uncapitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uppercase\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Stream", "name": "t", "type": "type t('a)", "docs": "<p>The type of streams holding values of type <code>&#39;a</code>.</p>\n", "kind": "type"}, {"path": "Stream", "name": "from", "type": "let from: int => option('a) => t('a)", "docs": "<p><code>Stream.from f</code> returns a stream built from the function <code>f</code>. To create a new stream element, the function <code>f</code> is called with the current stream count. The user function <code>f</code> must return either <code>Some &lt;value&gt;</code> for a value or <code>None</code> to specify the end of the stream.</p>\n<p>Do note that the indices passed to <code>f</code> may not start at <code>0</code> in the general case. For example, <code>[&lt; &#39;0; &#39;1; Stream.from f &gt;]</code> would call <code>f</code> the first time with count <code>2</code>.</p>\n", "kind": "value", "args": [["", "int => option('a)"]]}, {"path": "Stream", "name": "of_list", "type": "let of_list: list('a) => t('a)", "docs": "<p>Return the stream holding the elements of the list in the same order.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "Stream", "name": "of_string", "type": "let of_string: string => t(char)", "docs": "<p>Return the stream of the characters of the string parameter.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Stream", "name": "of_bytes", "type": "let of_bytes: bytes => t(char)", "docs": "<p>Return the stream of the characters of the bytes parameter.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "bytes"]]}, {"path": "Stream", "name": "of_channel", "type": "let of_channel: Pervasives.in_channel => t(char)", "docs": "<p>Return the stream of the characters read from the input channel.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "Stream", "name": "iter", "type": "let iter: ('a => unit, t('a)) => unit", "docs": "<p><code>Stream.iter f s</code> scans the whole stream s, applying function <code>f</code> in turn to each stream element encountered.</p>\n", "kind": "value", "args": [["", "'a => unit"], ["", "t('a)"]]}, {"path": "Stream", "name": "next", "type": "let next: t('a) => 'a", "docs": "<p>Return the first element of the stream and remove it from the stream. Raise Stream.Failure if the stream is empty.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stream", "name": "empty", "type": "let empty: t('a) => unit", "docs": "<p>Return <code>()</code> if the stream is empty, else raise <code>Stream.Failure</code>.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stream", "name": "peek", "type": "let peek: t('a) => option('a)", "docs": "<p>Return <code>Some</code> of &quot;the first element&quot; of the stream, or <code>None</code> if the stream is empty.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stream", "name": "junk", "type": "let junk: t('a) => unit", "docs": "<p>Remove the first element of the stream, possibly unfreezing it before.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stream", "name": "count", "type": "let count: t('a) => int", "docs": "<p>Return the current count of the stream elements, i.e. the number of the stream elements discarded.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stream", "name": "npeek", "type": "let npeek: (int, t('a)) => list('a)", "docs": "<p><code>npeek n</code> returns the list of the <code>n</code> first elements of the stream, or all its remaining elements if less than <code>n</code> elements are available.</p>\n", "kind": "value", "args": [["", "int"], ["", "t('a)"]]}, {"path": "Stream", "name": "iapp", "type": "let iapp: (t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Stream", "name": "icons", "type": "let icons: ('a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Stream", "name": "ising", "type": "let ising: 'a => t('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Stream", "name": "lapp", "type": "let lapp: (unit => t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "unit => t('a)"], ["", "t('a)"]]}, {"path": "Stream", "name": "lcons", "type": "let lcons: (unit => 'a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "unit => 'a"], ["", "t('a)"]]}, {"path": "Stream", "name": "lsing", "type": "let lsing: unit => 'a => t('a)", "docs": null, "kind": "value", "args": [["", "unit => 'a"]]}, {"path": "Stream", "name": "sempty", "type": "let sempty: t('a)", "docs": null, "kind": "value"}, {"path": "Stream", "name": "slazy", "type": "let slazy: unit => t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "unit => t('a)"]]}, {"path": "Stream", "name": "dump", "type": "let dump: ('a => unit, t('a)) => unit", "docs": null, "kind": "value", "args": [["", "'a => unit"], ["", "t('a)"]]}, {"path": "", "name": "Stream", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>count\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dump\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iapp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>icons\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ising\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>junk\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lapp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lcons\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lsing\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>next\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>npeek\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_bytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_list\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>peek\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sempty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slazy\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "StdLabels.Array", "name": "length", "type": "let length: array('a) => int", "docs": "<p>Return the length (number of elements) of the given array.</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "get", "type": "let get: (array('a), int) => 'a", "docs": "<p><code>ArrayLabels.get a n</code> returns the element number <code>n</code> of array <code>a</code>. The first element has number 0. The last element has number <code>ArrayLabels.length a - 1</code>. You can also write <code>a.(n)</code> instead of <code>ArrayLabels.get a n</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>(ArrayLabels.length a - 1)</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "StdLabels.Array", "name": "set", "type": "let set: (array('a), int, 'a) => unit", "docs": "<p><code>ArrayLabels.set a n x</code> modifies array <code>a</code> in place, replacing element number <code>n</code> with <code>x</code>. You can also write <code>a.(n) &lt;- x</code> instead of <code>ArrayLabels.set a n x</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>ArrayLabels.length a - 1</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "StdLabels.Array", "name": "make", "type": "let make: (int, 'a) => array('a)", "docs": "<p><code>ArrayLabels.make n x</code> returns a fresh array of length <code>n</code>, initialized with <code>x</code>. All the elements of this new array are initially physically equal to <code>x</code> (in the sense of the <code>==</code> predicate). Consequently, if <code>x</code> is mutable, it is shared among all elements of the array, and modifying <code>x</code> through one of the array entries will modify all other entries at the same time.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the value of <code>x</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "StdLabels.Array", "name": "create", "type": "let create: (int, 'a) => array('a)", "docs": "<p>Deprecated: <p><code>ArrayLabels.create</code> is an alias for make.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "StdLabels.Array", "name": "init", "type": "let init: (int, ~f: int => 'a) => array('a)", "docs": "<p><code>ArrayLabels.init n f</code> returns a fresh array of length <code>n</code>, with element number <code>i</code> initialized to the result of <code>f i</code>. In other terms, <code>ArrayLabels.init n f</code> tabulates the results of <code>f</code> applied to the integers <code>0</code> to <code>n-1</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the return type of <code>f</code> is <code>float</code>, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["", "int"], ["f", "int => 'a"]]}, {"path": "StdLabels.Array", "name": "make_matrix", "type": "let make_matrix: (~dimx: int, ~dimy: int, 'a) => array(array('a))", "docs": "<p><code>ArrayLabels.make_matrix dimx dimy e</code> returns a two-dimensional array (an array of arrays) with first dimension <code>dimx</code> and second dimension <code>dimy</code>. All the elements of this new matrix are initially physically equal to <code>e</code>. The element (<code>x,y</code>) of a matrix <code>m</code> is accessed with the notation <code>m.(x).(y)</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>dimx</code> or <code>dimy</code> is negative or greater than <code>Sys.max_array_length</code>. If the value of <code>e</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["dimx", "int"], ["dimy", "int"], ["", "'a"]]}, {"path": "StdLabels.Array", "name": "create_matrix", "type": "let create_matrix: (~dimx: int, ~dimy: int, 'a) => array(array('a))", "docs": "<p>Deprecated: <p><code>ArrayLabels.create_matrix</code> is an alias for make_matrix.</p></p>\n", "kind": "value", "args": [["dimx", "int"], ["dimy", "int"], ["", "'a"]]}, {"path": "StdLabels.Array", "name": "append", "type": "let append: (array('a), array('a)) => array('a)", "docs": "<p><code>ArrayLabels.append v1 v2</code> returns a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "concat", "type": "let concat: list(array('a)) => array('a)", "docs": "<p>Same as <code>ArrayLabels.append</code>, but concatenates a list of arrays.</p>\n", "kind": "value", "args": [["", "list(array('a))"]]}, {"path": "StdLabels.Array", "name": "sub", "type": "let sub: (array('a), ~pos: int, ~len: int) => array('a)", "docs": "<p><code>ArrayLabels.sub a start len</code> returns a fresh array of length <code>len</code>, containing the elements number <code>start</code> to <code>start + len - 1</code> of array <code>a</code>.</p>\n<p>Raise <code>Invalid_argument &quot;Array.sub&quot;</code> if <code>start</code> and <code>len</code> do not designate a valid subarray of <code>a</code>; that is, if <code>start &lt; 0</code>, or <code>len &lt; 0</code>, or <code>start + len &gt; ArrayLabels.length a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["pos", "int"], ["len", "int"]]}, {"path": "StdLabels.Array", "name": "copy", "type": "let copy: array('a) => array('a)", "docs": "<p><code>ArrayLabels.copy a</code> returns a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "fill", "type": "let fill: (array('a), ~pos: int, ~len: int, 'a) => unit", "docs": "<p><code>ArrayLabels.fill a ofs len x</code> modifies the array <code>a</code> in place, storing <code>x</code> in elements number <code>ofs</code> to <code>ofs + len - 1</code>.</p>\n<p>Raise <code>Invalid_argument &quot;Array.fill&quot;</code> if <code>ofs</code> and <code>len</code> do not designate a valid subarray of <code>a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["pos", "int"], ["len", "int"], ["", "'a"]]}, {"path": "StdLabels.Array", "name": "blit", "type": "let blit: (~src: array('a), ~src_pos: int, ~dst: array('a), ~dst_pos: int, ~len: int) => unit", "docs": "<p><code>ArrayLabels.blit v1 o1 v2 o2 len</code> copies <code>len</code> elements from array <code>v1</code>, starting at element number <code>o1</code>, to array <code>v2</code>, starting at element number <code>o2</code>. It works correctly even if <code>v1</code> and <code>v2</code> are the same array, and the source and destination chunks overlap.</p>\n<p>Raise <code>Invalid_argument &quot;Array.blit&quot;</code> if <code>o1</code> and <code>len</code> do not designate a valid subarray of <code>v1</code>, or if <code>o2</code> and <code>len</code> do not designate a valid subarray of <code>v2</code>.</p>\n", "kind": "value", "args": [["src", "array('a)"], ["src_pos", "int"], ["dst", "array('a)"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "StdLabels.Array", "name": "to_list", "type": "let to_list: array('a) => list('a)", "docs": "<p><code>ArrayLabels.to_list a</code> returns the list of all the elements of <code>a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "of_list", "type": "let of_list: list('a) => array('a)", "docs": "<p><code>ArrayLabels.of_list l</code> returns a fresh array containing the elements of <code>l</code>.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "StdLabels.Array", "name": "iter", "type": "let iter: (~f: 'a => unit, array('a)) => unit", "docs": "<p><code>ArrayLabels.iter f a</code> applies function <code>f</code> in turn to all the elements of <code>a</code>. It is equivalent to <code>f a.(0); f a.(1); ...; f a.(ArrayLabels.length a - 1); ()</code>.</p>\n", "kind": "value", "args": [["f", "'a => unit"], ["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "map", "type": "let map: (~f: 'a => 'b, array('a)) => array('b)", "docs": "<p><code>ArrayLabels.map f a</code> applies function <code>f</code> to all the elements of <code>a</code>, and builds an array with the results returned by <code>f</code>: <code>[| f a.(0); f a.(1); ...; f a.(ArrayLabels.length a - 1) |]</code>.</p>\n", "kind": "value", "args": [["f", "'a => 'b"], ["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "iteri", "type": "let iteri: (~f: (int, 'a) => unit, array('a)) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p>\n", "kind": "value", "args": [["f", "(int, 'a) => unit"], ["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "mapi", "type": "let mapi: (~f: (int, 'a) => 'b, array('a)) => array('b)", "docs": "<p>Same as map, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p>\n", "kind": "value", "args": [["f", "(int, 'a) => 'b"], ["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "fold_left", "type": "let fold_left: (~f: ('a, 'b) => 'a, ~init: 'a, array('b)) => 'a", "docs": "<p><code>ArrayLabels.fold_left f x a</code> computes <code>f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)</code>, where <code>n</code> is the length of the array <code>a</code>.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'a"], ["init", "'a"], ["", "array('b)"]]}, {"path": "StdLabels.Array", "name": "fold_right", "type": "let fold_right: (~f: ('b, 'a) => 'a, array('b), ~init: 'a) => 'a", "docs": "<p><code>ArrayLabels.fold_right f a x</code> computes <code>f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))</code>, where <code>n</code> is the length of the array <code>a</code>.</p>\n", "kind": "value", "args": [["f", "('b, 'a) => 'a"], ["", "array('b)"], ["init", "'a"]]}, {"path": "StdLabels.Array", "name": "sort", "type": "let sort: (~cmp: ('a, 'a) => int, array('a)) => unit", "docs": "<p>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, compare is a suitable comparison function, provided there are no floating-point NaN values in the data. After calling <code>ArrayLabels.sort</code>, the array is sorted in place in increasing order. <code>ArrayLabels.sort</code> is guaranteed to run in constant heap space and (at most) logarithmic stack space.</p>\n<p>The current implementation uses Heap Sort. It runs in constant stack space.</p>\n<p>Specification of the comparison function: Let <code>a</code> be the array and <code>cmp</code> the comparison function. The following must be true for all x, y, z in a :</p>\n<ul><li><p><code>cmp x y</code> &gt; 0 if and only if <code>cmp y x</code> &lt; 0</p>\n</li><li><p>if <code>cmp x y</code> &gt;= 0 and <code>cmp y z</code> &gt;= 0 then <code>cmp x z</code> &gt;= 0</p>\n</li></ul><p>When <code>ArrayLabels.sort</code> returns, <code>a</code> contains the same elements as before, reordered in such a way that for all i and j valid indices of <code>a</code> :</p>\n<ul><li><p><code>cmp a.(i) a.(j)</code> &gt;= 0 if and only if i &gt;= j</p>\n</li></ul>", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "stable_sort", "type": "let stable_sort: (~cmp: ('a, 'a) => int, array('a)) => unit", "docs": "<p>Same as sort, but the sorting algorithm is stable (i.e. elements that compare equal are kept in their original order) and not guaranteed to run in constant heap space.</p>\n<p>The current implementation uses Merge Sort. It uses <code>n/2</code> words of heap space, where <code>n</code> is the length of the array. It is usually faster than the current implementation of sort.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "fast_sort", "type": "let fast_sort: (~cmp: ('a, 'a) => int, array('a)) => unit", "docs": "<p>Same as sort or stable_sort, whichever is faster on typical input.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "array('a)"]]}, {"path": "StdLabels.Array", "name": "unsafe_get", "type": "let unsafe_get: (array('a), int) => 'a", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "StdLabels.Array", "name": "unsafe_set", "type": "let unsafe_set: (array('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "StdLabels", "name": "Array", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_matrix\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fast_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_matrix\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_list\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stable_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_list\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set", "docs": null, "kind": "module"}, {"path": "StdLabels.Bytes", "name": "length", "type": "let length: bytes => int", "docs": "<p>Return the length (number of bytes) of the argument.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "get", "type": "let get: (bytes, int) => char", "docs": "<p><code>get s n</code> returns the byte at index <code>n</code> in argument <code>s</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> not a valid index in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "StdLabels.Bytes", "name": "set", "type": "let set: (bytes, int, char) => unit", "docs": "<p><code>set s n c</code> modifies <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "create", "type": "let create: int => bytes", "docs": "<p><code>create n</code> returns a new byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "StdLabels.Bytes", "name": "make", "type": "let make: (int, char) => bytes", "docs": "<p><code>make n c</code> returns a new byte sequence of length <code>n</code>, filled with the byte <code>c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "init", "type": "let init: (int, ~f: int => char) => bytes", "docs": "<p><code>init n f</code> returns a fresh byte sequence of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["f", "int => char"]]}, {"path": "StdLabels.Bytes", "name": "empty", "type": "let empty: bytes", "docs": "<p>A byte sequence of size 0.</p>\n", "kind": "value"}, {"path": "StdLabels.Bytes", "name": "copy", "type": "let copy: bytes => bytes", "docs": "<p>Return a new byte sequence that contains the same bytes as the argument.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "of_string", "type": "let of_string: string => bytes", "docs": "<p>Return a new byte sequence that contains the same bytes as the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels.Bytes", "name": "to_string", "type": "let to_string: bytes => string", "docs": "<p>Return a new string that contains the same bytes as the given byte sequence.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "sub", "type": "let sub: (bytes, ~pos: int, ~len: int) => bytes", "docs": "<p><code>sub s start len</code> returns a new byte sequence of length <code>len</code>, containing the subsequence of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"]]}, {"path": "StdLabels.Bytes", "name": "sub_string", "type": "let sub_string: (bytes, int, int) => string", "docs": "<p>Same as <code>sub</code> but return a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "StdLabels.Bytes", "name": "fill", "type": "let fill: (bytes, ~pos: int, ~len: int, char) => unit", "docs": "<p><code>fill s start len c</code> modifies <code>s</code> in place, replacing <code>len</code> characters with <code>c</code>, starting at <code>start</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "blit", "type": "let blit: (~src: bytes, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit", "docs": "<p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from sequence <code>src</code>, starting at index <code>srcoff</code>, to sequence <code>dst</code>, starting at index <code>dstoff</code>. It works correctly even if <code>src</code> and <code>dst</code> are the same byte sequence, and the source and destination intervals overlap.</p>\n<p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p>\n", "kind": "value", "args": [["src", "bytes"], ["src_pos", "int"], ["dst", "bytes"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "StdLabels.Bytes", "name": "concat", "type": "let concat: (~sep: bytes, list(bytes)) => bytes", "docs": "<p><code>concat sep sl</code> concatenates the list of byte sequences <code>sl</code>, inserting the separator byte sequence <code>sep</code> between each, and returns the result as a new byte sequence.</p>\n", "kind": "value", "args": [["sep", "bytes"], ["", "list(bytes)"]]}, {"path": "StdLabels.Bytes", "name": "iter", "type": "let iter: (~f: char => unit, bytes) => unit", "docs": "<p><code>iter f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code>. It is equivalent to <code>f (get s 0); f (get s 1); ...; f (get s\n    (length s - 1)); ()</code>.</p>\n", "kind": "value", "args": [["f", "char => unit"], ["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "iteri", "type": "let iteri: (~f: (int, char) => unit, bytes) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the byte as first argument and the byte itself as second argument.</p>\n", "kind": "value", "args": [["f", "(int, char) => unit"], ["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "map", "type": "let map: (~f: char => char, bytes) => bytes", "docs": "<p><code>map f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code> and stores the resulting bytes in a new sequence that is returned as the result.</p>\n", "kind": "value", "args": [["f", "char => char"], ["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "mapi", "type": "let mapi: (~f: (int, char) => char, bytes) => bytes", "docs": "<p><code>mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p>\n", "kind": "value", "args": [["f", "(int, char) => char"], ["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "trim", "type": "let trim: bytes => bytes", "docs": "<p>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters <code>&#39; &#39;</code>, <code>&#39;\\012&#39;</code>, <code>&#39;\\n&#39;</code>, <code>&#39;\\r&#39;</code>, and <code>&#39;\\t&#39;</code>.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "escaped", "type": "let escaped: bytes => bytes", "docs": "<p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "index", "type": "let index: (bytes, char) => int", "docs": "<p><code>index s c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "rindex", "type": "let rindex: (bytes, char) => int", "docs": "<p><code>rindex s c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "index_from", "type": "let index_from: (bytes, int, char) => int", "docs": "<p><code>index_from s i c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> after position <code>i</code>. <code>Bytes.index s c</code> is equivalent to <code>Bytes.index_from s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "rindex_from", "type": "let rindex_from: (bytes, int, char) => int", "docs": "<p><code>rindex_from s i c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> before position <code>i+1</code>. <code>rindex s c</code> is equivalent to <code>rindex_from s (Bytes.length s - 1) c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "contains", "type": "let contains: (bytes, char) => bool", "docs": "<p><code>contains s c</code> tests if byte <code>c</code> appears in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "contains_from", "type": "let contains_from: (bytes, int, char) => bool", "docs": "<p><code>contains_from s start c</code> tests if byte <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>contains s c</code> is equivalent to <code>contains_from\n    s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "rcontains_from", "type": "let rcontains_from: (bytes, int, char) => bool", "docs": "<p><code>rcontains_from s stop c</code> tests if byte <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "uppercase", "type": "let uppercase: bytes => bytes", "docs": "<p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "lowercase", "type": "let lowercase: bytes => bytes", "docs": "<p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "capitalize", "type": "let capitalize: bytes => bytes", "docs": "<p>Return a copy of the argument, with the first byte set to uppercase.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "uncapitalize", "type": "let uncapitalize: bytes => bytes", "docs": "<p>Return a copy of the argument, with the first byte set to lowercase.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "t", "type": "type t = bytes", "docs": "<p>An alias for the type of byte sequences.</p>\n", "kind": "type"}, {"path": "StdLabels.Bytes", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for byte sequences, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Bytes</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "StdLabels.Bytes", "name": "unsafe_get", "type": "let unsafe_get: (bytes, int) => char", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "StdLabels.Bytes", "name": "unsafe_set", "type": "let unsafe_set: (bytes, int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "unsafe_blit", "type": "let unsafe_blit: (~src: bytes, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit", "docs": null, "kind": "value", "args": [["src", "bytes"], ["src_pos", "int"], ["dst", "bytes"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "StdLabels.Bytes", "name": "unsafe_fill", "type": "let unsafe_fill: (bytes, ~pos: int, ~len: int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"], ["", "char"]]}, {"path": "StdLabels.Bytes", "name": "unsafe_to_string", "type": "let unsafe_to_string: bytes => string", "docs": null, "kind": "value", "args": [["", "bytes"]]}, {"path": "StdLabels.Bytes", "name": "unsafe_of_string", "type": "let unsafe_of_string: string => bytes", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels", "name": "Bytes", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>capitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>escaped\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lowercase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rcontains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uncapitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uppercase\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "StdLabels.List", "name": "length", "type": "let length: list('a) => int", "docs": "<p>Return the length (number of elements) of the given list.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "StdLabels.List", "name": "hd", "type": "let hd: list('a) => 'a", "docs": "<p>Return the first element of the given list. Raise <code>Failure &quot;hd&quot;</code> if the list is empty.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "StdLabels.List", "name": "tl", "type": "let tl: list('a) => list('a)", "docs": "<p>Return the given list without its first element. Raise <code>Failure &quot;tl&quot;</code> if the list is empty.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "StdLabels.List", "name": "nth", "type": "let nth: (list('a), int) => 'a", "docs": "<p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Raise <code>Failure &quot;nth&quot;</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "int"]]}, {"path": "StdLabels.List", "name": "rev", "type": "let rev: list('a) => list('a)", "docs": "<p>List reversal.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "StdLabels.List", "name": "append", "type": "let append: (list('a), list('a)) => list('a)", "docs": "<p>Catenate two lists. Same function as the infix operator <code>@</code>. Not tail-recursive (length of the first argument). The <code>@</code> operator is not tail-recursive either.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "rev_append", "type": "let rev_append: (list('a), list('a)) => list('a)", "docs": "<p><code>ListLabels.rev_append l1 l2</code> reverses <code>l1</code> and concatenates it to <code>l2</code>. This is equivalent to rev<code> l1 @ l2</code>, but <code>rev_append</code> is tail-recursive and more efficient.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "concat", "type": "let concat: list(list('a)) => list('a)", "docs": "<p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</p>\n", "kind": "value", "args": [["", "list(list('a))"]]}, {"path": "StdLabels.List", "name": "flatten", "type": "let flatten: list(list('a)) => list('a)", "docs": "<p>Same as <code>concat</code>. Not tail-recursive (length of the argument + length of the longest sub-list).</p>\n", "kind": "value", "args": [["", "list(list('a))"]]}, {"path": "StdLabels.List", "name": "iter", "type": "let iter: (~f: 'a => unit, list('a)) => unit", "docs": "<p><code>ListLabels.iter f [a1; ...; an]</code> applies function <code>f</code> in turn to <code>a1; ...; an</code>. It is equivalent to <code>begin f a1; f a2; ...; f an; () end</code>.</p>\n", "kind": "value", "args": [["f", "'a => unit"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "iteri", "type": "let iteri: (~f: (int, 'a) => unit, list('a)) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p>\nSince: 4.00.0", "kind": "value", "args": [["f", "(int, 'a) => unit"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "map", "type": "let map: (~f: 'a => 'b, list('a)) => list('b)", "docs": "<p><code>ListLabels.map f [a1; ...; an]</code> applies function <code>f</code> to <code>a1, ..., an</code>, and builds the list <code>[f a1; ...; f an]</code> with the results returned by <code>f</code>. Not tail-recursive.</p>\n", "kind": "value", "args": [["f", "'a => 'b"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "mapi", "type": "let mapi: (~f: (int, 'a) => 'b, list('a)) => list('b)", "docs": "<p>Same as map, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p>\nSince: 4.00.0", "kind": "value", "args": [["f", "(int, 'a) => 'b"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "rev_map", "type": "let rev_map: (~f: 'a => 'b, list('a)) => list('b)", "docs": "<p><code>ListLabels.rev_map f l</code> gives the same result as rev<code> (</code>map<code> f l)</code>, but is tail-recursive and more efficient.</p>\n", "kind": "value", "args": [["f", "'a => 'b"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "fold_left", "type": "let fold_left: (~f: ('a, 'b) => 'a, ~init: 'a, list('b)) => 'a", "docs": "<p><code>ListLabels.fold_left f a [b1; ...; bn]</code> is <code>f (... (f (f a b1) b2) ...) bn</code>.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'a"], ["init", "'a"], ["", "list('b)"]]}, {"path": "StdLabels.List", "name": "fold_right", "type": "let fold_right: (~f: ('a, 'b) => 'b, list('a), ~init: 'b) => 'b", "docs": "<p><code>ListLabels.fold_right f [a1; ...; an] b</code> is <code>f a1 (f a2 (... (f an b) ...))</code>. Not tail-recursive.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'b"], ["", "list('a)"], ["init", "'b"]]}, {"path": "StdLabels.List", "name": "iter2", "type": "let iter2: (~f: ('a, 'b) => unit, list('a), list('b)) => unit", "docs": "<p><code>ListLabels.iter2 f [a1; ...; an] [b1; ...; bn]</code> calls in turn <code>f a1 b1; ...; f an bn</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => unit"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "StdLabels.List", "name": "map2", "type": "let map2: (~f: ('a, 'b) => 'c, list('a), list('b)) => list('c)", "docs": "<p><code>ListLabels.map2 f [a1; ...; an] [b1; ...; bn]</code> is <code>[f a1 b1; ...; f an bn]</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'c"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "StdLabels.List", "name": "rev_map2", "type": "let rev_map2: (~f: ('a, 'b) => 'c, list('a), list('b)) => list('c)", "docs": "<p><code>ListLabels.rev_map2 f l1 l2</code> gives the same result as rev<code> (</code>map2<code> f l1 l2)</code>, but is tail-recursive and more efficient.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'c"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "StdLabels.List", "name": "fold_left2", "type": "let fold_left2: (~f: ('a, 'b, 'c) => 'a, ~init: 'a, list('b), list('c)) => 'a", "docs": "<p><code>ListLabels.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</code> is <code>f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["f", "('a, 'b, 'c) => 'a"], ["init", "'a"], ["", "list('b)"], ["", "list('c)"]]}, {"path": "StdLabels.List", "name": "fold_right2", "type": "let fold_right2: (~f: ('a, 'b, 'c) => 'c, list('a), list('b), ~init: 'c) => 'c", "docs": "<p><code>ListLabels.fold_right2 f [a1; ...; an] [b1; ...; bn] c</code> is <code>f a1 b1 (f a2 b2 (... (f an bn c) ...))</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>\n", "kind": "value", "args": [["f", "('a, 'b, 'c) => 'c"], ["", "list('a)"], ["", "list('b)"], ["init", "'c"]]}, {"path": "StdLabels.List", "name": "for_all", "type": "let for_all: (~f: 'a => bool, list('a)) => bool", "docs": "<p><code>for_all p [a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code>p</code>. That is, it returns <code>(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)</code>.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "exists", "type": "let exists: (~f: 'a => bool, list('a)) => bool", "docs": "<p><code>exists p [a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code>p</code>. That is, it returns <code>(p a1) || (p a2) || ... || (p an)</code>.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "for_all2", "type": "let for_all2: (~f: ('a, 'b) => bool, list('a), list('b)) => bool", "docs": "<p>Same as for_all, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => bool"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "StdLabels.List", "name": "exists2", "type": "let exists2: (~f: ('a, 'b) => bool, list('a), list('b)) => bool", "docs": "<p>Same as exists, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => bool"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "StdLabels.List", "name": "mem", "type": "let mem: ('a, ~set: list('a)) => bool", "docs": "<p><code>mem a l</code> is true if and only if <code>a</code> is equal to an element of <code>l</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["set", "list('a)"]]}, {"path": "StdLabels.List", "name": "memq", "type": "let memq: ('a, ~set: list('a)) => bool", "docs": "<p>Same as mem, but uses physical equality instead of structural equality to compare list elements.</p>\n", "kind": "value", "args": [["", "'a"], ["set", "list('a)"]]}, {"path": "StdLabels.List", "name": "find", "type": "let find: (~f: 'a => bool, list('a)) => 'a", "docs": "<p><code>find p l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>p</code>. Raise <code>Not_found</code> if there is no value that satisfies <code>p</code> in the list <code>l</code>.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "filter", "type": "let filter: (~f: 'a => bool, list('a)) => list('a)", "docs": "<p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "find_all", "type": "let find_all: (~f: 'a => bool, list('a)) => list('a)", "docs": "<p><code>find_all</code> is another name for filter.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "partition", "type": "let partition: (~f: 'a => bool, list('a)) => (list('a), list('a))", "docs": "<p><code>partition p l</code> returns a pair of lists <code>(l1, l2)</code>, where <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate <code>p</code>, and <code>l2</code> is the list of all the elements of <code>l</code> that do not satisfy <code>p</code>. The order of the elements in the input list is preserved.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "assoc", "type": "let assoc: ('a, list(('a, 'b))) => 'b", "docs": "<p><code>assoc a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc a [ ...; (a,b); ...] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Raise <code>Not_found</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "StdLabels.List", "name": "assq", "type": "let assq: ('a, list(('a, 'b))) => 'b", "docs": "<p>Same as assoc, but uses physical equality instead of structural equality to compare keys.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "StdLabels.List", "name": "mem_assoc", "type": "let mem_assoc: ('a, ~map: list(('a, 'b))) => bool", "docs": "<p>Same as assoc, but simply return true if a binding exists, and false if no bindings exist for the given key.</p>\n", "kind": "value", "args": [["", "'a"], ["map", "list(('a, 'b))"]]}, {"path": "StdLabels.List", "name": "mem_assq", "type": "let mem_assq: ('a, ~map: list(('a, 'b))) => bool", "docs": "<p>Same as mem_assoc, but uses physical equality instead of structural equality to compare keys.</p>\n", "kind": "value", "args": [["", "'a"], ["map", "list(('a, 'b))"]]}, {"path": "StdLabels.List", "name": "remove_assoc", "type": "let remove_assoc: ('a, list(('a, 'b))) => list(('a, 'b))", "docs": "<p><code>remove_assoc a l</code> returns the list of pairs <code>l</code> without the first pair with key <code>a</code>, if any. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "StdLabels.List", "name": "remove_assq", "type": "let remove_assq: ('a, list(('a, 'b))) => list(('a, 'b))", "docs": "<p>Same as remove_assoc, but uses physical equality instead of structural equality to compare keys. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "StdLabels.List", "name": "split", "type": "let split: list(('a, 'b)) => (list('a), list('b))", "docs": "<p>Transform a list of pairs into a pair of lists: <code>split [(a1,b1); ...; (an,bn)]</code> is <code>([a1; ...; an], [b1; ...; bn])</code>. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "list(('a, 'b))"]]}, {"path": "StdLabels.List", "name": "combine", "type": "let combine: (list('a), list('b)) => list(('a, 'b))", "docs": "<p>Transform a pair of lists into a list of pairs: <code>combine [a1; ...; an] [b1; ...; bn]</code> is <code>[(a1,b1); ...; (an,bn)]</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('b)"]]}, {"path": "StdLabels.List", "name": "sort", "type": "let sort: (~cmp: ('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, compare is a suitable comparison function. The resulting list is sorted in increasing order. <code>ListLabels.sort</code> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p>\n<p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "stable_sort", "type": "let stable_sort: (~cmp: ('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Same as sort, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .</p>\n<p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "fast_sort", "type": "let fast_sort: (~cmp: ('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Same as sort or stable_sort, whichever is faster on typical input.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "StdLabels.List", "name": "merge", "type": "let merge: (~cmp: ('a, 'a) => int, list('a), list('a)) => list('a)", "docs": "<p>Merge two lists: Assuming that <code>l1</code> and <code>l2</code> are sorted according to the comparison function <code>cmp</code>, <code>merge cmp l1 l2</code> will return a sorted list containting all the elements of <code>l1</code> and <code>l2</code>. If several elements compare equal, the elements of <code>l1</code> will be before the elements of <code>l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "list('a)"], ["", "list('a)"]]}, {"path": "StdLabels", "name": "List", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>assoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>assq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>combine\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exists\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exists2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fast_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find_all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatten\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_left2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_right2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>for_all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>for_all2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem_assoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem_assq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>memq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove_assoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove_assq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_map2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stable_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tl", "docs": null, "kind": "module"}, {"path": "StdLabels.String", "name": "length", "type": "let length: string => int", "docs": "<p>Return the length (number of characters) of the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels.String", "name": "get", "type": "let get: (string, int) => char", "docs": "<p><code>String.get s n</code> returns the character at index <code>n</code> in string <code>s</code>. You can also write <code>s.[n]</code> instead of <code>String.get s n</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> not a valid index in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "StdLabels.String", "name": "set", "type": "let set: (bytes, int, char) => unit", "docs": "<p><code>String.set s n c</code> modifies byte sequence <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>. You can also write <code>s.[n] &lt;- c</code> instead of <code>String.set s n c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p>\n<p>Deprecated: <p>This is a deprecated alias of set.</p></p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.String", "name": "create", "type": "let create: int => bytes", "docs": "<p><code>String.create n</code> returns a fresh byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n<p>Deprecated: <p>This is a deprecated alias of create.</p></p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "StdLabels.String", "name": "make", "type": "let make: (int, char) => string", "docs": "<p><code>String.make n c</code> returns a fresh string of length <code>n</code>, filled with the character <code>c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["", "char"]]}, {"path": "StdLabels.String", "name": "init", "type": "let init: (int, ~f: int => char) => string", "docs": "<p><code>init n f</code> returns a string of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["f", "int => char"]]}, {"path": "StdLabels.String", "name": "copy", "type": "let copy: string => string", "docs": "<p>Return a copy of the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels.String", "name": "sub", "type": "let sub: (string, ~pos: int, ~len: int) => string", "docs": "<p><code>String.sub s start len</code> returns a fresh string of length <code>len</code>, containing the substring of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid substring of <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["pos", "int"], ["len", "int"]]}, {"path": "StdLabels.String", "name": "fill", "type": "let fill: (bytes, ~pos: int, ~len: int, char) => unit", "docs": "<p><code>String.fill s start len c</code> modifies byte sequence <code>s</code> in place, replacing <code>len</code> bytes by <code>c</code>, starting at <code>start</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid substring of <code>s</code>.</p>\n<p>Deprecated: <p>This is a deprecated alias of fill.</p></p>\n", "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"], ["", "char"]]}, {"path": "StdLabels.String", "name": "blit", "type": "let blit: (~src: string, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit", "docs": "<p><code>String.blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from the string <code>src</code>, starting at index <code>srcoff</code>, to byte sequence <code>dst</code>, starting at character number <code>dstoff</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p>\n", "kind": "value", "args": [["src", "string"], ["src_pos", "int"], ["dst", "bytes"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "StdLabels.String", "name": "concat", "type": "let concat: (~sep: string, list(string)) => string", "docs": "<p><code>String.concat sep sl</code> concatenates the list of strings <code>sl</code>, inserting the separator string <code>sep</code> between each.</p>\n", "kind": "value", "args": [["sep", "string"], ["", "list(string)"]]}, {"path": "StdLabels.String", "name": "iter", "type": "let iter: (~f: char => unit, string) => unit", "docs": "<p><code>String.iter f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code>. It is equivalent to <code>f s.[0]; f s.[1]; ...; f s.[String.length s - 1]; ()</code>.</p>\n", "kind": "value", "args": [["f", "char => unit"], ["", "string"]]}, {"path": "StdLabels.String", "name": "iteri", "type": "let iteri: (~f: (int, char) => unit, string) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the element as first argument (counting from 0), and the character itself as second argument.</p>\nSince: 4.00.0", "kind": "value", "args": [["f", "(int, char) => unit"], ["", "string"]]}, {"path": "StdLabels.String", "name": "map", "type": "let map: (~f: char => char, string) => string", "docs": "<p><code>String.map f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code> and stores the results in a new string that is returned.</p>\nSince: 4.00.0", "kind": "value", "args": [["f", "char => char"], ["", "string"]]}, {"path": "StdLabels.String", "name": "mapi", "type": "let mapi: (~f: (int, char) => char, string) => string", "docs": "<p><code>String.mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the results in a new string that is returned.</p>\nSince: 4.02.0", "kind": "value", "args": [["f", "(int, char) => char"], ["", "string"]]}, {"path": "StdLabels.String", "name": "trim", "type": "let trim: string => string", "docs": "<p>Return a copy of the argument, without leading and trailing whitespace. The characters regarded as whitespace are: <code>&#39; &#39;</code>, <code>&#39;\\012&#39;</code>, <code>&#39;\\n&#39;</code>, <code>&#39;\\r&#39;</code>, and <code>&#39;\\t&#39;</code>. If there is no leading nor trailing whitespace character in the argument, return the original string itself, not a copy.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels.String", "name": "escaped", "type": "let escaped: string => string", "docs": "<p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. If there is no special character in the argument, return the original string itself, not a copy. Its inverse function is Scanf.unescaped.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels.String", "name": "index", "type": "let index: (string, char) => int", "docs": "<p><code>String.index s c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "char"]]}, {"path": "StdLabels.String", "name": "rindex", "type": "let rindex: (string, char) => int", "docs": "<p><code>String.rindex s c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "char"]]}, {"path": "StdLabels.String", "name": "index_from", "type": "let index_from: (string, int, char) => int", "docs": "<p><code>String.index_from s i c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code> after position <code>i</code>. <code>String.index s c</code> is equivalent to <code>String.index_from s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.String", "name": "rindex_from", "type": "let rindex_from: (string, int, char) => int", "docs": "<p><code>String.rindex_from s i c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code> before position <code>i+1</code>. <code>String.rindex s c</code> is equivalent to <code>String.rindex_from s (String.length s - 1) c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.String", "name": "contains", "type": "let contains: (string, char) => bool", "docs": "<p><code>String.contains s c</code> tests if character <code>c</code> appears in the string <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "char"]]}, {"path": "StdLabels.String", "name": "contains_from", "type": "let contains_from: (string, int, char) => bool", "docs": "<p><code>String.contains_from s start c</code> tests if character <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>String.contains s c</code> is equivalent to <code>String.contains_from s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.String", "name": "rcontains_from", "type": "let rcontains_from: (string, int, char) => bool", "docs": "<p><code>String.rcontains_from s stop c</code> tests if character <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.String", "name": "uppercase", "type": "let uppercase: string => string", "docs": "<p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels.String", "name": "lowercase", "type": "let lowercase: string => string", "docs": "<p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels.String", "name": "capitalize", "type": "let capitalize: string => string", "docs": "<p>Return a copy of the argument, with the first character set to uppercase.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels.String", "name": "uncapitalize", "type": "let uncapitalize: string => string", "docs": "<p>Return a copy of the argument, with the first character set to lowercase.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "StdLabels.String", "name": "t", "type": "type t = string", "docs": "<p>An alias for the type of strings.</p>\n", "kind": "type"}, {"path": "StdLabels.String", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for strings, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>String</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "StdLabels.String", "name": "unsafe_get", "type": "let unsafe_get: (string, int) => char", "docs": null, "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "StdLabels.String", "name": "unsafe_set", "type": "let unsafe_set: (bytes, int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "StdLabels.String", "name": "unsafe_blit", "type": "let unsafe_blit: (~src: string, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit", "docs": null, "kind": "value", "args": [["src", "string"], ["src_pos", "int"], ["dst", "bytes"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "StdLabels.String", "name": "unsafe_fill", "type": "let unsafe_fill: (bytes, ~pos: int, ~len: int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"], ["", "char"]]}, {"path": "StdLabels", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>capitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>escaped\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lowercase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rcontains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uncapitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uppercase\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "", "name": "StdLabels", "type": "<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Array\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Bytes\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>List\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String", "docs": null, "kind": "module"}, {"path": "", "name": "Std_exit", "type": "", "docs": null, "kind": "module"}, {"path": "Stack", "name": "t", "type": "type t('a)", "docs": "<p>The type of stacks containing elements of type <code>&#39;a</code>.</p>\n", "kind": "type"}, {"path": "Stack", "name": "create", "type": "let create: unit => t('a)", "docs": "<p>Return a new stack, initially empty.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Stack", "name": "push", "type": "let push: ('a, t('a)) => unit", "docs": "<p><code>push x s</code> adds the element <code>x</code> at the top of stack <code>s</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Stack", "name": "pop", "type": "let pop: t('a) => 'a", "docs": "<p><code>pop s</code> removes and returns the topmost element in stack <code>s</code>, or raises <code>Empty</code> if the stack is empty.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stack", "name": "top", "type": "let top: t('a) => 'a", "docs": "<p><code>top s</code> returns the topmost element in stack <code>s</code>, or raises <code>Empty</code> if the stack is empty.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stack", "name": "clear", "type": "let clear: t('a) => unit", "docs": "<p>Discard all elements from a stack.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stack", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": "<p>Return a copy of the given stack.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stack", "name": "is_empty", "type": "let is_empty: t('a) => bool", "docs": "<p>Return <code>true</code> if the given stack is empty, <code>false</code> otherwise.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stack", "name": "length", "type": "let length: t('a) => int", "docs": "<p>Return the number of elements in a stack.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Stack", "name": "iter", "type": "let iter: ('a => unit, t('a)) => unit", "docs": "<p><code>iter f s</code> applies <code>f</code> in turn to all elements of <code>s</code>, from the element at the top of the stack to the element at the bottom of the stack. The stack itself is unchanged.</p>\n", "kind": "value", "args": [["", "'a => unit"], ["", "t('a)"]]}, {"path": "", "name": "Stack", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>push\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>top\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Sort", "name": "list", "type": "let list: (('a, 'a) => bool, list('a)) => list('a)", "docs": "<p>Sort a list in increasing order according to an ordering predicate. The predicate should return <code>true</code> if its first argument is less than or equal to its second argument.</p>\n", "kind": "value", "args": [["", "('a, 'a) => bool"], ["", "list('a)"]]}, {"path": "Sort", "name": "array", "type": "let array: (('a, 'a) => bool, array('a)) => unit", "docs": "<p>Sort an array in increasing order according to an ordering predicate. The predicate should return <code>true</code> if its first argument is less than or equal to its second argument. The array is sorted in place.</p>\n", "kind": "value", "args": [["", "('a, 'a) => bool"], ["", "array('a)"]]}, {"path": "Sort", "name": "merge", "type": "let merge: (('a, 'a) => bool, list('a), list('a)) => list('a)", "docs": "<p>Merge two lists according to the given predicate. Assuming the two argument lists are sorted according to the predicate, <code>merge</code> returns a sorted list containing the elements from the two lists. The behavior is undefined if the two argument lists were not sorted.</p>\n", "kind": "value", "args": [["", "('a, 'a) => bool"], ["", "list('a)"], ["", "list('a)"]]}, {"path": "", "name": "Sort", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>array\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>list\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge", "docs": null, "kind": "module"}, {"path": "Set", "name": "Make", "type": "", "docs": "<p>Functor building an implementation of the set structure given a totally ordered type.</p>\n", "kind": "module"}, {"path": "", "name": "Set", "type": "<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Make", "docs": null, "kind": "module"}, {"path": "Scanf.Scanning", "name": "in_channel", "type": "type in_channel", "docs": "<p>The notion of input channel for the <code>Scanf</code> module: those channels provide all the machinery necessary to read from a given <code>Pervasives.in_channel</code> value. A <code>Scanf.Scanning.in_channel</code> value is also called a <em>formatted input channel</em> or equivalently a <em>scanning buffer</em>. The type <code>scanbuf</code> below is an alias for <code>in_channel</code>.</p>\nSince: 3.12.0", "kind": "type"}, {"path": "Scanf.Scanning", "name": "scanbuf", "type": "type scanbuf = in_channel", "docs": "<p>The type of scanning buffers. A scanning buffer is the source from which a formatted input function gets characters. The scanning buffer holds the current state of the scan, plus a function to get the next char from the input, and a token buffer to store the string matched so far.</p>\n<p>Note: a scanning action may often require to examine one character in advance; when this &#39;lookahead&#39; character does not belong to the token read, it is stored back in the scanning buffer and becomes the next character yet to be read.</p>\n", "kind": "type"}, {"path": "Scanf.Scanning", "name": "stdin", "type": "let stdin: in_channel", "docs": "<p>The standard input notion for the <code>Scanf</code> module. <code>Scanning.stdin</code> is the formatted input channel attached to <code>Pervasives.stdin</code>.</p>\n<p>Note: in the interactive system, when input is read from <code>stdin</code>, the newline character that triggers the evaluation is incorporated in the input; thus, the scanning specifications must properly skip this additional newline character (for instance, simply add a <code>&#39;\\n&#39;</code> as the last character of the format string).</p>\nSince: 3.12.0", "kind": "value"}, {"path": "Scanf.Scanning", "name": "file_name", "type": "type file_name = string", "docs": "<p>A convenient alias to designate a file name.</p>\nSince: 4.00.0", "kind": "type"}, {"path": "Scanf.Scanning", "name": "open_in", "type": "let open_in: file_name => in_channel", "docs": "<p><code>Scanning.open_in fname</code> returns a formatted input channel for bufferized reading in text mode from file <code>fname</code>.</p>\n<p>Note: <code>open_in</code> returns a formatted input channel that efficiently reads characters in large chunks; in contrast, <code>from_channel</code> below returns formatted input channels that must read one character at a time, leading to a much slower scanning rate.</p>\nSince: 3.12.0", "kind": "value", "args": [["", "file_name"]]}, {"path": "Scanf.Scanning", "name": "open_in_bin", "type": "let open_in_bin: file_name => in_channel", "docs": "<p><code>Scanning.open_in_bin fname</code> returns a formatted input channel for bufferized reading in binary mode from file <code>fname</code>.</p>\nSince: 3.12.0", "kind": "value", "args": [["", "file_name"]]}, {"path": "Scanf.Scanning", "name": "close_in", "type": "let close_in: in_channel => unit", "docs": "<p>Closes the <code>Pervasives.in_channel</code> associated with the given <code>Scanning.in_channel</code> formatted input channel.</p>\nSince: 3.12.0", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Scanf.Scanning", "name": "from_file", "type": "let from_file: file_name => in_channel", "docs": "<p>An alias for <code>open_in</code> above.</p>\n", "kind": "value", "args": [["", "file_name"]]}, {"path": "Scanf.Scanning", "name": "from_file_bin", "type": "let from_file_bin: string => in_channel", "docs": "<p>An alias for <code>open_in_bin</code> above.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Scanf.Scanning", "name": "from_string", "type": "let from_string: string => in_channel", "docs": "<p><code>Scanning.from_string s</code> returns a formatted input channel which reads from the given string. Reading starts from the first character in the string. The end-of-input condition is set when the end of the string is reached.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Scanf.Scanning", "name": "from_function", "type": "let from_function: unit => char => in_channel", "docs": "<p><code>Scanning.from_function f</code> returns a formatted input channel with the given function as its reading method.</p>\n<p>When scanning needs one more character, the given function is called.</p>\n<p>When the function has no more character to provide, it <em>must</em> signal an end-of-input condition by raising the exception <code>End_of_file</code>.</p>\n", "kind": "value", "args": [["", "unit => char"]]}, {"path": "Scanf.Scanning", "name": "from_channel", "type": "let from_channel: Pervasives.in_channel => in_channel", "docs": "<p><code>Scanning.from_channel ic</code> returns a formatted input channel which reads from the regular input channel <code>ic</code> argument, starting at the current reading position.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "Scanf.Scanning", "name": "end_of_input", "type": "let end_of_input: in_channel => bool", "docs": "<p><code>Scanning.end_of_input ic</code> tests the end-of-input condition of the given formatted input channel.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Scanf.Scanning", "name": "beginning_of_input", "type": "let beginning_of_input: in_channel => bool", "docs": "<p><code>Scanning.beginning_of_input ic</code> tests the beginning of input condition of the given formatted input channel.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Scanf.Scanning", "name": "name_of_input", "type": "let name_of_input: in_channel => string", "docs": "<p><code>Scanning.name_of_input ic</code> returns the name of the character source for the formatted input channel <code>ic</code>.</p>\nSince: 3.09.0", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Scanf.Scanning", "name": "stdib", "type": "let stdib: in_channel", "docs": "<p>A deprecated alias for <code>Scanning.stdin</code>, the scanning buffer reading from <code>Pervasives.stdin</code>.</p>\n", "kind": "value"}, {"path": "Scanf", "name": "Scanning", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>beginning_of_input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>end_of_input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_file\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_file_bin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_function\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>name_of_input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_in_bin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stdib\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stdin\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>file_name\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>in_channel\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>scanbuf", "docs": null, "kind": "module"}, {"path": "Scanf", "name": "scanner", "type": "type scanner('a, 'b, 'c, 'd) = Pervasives.format6(\n  'a,\n  Scanning.in_channel,\n  'b,\n  'c,\n  'a => 'd,\n  'd\n) => 'c", "docs": "<p>The type of formatted input scanners: <code>(&#39;a, &#39;b, &#39;c, &#39;d) scanner</code> is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if <code>scan</code> is some formatted input function, then <code>scan\n    ic fmt f</code> applies <code>f</code> to the arguments specified by the format string <code>fmt</code>, when <code>scan</code> has read those arguments from the formatted input channel <code>ic</code>.</p>\n<p>For instance, the <code>scanf</code> function below has type <code>(&#39;a, &#39;b, &#39;c, &#39;d)\n    scanner</code>, since it is a formatted input function that reads from <code>Scanning.stdin</code>: <code>scanf fmt f</code> applies <code>f</code> to the arguments specified by <code>fmt</code>, reading those arguments from <code>Pervasives.stdin</code> as expected.</p>\n<p>If the format <code>fmt</code> has some <code>%r</code> indications, the corresponding input functions must be provided before the receiver <code>f</code> argument. For instance, if <code>read_elem</code> is an input function for values of type <code>t</code>, then <code>bscanf ic &quot;%r;&quot; read_elem f</code> reads a value <code>v</code> of type <code>t</code> followed by a <code>&#39;;&#39;</code> character, and returns <code>f v</code>.</p>\nSince: 3.10.0", "kind": "type"}, {"path": "Scanf", "name": "bscanf", "type": "let bscanf: Scanning.in_channel => scanner('a, 'b, 'c, 'd)", "docs": "<p><code>bscanf ic fmt r1 ... rN f</code> reads arguments for the function <code>f</code>, from the formatted input channel <code>ic</code>, according to the format string <code>fmt</code>, and applies <code>f</code> to these values. The result of this call to <code>f</code> is returned as the result of the entire <code>bscanf</code> call. For instance, if <code>f</code> is the function <code>fun s i -&gt; i + 1</code>, then <code>Scanf.sscanf &quot;x=  1&quot; &quot;%s = %i&quot; f</code> returns <code>2</code>.</p>\n<p>Arguments <code>r1</code> to <code>rN</code> are user-defined input functions that read the argument corresponding to the <code>%r</code> conversions specified in the format string.</p>\n", "kind": "value", "args": [["", "Scanning.in_channel"]]}, {"path": "Scanf", "name": "fscanf", "type": "let fscanf: Pervasives.in_channel => scanner('a, 'b, 'c, 'd)", "docs": "<p>Same as bscanf, but reads from the given regular input channel.</p>\n<p>Warning: since all formatted input functions operate from a <em>formatted input channel</em>, be aware that each <code>fscanf</code> invocation will operate with a formatted input channel reading from the given channel. This extra level of bufferization can lead to a strange scanning behaviour if you use low level primitives on the channel (reading characters, seeking the reading position, and so on).</p>\n<p>As a consequence, never mix direct low level reading and high level scanning from the same regular input channel.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "Scanf", "name": "sscanf", "type": "let sscanf: string => scanner('a, 'b, 'c, 'd)", "docs": "<p>Same as bscanf, but reads from the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Scanf", "name": "scanf", "type": "let scanf: scanner('a, 'b, 'c, 'd)", "docs": "<p>Same as bscanf, but reads from the predefined formatted input channel stdin that is connected to <code>Pervasives.stdin</code>.</p>\n", "kind": "value"}, {"path": "Scanf", "name": "kscanf", "type": "let kscanf: (Scanning.in_channel, (Scanning.in_channel, exn) => 'd) => scanner('a, 'b, 'c, 'd)", "docs": "<p>Same as bscanf, but takes an additional function argument <code>ef</code> that is called in case of error: if the scanning process or some conversion fails, the scanning function aborts and calls the error handling function <code>ef</code> with the formatted input channel and the exception that aborted the scanning process as arguments.</p>\n", "kind": "value", "args": [["", "Scanning.in_channel"], ["", "(Scanning.in_channel, exn) => 'd"]]}, {"path": "Scanf", "name": "ksscanf", "type": "let ksscanf: (string, (Scanning.in_channel, exn) => 'd) => scanner('a, 'b, 'c, 'd)", "docs": "<p>Same as kscanf but reads from the given string.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "string"], ["", "(Scanning.in_channel, exn) => 'd"]]}, {"path": "Scanf", "name": "kfscanf", "type": "let kfscanf: (Pervasives.in_channel, (Scanning.in_channel, exn) => 'd) => scanner('a, 'b, 'c, 'd)", "docs": "<p>Same as kscanf, but reads from the given regular input channel.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "Pervasives.in_channel"], ["", "(Scanning.in_channel, exn) => 'd"]]}, {"path": "Scanf", "name": "bscanf_format", "type": "let bscanf_format: (\n  Scanning.in_channel,\n  Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f),\n  Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f) => 'g\n) => 'g", "docs": "<p><code>bscanf_format ic fmt f</code> reads a format string token from the formatted input channel <code>ic</code>, according to the given format string <code>fmt</code>, and applies <code>f</code> to the resulting format string value. Raise <code>Scan_failure</code> if the format string value read does not have the same type as <code>fmt</code>.</p>\nSince: 3.09.0", "kind": "value", "args": [["", "Scanning.in_channel"], ["", "Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f)"], ["", "Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f) => 'g"]]}, {"path": "Scanf", "name": "sscanf_format", "type": "let sscanf_format: (\n  string,\n  Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f),\n  Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f) => 'g\n) => 'g", "docs": "<p>Same as bscanf_format, but reads from the given string.</p>\nSince: 3.09.0", "kind": "value", "args": [["", "string"], ["", "Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f)"], ["", "Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f) => 'g"]]}, {"path": "Scanf", "name": "format_from_string", "type": "let format_from_string: (string, Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f)) => Pervasives.format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n)", "docs": "<p><code>format_from_string s fmt</code> converts a string argument to a format string, according to the given format string <code>fmt</code>. Raise <code>Scan_failure</code> if <code>s</code>, considered as a format string, does not have the same type as <code>fmt</code>.</p>\nSince: 3.10.0", "kind": "value", "args": [["", "string"], ["", "Pervasives.format6('a, 'b, 'c, 'd, 'e, 'f)"]]}, {"path": "Scanf", "name": "unescaped", "type": "let unescaped: string => string", "docs": "<p>Return a copy of the argument with escape sequences, following the lexical conventions of OCaml, replaced by their corresponding special characters. If there is no escape sequence in the argument, still return a copy, contrary to String.escaped.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "Scanf", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bscanf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bscanf_format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format_from_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fscanf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kfscanf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kscanf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ksscanf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>scanf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sscanf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sscanf_format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unescaped\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>scanner\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Scanning", "docs": null, "kind": "module"}, {"path": "Random", "name": "init", "type": "let init: int => unit", "docs": "<p>Initialize the generator, using the argument as a seed. The same seed will always yield the same sequence of numbers.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Random", "name": "full_init", "type": "let full_init: array(int) => unit", "docs": "<p>Same as init but takes more data as seed.</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "Random", "name": "self_init", "type": "let self_init: unit => unit", "docs": "<p>Initialize the generator with a random seed chosen in a system-dependent way. If <code>/dev/urandom</code> is available on the host machine, it is used to provide a highly random initial seed. Otherwise, a less random seed is computed from system parameters (current time, process IDs).</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Random", "name": "bits", "type": "let bits: unit => int", "docs": "<p>Return 30 random bits in a nonnegative integer.</p>\nUnhandled tag", "kind": "value", "args": [["", "unit"]]}, {"path": "Random", "name": "int", "type": "let int: int => int", "docs": "<p><code>Random.int bound</code> returns a random integer between 0 (inclusive) and <code>bound</code> (exclusive). <code>bound</code> must be greater than 0 and less than 2Superscript.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Random", "name": "int32", "type": "let int32: Int32.t => Int32.t", "docs": null, "kind": "value", "args": [["", "Int32.t"]]}, {"path": "Random", "name": "nativeint", "type": "let nativeint: Nativeint.t => Nativeint.t", "docs": null, "kind": "value", "args": [["", "Nativeint.t"]]}, {"path": "Random", "name": "int64", "type": "let int64: Int64.t => Int64.t", "docs": null, "kind": "value", "args": [["", "Int64.t"]]}, {"path": "Random", "name": "float", "type": "let float: float => float", "docs": "<p><code>Random.float bound</code> returns a random floating-point number between 0 and <code>bound</code> (inclusive). If <code>bound</code> is negative, the result is negative or zero. If <code>bound</code> is 0, the result is 0.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Random", "name": "bool", "type": "let bool: unit => bool", "docs": "<p><code>Random.bool ()</code> returns <code>true</code> or <code>false</code> with probability 0.5 each.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Random.State", "name": "t", "type": "type t", "docs": "<p>The type of PRNG states.</p>\n", "kind": "type"}, {"path": "Random.State", "name": "make", "type": "let make: array(int) => t", "docs": "<p>Create a new state and initialize it with the given seed.</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "Random.State", "name": "make_self_init", "type": "let make_self_init: unit => t", "docs": "<p>Create a new state and initialize it with a system-dependent low-entropy seed.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Random.State", "name": "copy", "type": "let copy: t => t", "docs": "<p>Return a copy of the given state.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Random.State", "name": "bits", "type": "let bits: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Random.State", "name": "int", "type": "let int: (t, int) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Random.State", "name": "int32", "type": "let int32: (t, Int32.t) => Int32.t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Int32.t"]]}, {"path": "Random.State", "name": "nativeint", "type": "let nativeint: (t, Nativeint.t) => Nativeint.t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Nativeint.t"]]}, {"path": "Random.State", "name": "int64", "type": "let int64: (t, Int64.t) => Int64.t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Int64.t"]]}, {"path": "Random.State", "name": "float", "type": "let float: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Random.State", "name": "bool", "type": "let bool: t => bool", "docs": "<p>These functions are the same as the basic functions, except that they use (and update) the given PRNG state instead of the default one.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Random", "name": "State", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bits\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bool\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int64\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_self_init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nativeint\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Random", "name": "get_state", "type": "let get_state: unit => State.t", "docs": "<p>Return the current state of the generator used by the basic functions.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Random", "name": "set_state", "type": "let set_state: State.t => unit", "docs": "<p>Set the state of the generator used by the basic functions.</p>\n", "kind": "value", "args": [["", "State.t"]]}, {"path": "", "name": "Random", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bits\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bool\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>full_init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_state\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int64\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nativeint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>self_init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_state\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>State", "docs": null, "kind": "module"}, {"path": "Queue", "name": "t", "type": "type t('a)", "docs": "<p>The type of queues containing elements of type <code>&#39;a</code>.</p>\n", "kind": "type"}, {"path": "Queue", "name": "create", "type": "let create: unit => t('a)", "docs": "<p>Return a new queue, initially empty.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Queue", "name": "add", "type": "let add: ('a, t('a)) => unit", "docs": "<p><code>add x q</code> adds the element <code>x</code> at the end of the queue <code>q</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Queue", "name": "push", "type": "let push: ('a, t('a)) => unit", "docs": "<p><code>push</code> is a synonym for <code>add</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Queue", "name": "take", "type": "let take: t('a) => 'a", "docs": "<p><code>take q</code> removes and returns the first element in queue <code>q</code>, or raises <code>Empty</code> if the queue is empty.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Queue", "name": "pop", "type": "let pop: t('a) => 'a", "docs": "<p><code>pop</code> is a synonym for <code>take</code>.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Queue", "name": "peek", "type": "let peek: t('a) => 'a", "docs": "<p><code>peek q</code> returns the first element in queue <code>q</code>, without removing it from the queue, or raises <code>Empty</code> if the queue is empty.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Queue", "name": "top", "type": "let top: t('a) => 'a", "docs": "<p><code>top</code> is a synonym for <code>peek</code>.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Queue", "name": "clear", "type": "let clear: t('a) => unit", "docs": "<p>Discard all elements from a queue.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Queue", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": "<p>Return a copy of the given queue.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Queue", "name": "is_empty", "type": "let is_empty: t('a) => bool", "docs": "<p>Return <code>true</code> if the given queue is empty, <code>false</code> otherwise.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Queue", "name": "length", "type": "let length: t('a) => int", "docs": "<p>Return the number of elements in a queue.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Queue", "name": "iter", "type": "let iter: ('a => unit, t('a)) => unit", "docs": "<p><code>iter f q</code> applies <code>f</code> in turn to all elements of <code>q</code>, from the least recently entered to the most recently entered. The queue itself is unchanged.</p>\n", "kind": "value", "args": [["", "'a => unit"], ["", "t('a)"]]}, {"path": "Queue", "name": "fold", "type": "let fold: (('b, 'a) => 'b, 'b, t('a)) => 'b", "docs": "<p><code>fold f accu q</code> is equivalent to <code>List.fold_left f accu l</code>, where <code>l</code> is the list of <code>q</code>&#39;s elements. The queue remains unchanged.</p>\n", "kind": "value", "args": [["", "('b, 'a) => 'b"], ["", "'b"], ["", "t('a)"]]}, {"path": "Queue", "name": "transfer", "type": "let transfer: (t('a), t('a)) => unit", "docs": "<p><code>transfer q1 q2</code> adds all of <code>q1</code>&#39;s elements at the end of the queue <code>q2</code>, then clears <code>q1</code>. It is equivalent to the sequence <code>iter (fun x -&gt; add x q2) q1; clear q1</code>, but runs in constant time.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "", "name": "Queue", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>peek\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>push\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>take\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>top\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>transfer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Printf", "name": "fprintf", "type": "let fprintf: (Pervasives.out_channel, Pervasives.format('a, Pervasives.out_channel, unit)) => 'a", "docs": "<p><code>fprintf outchan format arg1 ... argN</code> formats the arguments <code>arg1</code> to <code>argN</code> according to the format string <code>format</code>, and outputs the resulting string on the channel <code>outchan</code>.</p>\n<p>The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments.</p>\n<p>Conversion specifications have the following form:</p>\n<p><code>% [flags] [width] [.precision] type</code></p>\n<p>In short, a conversion specification consists in the <code>%</code> character, followed by optional modifiers and a type which is made of one or two characters.</p>\n<p>The types and their meanings are:</p>\n<ul><li><p><code>d</code>, <code>i</code>: convert an integer argument to signed decimal.</p>\n</li><li><p><code>u</code>, <code>n</code>, <code>l</code>, <code>L</code>, or <code>N</code>: convert an integer argument to unsigned decimal. Warning: <code>n</code>, <code>l</code>, <code>L</code>, and <code>N</code> are used for <code>scanf</code>, and should not be used for <code>printf</code>.</p>\n</li><li><p><code>x</code>: convert an integer argument to unsigned hexadecimal, using lowercase letters.</p>\n</li><li><p><code>X</code>: convert an integer argument to unsigned hexadecimal, using uppercase letters.</p>\n</li><li><p><code>o</code>: convert an integer argument to unsigned octal.</p>\n</li><li><p><code>s</code>: insert a string argument.</p>\n</li><li><p><code>S</code>: convert a string argument to OCaml syntax (double quotes, escapes).</p>\n</li><li><p><code>c</code>: insert a character argument.</p>\n</li><li><p><code>C</code>: convert a character argument to OCaml syntax (single quotes, escapes).</p>\n</li><li><p><code>f</code>: convert a floating-point argument to decimal notation, in the style <code>dddd.ddd</code>.</p>\n</li><li><p><code>F</code>: convert a floating-point argument to OCaml syntax (<code>dddd.</code> or <code>dddd.ddd</code> or <code>d.ddd e+-dd</code>).</p>\n</li><li><p><code>e</code> or <code>E</code>: convert a floating-point argument to decimal notation, in the style <code>d.ddd e+-dd</code> (mantissa and exponent).</p>\n</li><li><p><code>g</code> or <code>G</code>: convert a floating-point argument to decimal notation, in style <code>f</code> or <code>e</code>, <code>E</code> (whichever is more compact).</p>\n</li><li><p><code>B</code>: convert a boolean argument to the string <code>true</code> or <code>false</code></p>\n</li><li><p><code>b</code>: convert a boolean argument (deprecated; do not use in new programs).</p>\n</li><li><p><code>ld</code>, <code>li</code>, <code>lu</code>, <code>lx</code>, <code>lX</code>, <code>lo</code>: convert an <code>int32</code> argument to the format specified by the second letter (decimal, hexadecimal, etc).</p>\n</li><li><p><code>nd</code>, <code>ni</code>, <code>nu</code>, <code>nx</code>, <code>nX</code>, <code>no</code>: convert a <code>nativeint</code> argument to the format specified by the second letter.</p>\n</li><li><p><code>Ld</code>, <code>Li</code>, <code>Lu</code>, <code>Lx</code>, <code>LX</code>, <code>Lo</code>: convert an <code>int64</code> argument to the format specified by the second letter.</p>\n</li><li><p><code>a</code>: user-defined printer. Take two arguments and apply the first one to <code>outchan</code> (the current output channel) and to the second argument. The first argument must therefore have type <code>out_channel -&gt; &#39;b -&gt; unit</code> and the second <code>&#39;b</code>. The output produced by the function is inserted in the output of <code>fprintf</code> at the current point.</p>\n</li><li><p><code>t</code>: same as <code>%a</code>, but take only one argument (with type <code>out_channel -&gt; unit</code>) and apply it to <code>outchan</code>.</p>\n</li><li><p><code>\\{ fmt %\\}</code>: convert a format string argument to its type digest. The argument must have the same type as the internal format string <code>fmt</code>.</p>\n</li><li><p><code>( fmt %)</code>: format string substitution. Take a format string argument and substitute it to the internal format string <code>fmt</code> to print following arguments. The argument must have the same type as the internal format string <code>fmt</code>.</p>\n</li><li><p><code>!</code>: take no argument and flush the output.</p>\n</li><li><p><code>%</code>: take no argument and output one <code>%</code> character.</p>\n</li><li><p><code>\\@</code>: take no argument and output one <code>\\@</code> character.</p>\n</li><li><p><code>,</code>: take no argument and output nothing: a no-op delimiter for conversion specifications.</p>\n</li></ul><p>The optional <code>flags</code> are:</p>\n<ul><li><p><code>-</code>: left-justify the output (default is right justification).</p>\n</li><li><p><code>0</code>: for numerical conversions, pad with zeroes instead of spaces.</p>\n</li><li><p><code>+</code>: for signed numerical conversions, prefix number with a <code>+</code> sign if positive.</p>\n</li><li><p>space: for signed numerical conversions, prefix number with a space if positive.</p>\n</li><li><p><code>#</code>: request an alternate formatting style for the hexadecimal and octal integer types (<code>x</code>, <code>X</code>, <code>o</code>, <code>lx</code>, <code>lX</code>, <code>lo</code>, <code>Lx</code>, <code>LX</code>, <code>Lo</code>).</p>\n</li></ul><p>The optional <code>width</code> is an integer indicating the minimal width of the result. For instance, <code>%6d</code> prints an integer, prefixing it with spaces to fill at least 6 characters.</p>\n<p>The optional <code>precision</code> is a dot <code>.</code> followed by an integer indicating how many digits follow the decimal point in the <code>%f</code>, <code>%e</code>, and <code>%E</code> conversions. For instance, <code>%.4f</code> prints a <code>float</code> with 4 fractional digits.</p>\n<p>The integer in a <code>width</code> or <code>precision</code> can also be specified as <code>*</code>, in which case an extra integer argument is taken to specify the corresponding <code>width</code> or <code>precision</code>. This integer argument precedes immediately the argument to print. For instance, <code>%.*f</code> prints a <code>float</code> with as many fractional digits as the value of the argument given before the float.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"], ["", "Pervasives.format('a, Pervasives.out_channel, unit)"]]}, {"path": "Printf", "name": "printf", "type": "let printf: Pervasives.format('a, Pervasives.out_channel, unit) => 'a", "docs": "<p>Same as fprintf, but output on <code>stdout</code>.</p>\n", "kind": "value", "args": [["", "Pervasives.format('a, Pervasives.out_channel, unit)"]]}, {"path": "Printf", "name": "eprintf", "type": "let eprintf: Pervasives.format('a, Pervasives.out_channel, unit) => 'a", "docs": "<p>Same as fprintf, but output on <code>stderr</code>.</p>\n", "kind": "value", "args": [["", "Pervasives.format('a, Pervasives.out_channel, unit)"]]}, {"path": "Printf", "name": "sprintf", "type": "let sprintf: Pervasives.format('a, unit, string) => 'a", "docs": "<p>Same as fprintf, but instead of printing on an output channel, return a string containing the result of formatting the arguments.</p>\n", "kind": "value", "args": [["", "Pervasives.format('a, unit, string)"]]}, {"path": "Printf", "name": "bprintf", "type": "let bprintf: (Buffer.t, Pervasives.format('a, Buffer.t, unit)) => 'a", "docs": "<p>Same as fprintf, but instead of printing on an output channel, append the formatted arguments to the given extensible buffer (see module Buffer).</p>\n", "kind": "value", "args": [["", "Buffer.t"], ["", "Pervasives.format('a, Buffer.t, unit)"]]}, {"path": "Printf", "name": "ifprintf", "type": "let ifprintf: ('a, Pervasives.format('b, 'a, unit)) => 'b", "docs": "<p>Same as fprintf, but does not print anything. Useful to ignore some material when conditionally printing.</p>\nSince: 3.10.0", "kind": "value", "args": [["", "'a"], ["", "Pervasives.format('b, 'a, unit)"]]}, {"path": "Printf", "name": "kfprintf", "type": "let kfprintf: (\n  Pervasives.out_channel => 'a,\n  Pervasives.out_channel,\n  Pervasives.format4('b, Pervasives.out_channel, unit, 'a)\n) => 'b", "docs": "<p>Same as <code>fprintf</code>, but instead of returning immediately, passes the out channel to its first argument at the end of printing.</p>\nSince: 3.09.0", "kind": "value", "args": [["", "Pervasives.out_channel => 'a"], ["", "Pervasives.out_channel"], ["", "Pervasives.format4('b, Pervasives.out_channel, unit, 'a)"]]}, {"path": "Printf", "name": "ikfprintf", "type": "let ikfprintf: (\n  Pervasives.out_channel => 'a,\n  Pervasives.out_channel,\n  Pervasives.format4('b, Pervasives.out_channel, unit, 'a)\n) => 'b", "docs": "<p>Same as <code>kfprintf</code> above, but does not print anything. Useful to ignore some material when conditionally printing.</p>\nSince: 4.0", "kind": "value", "args": [["", "Pervasives.out_channel => 'a"], ["", "Pervasives.out_channel"], ["", "Pervasives.format4('b, Pervasives.out_channel, unit, 'a)"]]}, {"path": "Printf", "name": "ksprintf", "type": "let ksprintf: (string => 'a, Pervasives.format4('b, unit, string, 'a)) => 'b", "docs": "<p>Same as <code>sprintf</code> above, but instead of returning the string, passes it to the first argument.</p>\nSince: 3.09.0", "kind": "value", "args": [["", "string => 'a"], ["", "Pervasives.format4('b, unit, string, 'a)"]]}, {"path": "Printf", "name": "kbprintf", "type": "let kbprintf: (Buffer.t => 'a, Buffer.t, Pervasives.format4('b, Buffer.t, unit, 'a)) => 'b", "docs": "<p>Same as <code>bprintf</code>, but instead of returning immediately, passes the buffer to its first argument at the end of printing.</p>\nSince: 3.10.0", "kind": "value", "args": [["", "Buffer.t => 'a"], ["", "Buffer.t"], ["", "Pervasives.format4('b, Buffer.t, unit, 'a)"]]}, {"path": "Printf", "name": "kprintf", "type": "let kprintf: (string => 'a, Pervasives.format4('b, unit, string, 'a)) => 'b", "docs": "<p>A deprecated synonym for <code>ksprintf</code>.</p>\n", "kind": "value", "args": [["", "string => 'a"], ["", "Pervasives.format4('b, unit, string, 'a)"]]}, {"path": "", "name": "Printf", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ifprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ikfprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kbprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kfprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ksprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>printf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sprintf", "docs": null, "kind": "module"}, {"path": "Printexc", "name": "to_string", "type": "let to_string: exn => string", "docs": "<p><code>Printexc.to_string e</code> returns a string representation of the exception <code>e</code>.</p>\n", "kind": "value", "args": [["", "exn"]]}, {"path": "Printexc", "name": "print", "type": "let print: ('a => 'b, 'a) => 'b", "docs": "<p><code>Printexc.print fn x</code> applies <code>fn</code> to <code>x</code> and returns the result. If the evaluation of <code>fn x</code> raises any exception, the name of the exception is printed on standard error output, and the exception is raised again. The typical use is to catch and report exceptions that escape a function application.</p>\n", "kind": "value", "args": [["", "'a => 'b"], ["", "'a"]]}, {"path": "Printexc", "name": "catch", "type": "let catch: ('a => 'b, 'a) => 'b", "docs": "<p><code>Printexc.catch fn x</code> is similar to print, but aborts the program with exit code 2 after printing the uncaught exception. This function is deprecated: the runtime system is now able to print uncaught exceptions as precisely as <code>Printexc.catch</code> does. Moreover, calling <code>Printexc.catch</code> makes it harder to track the location of the exception using the debugger or the stack backtrace facility. So, do not use <code>Printexc.catch</code> in new code.</p>\n", "kind": "value", "args": [["", "'a => 'b"], ["", "'a"]]}, {"path": "Printexc", "name": "print_backtrace", "type": "let print_backtrace: Pervasives.out_channel => unit", "docs": "<p><code>Printexc.print_backtrace oc</code> prints an exception backtrace on the output channel <code>oc</code>. The backtrace lists the program locations where the most-recently raised exception was raised and where it was propagated through function calls.</p>\nSince: 3.11.0", "kind": "value", "args": [["", "Pervasives.out_channel"]]}, {"path": "Printexc", "name": "get_backtrace", "type": "let get_backtrace: unit => string", "docs": "<p><code>Printexc.get_backtrace ()</code> returns a string containing the same exception backtrace that <code>Printexc.print_backtrace</code> would print.</p>\nSince: 3.11.0", "kind": "value", "args": [["", "unit"]]}, {"path": "Printexc", "name": "record_backtrace", "type": "let record_backtrace: bool => unit", "docs": "<p><code>Printexc.record_backtrace b</code> turns recording of exception backtraces on (if <code>b = true</code>) or off (if <code>b = false</code>). Initially, backtraces are not recorded, unless the <code>b</code> flag is given to the program through the <code>OCAMLRUNPARAM</code> variable.</p>\nSince: 3.11.0", "kind": "value", "args": [["", "bool"]]}, {"path": "Printexc", "name": "backtrace_status", "type": "let backtrace_status: unit => bool", "docs": "<p><code>Printexc.backtrace_status()</code> returns <code>true</code> if exception backtraces are currently recorded, <code>false</code> if not.</p>\nSince: 3.11.0", "kind": "value", "args": [["", "unit"]]}, {"path": "Printexc", "name": "register_printer", "type": "let register_printer: exn => option(string) => unit", "docs": "<p><code>Printexc.register_printer fn</code> registers <code>fn</code> as an exception printer. The printer should return <code>None</code> or raise an exception if it does not know how to convert the passed exception, and <code>Some\n    s</code> with <code>s</code> the resulting string if it can convert the passed exception. Exceptions raised by the printer are ignored.</p>\n<p>When converting an exception into a string, the printers will be invoked in the reverse order of their registrations, until a printer returns a <code>Some s</code> value (if no such printer exists, the runtime will use a generic printer).</p>\n<p>When using this mechanism, one should be aware that an exception backtrace is attached to the thread that saw it raised, rather than to the exception itself. Practically, it means that the code related to <code>fn</code> should not use the backtrace if it has itself raised an exception before.</p>\nSince: 3.11.2", "kind": "value", "args": [["", "exn => option(string)"]]}, {"path": "Printexc", "name": "raw_backtrace", "type": "type raw_backtrace", "docs": "<p>The abstract type <code>raw_backtrace</code> stores a backtrace in a low-level format, instead of directly exposing them as string as the <code>get_backtrace()</code> function does.</p>\n<p>This allows delaying the formatting of backtraces to when they are actually printed, which may be useful if you record more backtraces than you print.</p>\n<p>Raw backtraces cannot be marshalled. If you need marshalling, you should use the array returned by the <code>backtrace_slots</code> function of the next section.</p>\nSince: 4.01.0", "kind": "type"}, {"path": "Printexc", "name": "get_raw_backtrace", "type": "let get_raw_backtrace: unit => raw_backtrace", "docs": "<p><code>Printexc.get_raw_backtrace ()</code> returns the same exception backtrace that <code>Printexc.print_backtrace</code> would print, but in a raw format.</p>\nSince: 4.01.0", "kind": "value", "args": [["", "unit"]]}, {"path": "Printexc", "name": "print_raw_backtrace", "type": "let print_raw_backtrace: (Pervasives.out_channel, raw_backtrace) => unit", "docs": "<p>Print a raw backtrace in the same format <code>Printexc.print_backtrace</code> uses.</p>\nSince: 4.01.0", "kind": "value", "args": [["", "Pervasives.out_channel"], ["", "raw_backtrace"]]}, {"path": "Printexc", "name": "raw_backtrace_to_string", "type": "let raw_backtrace_to_string: raw_backtrace => string", "docs": "<p>Return a string from a raw backtrace, in the same format <code>Printexc.get_backtrace</code> uses.</p>\nSince: 4.01.0", "kind": "value", "args": [["", "raw_backtrace"]]}, {"path": "Printexc", "name": "get_callstack", "type": "let get_callstack: int => raw_backtrace", "docs": "<p><code>Printexc.get_callstack n</code> returns a description of the top of the call stack on the current program point (for the current thread), with at most <code>n</code> entries. (Note: this function is not related to exceptions at all, despite being part of the <code>Printexc</code> module.)</p>\nSince: 4.01.0", "kind": "value", "args": [["", "int"]]}, {"path": "Printexc", "name": "set_uncaught_exception_handler", "type": "let set_uncaught_exception_handler: (exn, raw_backtrace) => unit => unit", "docs": "<p><code>Printexc.set_uncaught_exception_handler fn</code> registers <code>fn</code> as the handler for uncaught exceptions. The default handler prints the exception and backtrace on standard error output.</p>\n<p>Note that when <code>fn</code> is called all the functions registered with at_exit have already been called. Because of this you must make sure any output channel <code>fn</code> writes on is flushed.</p>\n<p>Also note that exceptions raised by user code in the interactive toplevel are not passed to this function as they are caught by the toplevel itself.</p>\n<p>If <code>fn</code> raises an exception, both the exceptions passed to <code>fn</code> and raised by <code>fn</code> will be printed with their respective backtrace.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "(exn, raw_backtrace) => unit"]]}, {"path": "Printexc", "name": "backtrace_slot", "type": "type backtrace_slot", "docs": "<p>The abstract type <code>backtrace_slot</code> represents a single slot of a backtrace.</p>\nSince: 4.02", "kind": "type"}, {"path": "Printexc", "name": "backtrace_slots", "type": "let backtrace_slots: raw_backtrace => option(array(backtrace_slot))", "docs": "<p>Returns the slots of a raw backtrace, or <code>None</code> if none of them contain useful information.</p>\n<p>In the return array, the slot at index <code>0</code> corresponds to the most recent function call, raise, or primitive <code>get_backtrace</code> call in the trace.</p>\n<p>Some possible reasons for returning <code>None</code> are as follow:</p>\n<ul><li><p>none of the slots in the trace come from modules compiled with debug information (<code>-g</code>)</p>\n</li><li><p>the program is a bytecode program that has not been linked with debug information enabled (<code>ocamlc -g</code>)</p>\n</li></ul>Since: 4.02.0", "kind": "value", "args": [["", "raw_backtrace"]]}, {"path": "Printexc", "name": "location", "type": "type location = {filename: string, line_number: int, start_char: int, end_char: int}", "docs": "<p>The type of location information found in backtraces. <code>start_char</code> and <code>end_char</code> are positions relative to the beginning of the line.</p>\nSince: 4.02", "kind": "type"}, {"path": "Printexc.Slot", "name": "t", "type": "type t = backtrace_slot", "docs": null, "kind": "type"}, {"path": "Printexc.Slot", "name": "is_raise", "type": "let is_raise: t => bool", "docs": "<p><code>is_raise slot</code> is <code>true</code> when <code>slot</code> refers to a raising point in the code, and <code>false</code> when it comes from a simple function call.</p>\nSince: 4.02", "kind": "value", "args": [["", "t"]]}, {"path": "Printexc.Slot", "name": "location", "type": "let location: t => option(location)", "docs": "<p><code>location slot</code> returns the location information of the slot, if available, and <code>None</code> otherwise.</p>\n<p>Some possible reasons for failing to return a location are as follow:</p>\n<ul><li><p>the slot corresponds to a compiler-inserted raise</p>\n</li><li><p>the slot corresponds to a part of the program that has not been compiled with debug information (<code>-g</code>)</p>\n</li></ul>Since: 4.02", "kind": "value", "args": [["", "t"]]}, {"path": "Printexc.Slot", "name": "format", "type": "let format: (int, t) => option(string)", "docs": "<p><code>format pos slot</code> returns the string representation of <code>slot</code> as <code>raw_backtrace_to_string</code> would format it, assuming it is the <code>pos</code>-th element of the backtrace: the <code>0</code>-th element is pretty-printed differently than the others.</p>\n<p>Whole-backtrace printing functions also skip some uninformative slots; in that case, <code>format pos slot</code> returns <code>None</code>.</p>\nSince: 4.02", "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Printexc", "name": "Slot", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_raise\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>location\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Printexc", "name": "raw_backtrace_slot", "type": "type raw_backtrace_slot", "docs": "<p>This type allows direct access to raw backtrace slots, without any conversion in an OCaml-usable data-structure. Being process-specific, they must absolutely not be marshalled, and are unsafe to use for this reason (marshalling them may not fail, but un-marshalling and using the result will result in undefined behavior).</p>\n<p>Elements of this type can still be compared and hashed: when two elements are equal, then they represent the same source location (the converse is not necessarily true in presence of inlining, for example).</p>\nSince: 4.02.0", "kind": "type"}, {"path": "Printexc", "name": "raw_backtrace_length", "type": "let raw_backtrace_length: raw_backtrace => int", "docs": "<p><code>raw_backtrace_length bckt</code> returns the number of slots in the backtrace <code>bckt</code>.</p>\nSince: 4.02", "kind": "value", "args": [["", "raw_backtrace"]]}, {"path": "Printexc", "name": "get_raw_backtrace_slot", "type": "let get_raw_backtrace_slot: (raw_backtrace, int) => raw_backtrace_slot", "docs": "<p><code>get_slot bckt pos</code> returns the slot in position <code>pos</code> in the backtrace <code>bckt</code>.</p>\nSince: 4.02", "kind": "value", "args": [["", "raw_backtrace"], ["", "int"]]}, {"path": "Printexc", "name": "convert_raw_backtrace_slot", "type": "let convert_raw_backtrace_slot: raw_backtrace_slot => backtrace_slot", "docs": "<p>Extracts the user-friendly <code>backtrace_slot</code> from a low-level <code>raw_backtrace_slot</code>.</p>\nSince: 4.02", "kind": "value", "args": [["", "raw_backtrace_slot"]]}, {"path": "Printexc", "name": "exn_slot_id", "type": "let exn_slot_id: exn => int", "docs": "<p><code>Printexc.exn_slot_id</code> returns an integer which uniquely identifies the constructor used to create the exception value <code>exn</code> (in the current runtime).</p>\nSince: 4.02.0", "kind": "value", "args": [["", "exn"]]}, {"path": "Printexc", "name": "exn_slot_name", "type": "let exn_slot_name: exn => string", "docs": "<p><code>Printexc.exn_slot_id exn</code> returns the internal name of the constructor used to create the exception value <code>exn</code>.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "exn"]]}, {"path": "", "name": "Printexc", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>backtrace_slots\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>backtrace_status\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>catch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>convert_raw_backtrace_slot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exn_slot_id\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exn_slot_name\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_backtrace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_callstack\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_raw_backtrace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_raw_backtrace_slot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_backtrace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_raw_backtrace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>raw_backtrace_length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>raw_backtrace_to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>record_backtrace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>register_printer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_uncaught_exception_handler\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_string\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>backtrace_slot\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>location\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>raw_backtrace\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>raw_backtrace_slot\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Slot", "docs": null, "kind": "module"}, {"path": "Pervasives", "name": "raise", "type": "let raise: exn => 'a", "docs": "<p>Raise the given exception value</p>\n", "kind": "value", "args": [["", "exn"]]}, {"path": "Pervasives", "name": "raise_notrace", "type": "let raise_notrace: exn => 'a", "docs": "<p>A faster version <code>raise</code> which does not record the backtrace.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "exn"]]}, {"path": "Pervasives", "name": "invalid_arg", "type": "let invalid_arg: string => 'a", "docs": "<p>Raise exception <code>Invalid_argument</code> with the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "failwith", "type": "let failwith: string => 'a", "docs": "<p>Raise exception <code>Failure</code> with the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "=", "type": "let =: ('a, 'a) => bool", "docs": "<p><code>e1 = e2</code> tests for structural equality of <code>e1</code> and <code>e2</code>. Mutable structures (e.g. references and arrays) are equal if and only if their current contents are structurally equal, even if the two mutable objects are not the same physical object. Equality between functional values raises <code>Invalid_argument</code>. Equality between cyclic data structures may not terminate.</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": "<>", "type": "let <>: ('a, 'a) => bool", "docs": "<p>Negation of ( = ).</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": "<", "type": "let <: ('a, 'a) => bool", "docs": "<p>See ( &gt;= ).</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": ">", "type": "let >: ('a, 'a) => bool", "docs": "<p>See ( &gt;= ).</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": "<=", "type": "let <=: ('a, 'a) => bool", "docs": "<p>See ( &gt;= ).</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": ">=", "type": "let >=: ('a, 'a) => bool", "docs": "<p>Structural ordering functions. These functions coincide with the usual orderings over integers, characters, strings, byte sequences and floating-point numbers, and extend them to a total ordering over all types. The ordering is compatible with <code>( = )</code>. As in the case of <code>( = )</code>, mutable structures are compared by contents. Comparison between functional values raises <code>Invalid_argument</code>. Comparison between cyclic structures may not terminate.</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": "compare", "type": "let compare: ('a, 'a) => int", "docs": "<p><code>compare x y</code> returns <code>0</code> if <code>x</code> is equal to <code>y</code>, a negative integer if <code>x</code> is less than <code>y</code>, and a positive integer if <code>x</code> is greater than <code>y</code>. The ordering implemented by <code>compare</code> is compatible with the comparison predicates <code>=</code>, <code>&lt;</code> and <code>&gt;</code> defined above, with one difference on the treatment of the float value nan. Namely, the comparison predicates treat <code>nan</code> as different from any other float value, including itself; while <code>compare</code> treats <code>nan</code> as equal to itself and less than any other float value. This treatment of <code>nan</code> ensures that <code>compare</code> defines a total ordering relation.</p>\n<p><code>compare</code> applied to functional values may raise <code>Invalid_argument</code>. <code>compare</code> applied to cyclic structures may not terminate.</p>\n<p>The <code>compare</code> function can be used as the comparison function required by the Make and Make functors, as well as the sort and sort functions.</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": "min", "type": "let min: ('a, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": "max", "type": "let max: ('a, 'a) => 'a", "docs": null, "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": "==", "type": "let ==: ('a, 'a) => bool", "docs": "<p><code>e1 == e2</code> tests for physical equality of <code>e1</code> and <code>e2</code>. On mutable types such as references, arrays, byte sequences, records with mutable fields and objects with mutable instance variables, <code>e1 == e2</code> is true if and only if physical modification of <code>e1</code> also affects <code>e2</code>. On non-mutable types, the behavior of <code>( == )</code> is implementation-dependent; however, it is guaranteed that <code>e1 == e2</code> implies <code>compare e1 e2 = 0</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": "!=", "type": "let !=: ('a, 'a) => bool", "docs": "<p>Negation of ( == ).</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Pervasives", "name": "not", "type": "let not: bool => bool", "docs": "<p>The boolean negation.</p>\n", "kind": "value", "args": [["", "bool"]]}, {"path": "Pervasives", "name": "&&", "type": "let &&: (bool, bool) => bool", "docs": "<p>The boolean &#39;and&#39;. Evaluation is sequential, left-to-right: in <code>e1 &amp;&amp; e2</code>, <code>e1</code> is evaluated first, and if it returns <code>false</code>, <code>e2</code> is not evaluated at all.</p>\n", "kind": "value", "args": [["", "bool"], ["", "bool"]]}, {"path": "Pervasives", "name": "&", "type": "let &: (bool, bool) => bool", "docs": "<p>Deprecated: <p>( &amp;&amp; ) should be used instead.</p></p>\n", "kind": "value", "args": [["", "bool"], ["", "bool"]]}, {"path": "Pervasives", "name": "||", "type": "let ||: (bool, bool) => bool", "docs": "<p>The boolean &#39;or&#39;. Evaluation is sequential, left-to-right: in <code>e1 || e2</code>, <code>e1</code> is evaluated first, and if it returns <code>true</code>, <code>e2</code> is not evaluated at all.</p>\n", "kind": "value", "args": [["", "bool"], ["", "bool"]]}, {"path": "Pervasives", "name": "or", "type": "let or: (bool, bool) => bool", "docs": "<p>Deprecated: <p>( || ) should be used instead.</p></p>\n", "kind": "value", "args": [["", "bool"], ["", "bool"]]}, {"path": "Pervasives", "name": "__LOC__", "type": "let __LOC__: string", "docs": "<p><code>__LOC__</code> returns the location at which this expression appears in the file currently being parsed by the compiler, with the standard error format of OCaml: &quot;File %S, line %d, characters %d-%d&quot;.</p>\nSince: 4.02.0", "kind": "value"}, {"path": "Pervasives", "name": "__FILE__", "type": "let __FILE__: string", "docs": "<p><code>__LOC__</code> returns the location at which this expression appears in the file currently being parsed by the compiler, with the standard error format of OCaml: &quot;File %S, line %d, characters %d-%d&quot;.</p>\nSince: 4.02.0", "kind": "value"}, {"path": "Pervasives", "name": "__LINE__", "type": "let __LINE__: int", "docs": "<p><code>__FILE__</code> returns the name of the file currently being parsed by the compiler.</p>\nSince: 4.02.0", "kind": "value"}, {"path": "Pervasives", "name": "__MODULE__", "type": "let __MODULE__: string", "docs": "<p><code>__LINE__</code> returns the line number at which this expression appears in the file currently being parsed by the compiler.</p>\nSince: 4.02.0", "kind": "value"}, {"path": "Pervasives", "name": "__POS__", "type": "let __POS__: (string, int, int, int)", "docs": "<p><code>__MODULE__</code> returns the module name of the file being parsed by the compiler.</p>\nSince: 4.02.0", "kind": "value"}, {"path": "Pervasives", "name": "__LOC_OF__", "type": "let __LOC_OF__: 'a => (string, 'a)", "docs": "<p><code>__LOC_OF__ expr</code> returns a pair <code>(loc, expr)</code> where <code>loc</code> is the location of <code>expr</code> in the file currently being parsed by the compiler, with the standard error format of OCaml: &quot;File %S, line %d, characters %d-%d&quot;.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "'a"]]}, {"path": "Pervasives", "name": "__LINE_OF__", "type": "let __LINE_OF__: 'a => (int, 'a)", "docs": "<p><code>__LOC_OF__ expr</code> returns a pair <code>(loc, expr)</code> where <code>loc</code> is the location of <code>expr</code> in the file currently being parsed by the compiler, with the standard error format of OCaml: &quot;File %S, line %d, characters %d-%d&quot;.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "'a"]]}, {"path": "Pervasives", "name": "__POS_OF__", "type": "let __POS_OF__: 'a => ((string, int, int, int), 'a)", "docs": "<p><code>__LINE__ expr</code> returns a pair <code>(line, expr)</code>, where <code>line</code> is the line number at which the expression <code>expr</code> appears in the file currently being parsed by the compiler.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "'a"]]}, {"path": "Pervasives", "name": "|>", "type": "let |>: ('a, 'a => 'b) => 'b", "docs": "<p>Reverse-application operator: <code>x |&gt; f |&gt; g</code> is exactly equivalent to <code>g (f (x))</code>.</p>\nSince: 4.01", "kind": "value", "args": [["", "'a"], ["", "'a => 'b"]]}, {"path": "Pervasives", "name": "@@", "type": "let @@: ('a => 'b, 'a) => 'b", "docs": "<p>Application operator: <code>g @@ f @@ x</code> is exactly equivalent to <code>g (f (x))</code>.</p>\nSince: 4.01", "kind": "value", "args": [["", "'a => 'b"], ["", "'a"]]}, {"path": "Pervasives", "name": "~-", "type": "let ~-: int => int", "docs": "<p>Unary negation. You can also write <code>- e</code> instead of <code>~- e</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "~+", "type": "let ~+: int => int", "docs": "<p>Unary addition. You can also write <code>+ e</code> instead of <code>~+ e</code>.</p>\nSince: 3.12.0", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "succ", "type": "let succ: int => int", "docs": "<p><code>succ x</code> is <code>x + 1</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "pred", "type": "let pred: int => int", "docs": "<p><code>pred x</code> is <code>x - 1</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "+", "type": "let +: (int, int) => int", "docs": "<p>Integer addition.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "-", "type": "let -: (int, int) => int", "docs": "<p>Integer subtraction.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "*", "type": "let *: (int, int) => int", "docs": "<p>Integer multiplication.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "/", "type": "let /: (int, int) => int", "docs": "<p>Integer division. Raise <code>Division_by_zero</code> if the second argument is 0. Integer division rounds the real quotient of its arguments towards zero. More precisely, if <code>x &gt;= 0</code> and <code>y &gt; 0</code>, <code>x / y</code> is the greatest integer less than or equal to the real quotient of <code>x</code> by <code>y</code>. Moreover, <code>(- x) / y = x / (- y) = - (x / y)</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "mod", "type": "let mod: (int, int) => int", "docs": "failed to parse: File &quot;&quot;, line 2, characters 11-12:\nunpaired &#39;]&#39; (end of code)", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "abs", "type": "let abs: int => int", "docs": "<p>Return the absolute value of the argument. Note that this may be negative if the argument is <code>min_int</code>.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "max_int", "type": "let max_int: int", "docs": "<p>The greatest representable integer.</p>\n", "kind": "value"}, {"path": "Pervasives", "name": "min_int", "type": "let min_int: int", "docs": "<p>The smallest representable integer.</p>\n", "kind": "value"}, {"path": "Pervasives", "name": "land", "type": "let land: (int, int) => int", "docs": "<p>Bitwise logical and.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "lor", "type": "let lor: (int, int) => int", "docs": "<p>Bitwise logical or.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "lxor", "type": "let lxor: (int, int) => int", "docs": "<p>Bitwise logical exclusive or.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "lnot", "type": "let lnot: int => int", "docs": "<p>Bitwise logical negation.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "lsl", "type": "let lsl: (int, int) => int", "docs": "<p><code>n lsl m</code> shifts <code>n</code> to the left by <code>m</code> bits. The result is unspecified if <code>m &lt; 0</code> or <code>m &gt;= bitsize</code>, where <code>bitsize</code> is <code>32</code> on a 32-bit platform and <code>64</code> on a 64-bit platform.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "lsr", "type": "let lsr: (int, int) => int", "docs": "<p><code>n lsr m</code> shifts <code>n</code> to the right by <code>m</code> bits. This is a logical shift: zeroes are inserted regardless of the sign of <code>n</code>. The result is unspecified if <code>m &lt; 0</code> or <code>m &gt;= bitsize</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "asr", "type": "let asr: (int, int) => int", "docs": "<p><code>n asr m</code> shifts <code>n</code> to the right by <code>m</code> bits. This is an arithmetic shift: the sign bit of <code>n</code> is replicated. The result is unspecified if <code>m &lt; 0</code> or <code>m &gt;= bitsize</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "~-.", "type": "let ~-.: float => float", "docs": "<p>Unary negation. You can also write <code>-. e</code> instead of <code>~-. e</code>.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "~+.", "type": "let ~+.: float => float", "docs": "<p>Unary addition. You can also write <code>+. e</code> instead of <code>~+. e</code>.</p>\nSince: 3.12.0", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "+.", "type": "let +.: (float, float) => float", "docs": "<p>Floating-point addition</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Pervasives", "name": "-.", "type": "let -.: (float, float) => float", "docs": "<p>Floating-point subtraction</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Pervasives", "name": "*.", "type": "let *.: (float, float) => float", "docs": "<p>Floating-point multiplication</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Pervasives", "name": "/.", "type": "let /.: (float, float) => float", "docs": "<p>Floating-point division.</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Pervasives", "name": "**", "type": "let **: (float, float) => float", "docs": "<p>Exponentiation.</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Pervasives", "name": "sqrt", "type": "let sqrt: float => float", "docs": "<p>Square root.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "exp", "type": "let exp: float => float", "docs": "<p>Exponential.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "log", "type": "let log: float => float", "docs": "<p>Natural logarithm.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "log10", "type": "let log10: float => float", "docs": "<p>Base 10 logarithm.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "expm1", "type": "let expm1: float => float", "docs": "<p><code>expm1 x</code> computes <code>exp x -. 1.0</code>, giving numerically-accurate results even if <code>x</code> is close to <code>0.0</code>.</p>\nSince: 3.12.0", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "log1p", "type": "let log1p: float => float", "docs": "<p><code>log1p x</code> computes <code>log(1.0 +. x)</code> (natural logarithm), giving numerically-accurate results even if <code>x</code> is close to <code>0.0</code>.</p>\nSince: 3.12.0", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "cos", "type": "let cos: float => float", "docs": "<p>Cosine. Argument is in radians.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "sin", "type": "let sin: float => float", "docs": "<p>Sine. Argument is in radians.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "tan", "type": "let tan: float => float", "docs": "<p>Tangent. Argument is in radians.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "acos", "type": "let acos: float => float", "docs": "<p>Arc cosine. The argument must fall within the range <code>[-1.0, 1.0]</code>. Result is in radians and is between <code>0.0</code> and <code>pi</code>.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "asin", "type": "let asin: float => float", "docs": "<p>Arc sine. The argument must fall within the range <code>[-1.0, 1.0]</code>. Result is in radians and is between <code>-pi/2</code> and <code>pi/2</code>.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "atan", "type": "let atan: float => float", "docs": "<p>Arc tangent. Result is in radians and is between <code>-pi/2</code> and <code>pi/2</code>.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "atan2", "type": "let atan2: (float, float) => float", "docs": "<p><code>atan2 y x</code> returns the arc tangent of <code>y /. x</code>. The signs of <code>x</code> and <code>y</code> are used to determine the quadrant of the result. Result is in radians and is between <code>-pi</code> and <code>pi</code>.</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Pervasives", "name": "hypot", "type": "let hypot: (float, float) => float", "docs": "<p><code>hypot x y</code> returns <code>sqrt(x *. x + y *. y)</code>, that is, the length of the hypotenuse of a right-angled triangle with sides of length <code>x</code> and <code>y</code>, or, equivalently, the distance of the point <code>(x,y)</code> to origin.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Pervasives", "name": "cosh", "type": "let cosh: float => float", "docs": "<p>Hyperbolic cosine. Argument is in radians.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "sinh", "type": "let sinh: float => float", "docs": "<p>Hyperbolic sine. Argument is in radians.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "tanh", "type": "let tanh: float => float", "docs": "<p>Hyperbolic tangent. Argument is in radians.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "ceil", "type": "let ceil: float => float", "docs": "<p>Round above to an integer value. <code>ceil f</code> returns the least integer value greater than or equal to <code>f</code>. The result is returned as a float.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "floor", "type": "let floor: float => float", "docs": "<p>Round below to an integer value. <code>floor f</code> returns the greatest integer value less than or equal to <code>f</code>. The result is returned as a float.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "abs_float", "type": "let abs_float: float => float", "docs": "<p><code>abs_float f</code> returns the absolute value of <code>f</code>.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "copysign", "type": "let copysign: (float, float) => float", "docs": "<p><code>copysign x y</code> returns a float whose absolute value is that of <code>x</code> and whose sign is that of <code>y</code>. If <code>x</code> is <code>nan</code>, returns <code>nan</code>. If <code>y</code> is <code>nan</code>, returns either <code>x</code> or <code>-. x</code>, but it is not specified which.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Pervasives", "name": "mod_float", "type": "let mod_float: (float, float) => float", "docs": "<p><code>mod_float a b</code> returns the remainder of <code>a</code> with respect to <code>b</code>. The returned value is <code>a -. n *. b</code>, where <code>n</code> is the quotient <code>a /. b</code> rounded towards zero to an integer.</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Pervasives", "name": "frexp", "type": "let frexp: float => (float, int)", "docs": "failed to parse: File &quot;&quot;, line 4, characters 1-2:\nunpaired &#39;]&#39; (end of code)", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "ldexp", "type": "let ldexp: (float, int) => float", "docs": "<p><code>ldexp x n</code> returns <code>x *. 2 ** n</code>.</p>\n", "kind": "value", "args": [["", "float"], ["", "int"]]}, {"path": "Pervasives", "name": "modf", "type": "let modf: float => (float, float)", "docs": "<p><code>modf f</code> returns the pair of the fractional and integral part of <code>f</code>.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "float", "type": "let float: int => float", "docs": "<p>Same as float_of_int.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "float_of_int", "type": "let float_of_int: int => float", "docs": "<p>Convert an integer to floating-point.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "truncate", "type": "let truncate: float => int", "docs": "<p>Same as int_of_float.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "int_of_float", "type": "let int_of_float: float => int", "docs": "<p>Truncate the given floating-point number to an integer. The result is unspecified if the argument is <code>nan</code> or falls outside the range of representable integers.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "infinity", "type": "let infinity: float", "docs": null, "kind": "value"}, {"path": "Pervasives", "name": "neg_infinity", "type": "let neg_infinity: float", "docs": null, "kind": "value"}, {"path": "Pervasives", "name": "nan", "type": "let nan: float", "docs": null, "kind": "value"}, {"path": "Pervasives", "name": "max_float", "type": "let max_float: float", "docs": null, "kind": "value"}, {"path": "Pervasives", "name": "min_float", "type": "let min_float: float", "docs": null, "kind": "value"}, {"path": "Pervasives", "name": "epsilon_float", "type": "let epsilon_float: float", "docs": null, "kind": "value"}, {"path": "Pervasives", "name": "fpclass", "type": "type fpclass = | FP_normal | FP_subnormal | FP_zero | FP_infinite | FP_nan\n", "docs": "<p>The five classes of floating-point numbers, as determined by the classify_float function.</p>\n", "kind": "type"}, {"path": "Pervasives", "name": "classify_float", "type": "let classify_float: float => fpclass", "docs": "<p>Return the class of the given floating-point number: normal, subnormal, zero, infinite, or not a number.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "^", "type": "let ^: (string, string) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Pervasives", "name": "int_of_char", "type": "let int_of_char: char => int", "docs": "<p>Return the ASCII code of the argument.</p>\n", "kind": "value", "args": [["", "char"]]}, {"path": "Pervasives", "name": "char_of_int", "type": "let char_of_int: int => char", "docs": "<p>Return the character with the given ASCII code. Raise <code>Invalid_argument &quot;char_of_int&quot;</code> if the argument is outside the range 0--255.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "ignore", "type": "let ignore: 'a => unit", "docs": "<p>Discard the value of its argument and return <code>()</code>. For instance, <code>ignore(f x)</code> discards the result of the side-effecting function <code>f</code>. It is equivalent to <code>f x; ()</code>, except that the latter may generate a compiler warning; writing <code>ignore(f x)</code> instead avoids the warning.</p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Pervasives", "name": "string_of_bool", "type": "let string_of_bool: bool => string", "docs": "<p>Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.</p>\n", "kind": "value", "args": [["", "bool"]]}, {"path": "Pervasives", "name": "bool_of_string", "type": "let bool_of_string: string => bool", "docs": "<p>Convert the given string to a boolean. Raise <code>Invalid_argument &quot;bool_of_string&quot;</code> if the string is not <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "string_of_int", "type": "let string_of_int: int => string", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "int_of_string", "type": "let int_of_string: string => int", "docs": "<p>Convert the given string to an integer. The string is read in decimal (by default) or in hexadecimal (if it begins with <code>0x</code> or <code>0X</code>), octal (if it begins with <code>0o</code> or <code>0O</code>), or binary (if it begins with <code>0b</code> or <code>0B</code>). Raise <code>Failure &quot;int_of_string&quot;</code> if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type <code>int</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "string_of_float", "type": "let string_of_float: float => string", "docs": "<p>Return the string representation of a floating-point number.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "float_of_string", "type": "let float_of_string: string => float", "docs": "<p>Convert the given string to a float. Raise <code>Failure &quot;float_of_string&quot;</code> if the given string is not a valid representation of a float.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "fst", "type": "let fst: ('a, 'b) => 'a", "docs": "<p>Return the first component of a pair.</p>\n", "kind": "value", "args": [["", "('a, 'b)"]]}, {"path": "Pervasives", "name": "snd", "type": "let snd: ('a, 'b) => 'b", "docs": "<p>Return the second component of a pair.</p>\n", "kind": "value", "args": [["", "('a, 'b)"]]}, {"path": "Pervasives", "name": "@", "type": "let @: (list('a), list('a)) => list('a)", "docs": "<p>List concatenation.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('a)"]]}, {"path": "Pervasives", "name": "in_channel", "type": "type in_channel", "docs": "<p>The type of input channel.</p>\n", "kind": "type"}, {"path": "Pervasives", "name": "out_channel", "type": "type out_channel", "docs": "<p>The type of output channel.</p>\n", "kind": "type"}, {"path": "Pervasives", "name": "stdin", "type": "let stdin: in_channel", "docs": "<p>The standard input for the process.</p>\n", "kind": "value"}, {"path": "Pervasives", "name": "stdout", "type": "let stdout: out_channel", "docs": "<p>The standard output for the process.</p>\n", "kind": "value"}, {"path": "Pervasives", "name": "stderr", "type": "let stderr: out_channel", "docs": "<p>The standard error output for the process.</p>\n", "kind": "value"}, {"path": "Pervasives", "name": "print_char", "type": "let print_char: char => unit", "docs": "<p>Print a character on standard output.</p>\n", "kind": "value", "args": [["", "char"]]}, {"path": "Pervasives", "name": "print_string", "type": "let print_string: string => unit", "docs": "<p>Print a string on standard output.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "print_bytes", "type": "let print_bytes: bytes => unit", "docs": "<p>Print a byte sequence on standard output.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "bytes"]]}, {"path": "Pervasives", "name": "print_int", "type": "let print_int: int => unit", "docs": "<p>Print an integer, in decimal, on standard output.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "print_float", "type": "let print_float: float => unit", "docs": "<p>Print a floating-point number, in decimal, on standard output.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "print_endline", "type": "let print_endline: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "print_newline", "type": "let print_newline: unit => unit", "docs": "<p>Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Pervasives", "name": "prerr_char", "type": "let prerr_char: char => unit", "docs": "<p>Print a character on standard error.</p>\n", "kind": "value", "args": [["", "char"]]}, {"path": "Pervasives", "name": "prerr_string", "type": "let prerr_string: string => unit", "docs": "<p>Print a string on standard error.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "prerr_bytes", "type": "let prerr_bytes: bytes => unit", "docs": "<p>Print a byte sequence on standard error.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "bytes"]]}, {"path": "Pervasives", "name": "prerr_int", "type": "let prerr_int: int => unit", "docs": "<p>Print an integer, in decimal, on standard error.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "prerr_float", "type": "let prerr_float: float => unit", "docs": "<p>Print a floating-point number, in decimal, on standard error.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Pervasives", "name": "prerr_endline", "type": "let prerr_endline: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "prerr_newline", "type": "let prerr_newline: unit => unit", "docs": "<p>Print a newline character on standard error, and flush standard error.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Pervasives", "name": "read_line", "type": "let read_line: unit => string", "docs": "<p>Flush standard output, then read characters from standard input until a newline character is encountered. Return the string of all characters read, without the newline character at the end.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Pervasives", "name": "read_int", "type": "let read_int: unit => int", "docs": "<p>Flush standard output, then read one line from standard input and convert it to an integer. Raise <code>Failure &quot;int_of_string&quot;</code> if the line read is not a valid representation of an integer.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Pervasives", "name": "read_float", "type": "let read_float: unit => float", "docs": "<p>Flush standard output, then read one line from standard input and convert it to a floating-point number. The result is unspecified if the line read is not a valid representation of a floating-point number.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Pervasives", "name": "open_flag", "type": "type open_flag = \n  | Open_rdonly\n  | Open_wronly\n  | Open_append\n  | Open_creat\n  | Open_trunc\n  | Open_excl\n  | Open_binary\n  | Open_text\n  | Open_nonblock\n", "docs": "<p>Opening modes for open_out_gen and open_in_gen.</p>\n", "kind": "type"}, {"path": "Pervasives", "name": "open_out", "type": "let open_out: string => out_channel", "docs": "<p>Open the named file for writing, and return a new output channel on that file, positionned at the beginning of the file. The file is truncated to zero length if it already exists. It is created if it does not already exists.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "open_out_bin", "type": "let open_out_bin: string => out_channel", "docs": "<p>Same as open_out, but the file is opened in binary mode, so that no translation takes place during writes. On operating systems that do not distinguish between text mode and binary mode, this function behaves like open_out.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "open_out_gen", "type": "let open_out_gen: (list(open_flag), int, string) => out_channel", "docs": "<p><code>open_out_gen mode perm filename</code> opens the named file for writing, as described above. The extra argument <code>mode</code> specify the opening mode. The extra argument <code>perm</code> specifies the file permissions, in case the file must be created. open_out and open_out_bin are special cases of this function.</p>\n", "kind": "value", "args": [["", "list(open_flag)"], ["", "int"], ["", "string"]]}, {"path": "Pervasives", "name": "flush", "type": "let flush: out_channel => unit", "docs": "<p>Flush the buffer associated with the given output channel, performing all pending writes on that channel. Interactive programs must be careful about flushing standard output and standard error at the right time.</p>\n", "kind": "value", "args": [["", "out_channel"]]}, {"path": "Pervasives", "name": "flush_all", "type": "let flush_all: unit => unit", "docs": "<p>Flush all open output channels; ignore errors.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Pervasives", "name": "output_char", "type": "let output_char: (out_channel, char) => unit", "docs": "<p>Write the character on the given output channel.</p>\n", "kind": "value", "args": [["", "out_channel"], ["", "char"]]}, {"path": "Pervasives", "name": "output_string", "type": "let output_string: (out_channel, string) => unit", "docs": "<p>Write the string on the given output channel.</p>\n", "kind": "value", "args": [["", "out_channel"], ["", "string"]]}, {"path": "Pervasives", "name": "output_bytes", "type": "let output_bytes: (out_channel, bytes) => unit", "docs": "<p>Write the byte sequence on the given output channel.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "out_channel"], ["", "bytes"]]}, {"path": "Pervasives", "name": "output", "type": "let output: (out_channel, bytes, int, int) => unit", "docs": "<p><code>output oc buf pos len</code> writes <code>len</code> characters from byte sequence <code>buf</code>, starting at offset <code>pos</code>, to the given output channel <code>oc</code>. Raise <code>Invalid_argument &quot;output&quot;</code> if <code>pos</code> and <code>len</code> do not designate a valid range of <code>buf</code>.</p>\n", "kind": "value", "args": [["", "out_channel"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "output_substring", "type": "let output_substring: (out_channel, string, int, int) => unit", "docs": "<p>Same as <code>output</code> but take a string as argument instead of a byte sequence.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "out_channel"], ["", "string"], ["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "output_byte", "type": "let output_byte: (out_channel, int) => unit", "docs": "<p>Write one 8-bit integer (as the single character with that code) on the given output channel. The given integer is taken modulo 256.</p>\n", "kind": "value", "args": [["", "out_channel"], ["", "int"]]}, {"path": "Pervasives", "name": "output_binary_int", "type": "let output_binary_int: (out_channel, int) => unit", "docs": "<p>Write one integer in binary format (4 bytes, big-endian) on the given output channel. The given integer is taken modulo 2Superscript. The only reliable way to read it back is through the input_binary_int function. The format is compatible across all machines for a given version of OCaml.</p>\n", "kind": "value", "args": [["", "out_channel"], ["", "int"]]}, {"path": "Pervasives", "name": "output_value", "type": "let output_value: (out_channel, 'a) => unit", "docs": "<p>Write the representation of a structured value of any type to a channel. Circularities and sharing inside the value are detected and preserved. The object can be read back, by the function input_value. See the description of module Marshal for more information. output_value is equivalent to to_channel with an empty list of flags.</p>\n", "kind": "value", "args": [["", "out_channel"], ["", "'a"]]}, {"path": "Pervasives", "name": "seek_out", "type": "let seek_out: (out_channel, int) => unit", "docs": "<p><code>seek_out chan pos</code> sets the current writing position to <code>pos</code> for channel <code>chan</code>. This works only for regular files. On files of other kinds (such as terminals, pipes and sockets), the behavior is unspecified.</p>\n", "kind": "value", "args": [["", "out_channel"], ["", "int"]]}, {"path": "Pervasives", "name": "pos_out", "type": "let pos_out: out_channel => int", "docs": "<p>Return the current writing position for the given channel. Does not work on channels opened with the <code>Open_append</code> flag (returns unspecified results).</p>\n", "kind": "value", "args": [["", "out_channel"]]}, {"path": "Pervasives", "name": "out_channel_length", "type": "let out_channel_length: out_channel => int", "docs": "<p>Return the size (number of characters) of the regular file on which the given channel is opened. If the channel is opened on a file that is not a regular file, the result is meaningless.</p>\n", "kind": "value", "args": [["", "out_channel"]]}, {"path": "Pervasives", "name": "close_out", "type": "let close_out: out_channel => unit", "docs": "<p>Close the given channel, flushing all buffered write operations. Output functions raise a <code>Sys_error</code> exception when they are applied to a closed output channel, except <code>close_out</code> and <code>flush</code>, which do nothing when applied to an already closed channel. Note that <code>close_out</code> may raise <code>Sys_error</code> if the operating system signals an error when flushing or closing.</p>\n", "kind": "value", "args": [["", "out_channel"]]}, {"path": "Pervasives", "name": "close_out_noerr", "type": "let close_out_noerr: out_channel => unit", "docs": "<p>Same as <code>close_out</code>, but ignore all errors.</p>\n", "kind": "value", "args": [["", "out_channel"]]}, {"path": "Pervasives", "name": "set_binary_mode_out", "type": "let set_binary_mode_out: (out_channel, bool) => unit", "docs": "<p><code>set_binary_mode_out oc true</code> sets the channel <code>oc</code> to binary mode: no translations take place during output. <code>set_binary_mode_out oc false</code> sets the channel <code>oc</code> to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from <code>\\n</code> to <code>\\r\\n</code>. This function has no effect under operating systems that do not distinguish between text mode and binary mode.</p>\n", "kind": "value", "args": [["", "out_channel"], ["", "bool"]]}, {"path": "Pervasives", "name": "open_in", "type": "let open_in: string => in_channel", "docs": "<p>Open the named file for reading, and return a new input channel on that file, positionned at the beginning of the file.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "open_in_bin", "type": "let open_in_bin: string => in_channel", "docs": "<p>Same as open_in, but the file is opened in binary mode, so that no translation takes place during reads. On operating systems that do not distinguish between text mode and binary mode, this function behaves like open_in.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "open_in_gen", "type": "let open_in_gen: (list(open_flag), int, string) => in_channel", "docs": "<p><code>open_in_gen mode perm filename</code> opens the named file for reading, as described above. The extra arguments <code>mode</code> and <code>perm</code> specify the opening mode and file permissions. open_in and open_in_bin are special cases of this function.</p>\n", "kind": "value", "args": [["", "list(open_flag)"], ["", "int"], ["", "string"]]}, {"path": "Pervasives", "name": "input_char", "type": "let input_char: in_channel => char", "docs": "<p>Read one character from the given input channel. Raise <code>End_of_file</code> if there are no more characters to read.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "input_line", "type": "let input_line: in_channel => string", "docs": "<p>Read characters from the given input channel, until a newline character is encountered. Return the string of all characters read, without the newline character at the end. Raise <code>End_of_file</code> if the end of the file is reached at the beginning of line.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "input", "type": "let input: (in_channel, bytes, int, int) => int", "docs": "<p><code>input ic buf pos len</code> reads up to <code>len</code> characters from the given channel <code>ic</code>, storing them in byte sequence <code>buf</code>, starting at character number <code>pos</code>. It returns the actual number of characters read, between 0 and <code>len</code> (inclusive). A return value of 0 means that the end of file was reached. A return value between 0 and <code>len</code> exclusive means that not all requested <code>len</code> characters were read, either because no more characters were available at that time, or because the implementation found it convenient to do a partial read; <code>input</code> must be called again to read the remaining characters, if desired. (See also really_input for reading exactly <code>len</code> characters.) Exception <code>Invalid_argument &quot;input&quot;</code> is raised if <code>pos</code> and <code>len</code> do not designate a valid range of <code>buf</code>.</p>\n", "kind": "value", "args": [["", "in_channel"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "really_input", "type": "let really_input: (in_channel, bytes, int, int) => unit", "docs": "<p><code>really_input ic buf pos len</code> reads <code>len</code> characters from channel <code>ic</code>, storing them in byte sequence <code>buf</code>, starting at character number <code>pos</code>. Raise <code>End_of_file</code> if the end of file is reached before <code>len</code> characters have been read. Raise <code>Invalid_argument &quot;really_input&quot;</code> if <code>pos</code> and <code>len</code> do not designate a valid range of <code>buf</code>.</p>\n", "kind": "value", "args": [["", "in_channel"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "really_input_string", "type": "let really_input_string: (in_channel, int) => string", "docs": "<p><code>really_input_string ic len</code> reads <code>len</code> characters from channel <code>ic</code> and returns them in a new string. Raise <code>End_of_file</code> if the end of file is reached before <code>len</code> characters have been read.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "in_channel"], ["", "int"]]}, {"path": "Pervasives", "name": "input_byte", "type": "let input_byte: in_channel => int", "docs": "<p>Same as input_char, but return the 8-bit integer representing the character. Raise <code>End_of_file</code> if an end of file was reached.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "input_binary_int", "type": "let input_binary_int: in_channel => int", "docs": "<p>Read an integer encoded in binary format (4 bytes, big-endian) from the given input channel. See output_binary_int. Raise <code>End_of_file</code> if an end of file was reached while reading the integer.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "input_value", "type": "let input_value: in_channel => 'a", "docs": "<p>Read the representation of a structured value, as produced by output_value, and return the corresponding value. This function is identical to from_channel; see the description of module Marshal for more information, in particular concerning the lack of type safety.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "seek_in", "type": "let seek_in: (in_channel, int) => unit", "docs": "<p><code>seek_in chan pos</code> sets the current reading position to <code>pos</code> for channel <code>chan</code>. This works only for regular files. On files of other kinds, the behavior is unspecified.</p>\n", "kind": "value", "args": [["", "in_channel"], ["", "int"]]}, {"path": "Pervasives", "name": "pos_in", "type": "let pos_in: in_channel => int", "docs": "<p>Return the current reading position for the given channel.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "in_channel_length", "type": "let in_channel_length: in_channel => int", "docs": "<p>Return the size (number of characters) of the regular file on which the given channel is opened. If the channel is opened on a file that is not a regular file, the result is meaningless. The returned size does not take into account the end-of-line translations that can be performed when reading from a channel opened in text mode.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "close_in", "type": "let close_in: in_channel => unit", "docs": "<p>Close the given channel. Input functions raise a <code>Sys_error</code> exception when they are applied to a closed input channel, except <code>close_in</code>, which does nothing when applied to an already closed channel.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "close_in_noerr", "type": "let close_in_noerr: in_channel => unit", "docs": "<p>Same as <code>close_in</code>, but ignore all errors.</p>\n", "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "set_binary_mode_in", "type": "let set_binary_mode_in: (in_channel, bool) => unit", "docs": "<p><code>set_binary_mode_in ic true</code> sets the channel <code>ic</code> to binary mode: no translations take place during input. <code>set_binary_mode_out ic false</code> sets the channel <code>ic</code> to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from <code>\\r\\n</code> to <code>\\n</code>. This function has no effect under operating systems that do not distinguish between text mode and binary mode.</p>\n", "kind": "value", "args": [["", "in_channel"], ["", "bool"]]}, {"path": "Pervasives.LargeFile", "name": "seek_out", "type": "let seek_out: (out_channel, int64) => unit", "docs": null, "kind": "value", "args": [["", "out_channel"], ["", "int64"]]}, {"path": "Pervasives.LargeFile", "name": "pos_out", "type": "let pos_out: out_channel => int64", "docs": null, "kind": "value", "args": [["", "out_channel"]]}, {"path": "Pervasives.LargeFile", "name": "out_channel_length", "type": "let out_channel_length: out_channel => int64", "docs": null, "kind": "value", "args": [["", "out_channel"]]}, {"path": "Pervasives.LargeFile", "name": "seek_in", "type": "let seek_in: (in_channel, int64) => unit", "docs": null, "kind": "value", "args": [["", "in_channel"], ["", "int64"]]}, {"path": "Pervasives.LargeFile", "name": "pos_in", "type": "let pos_in: in_channel => int64", "docs": null, "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives.LargeFile", "name": "in_channel_length", "type": "let in_channel_length: in_channel => int64", "docs": null, "kind": "value", "args": [["", "in_channel"]]}, {"path": "Pervasives", "name": "LargeFile", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>in_channel_length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>out_channel_length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pos_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pos_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>seek_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>seek_out", "docs": "<p>Operations on large files. This sub-module provides 64-bit variants of the channel functions that manipulate file positions and file sizes. By representing positions and sizes by 64-bit integers (type <code>int64</code>) instead of regular integers (type <code>int</code>), these alternate functions allow operating on files whose sizes are greater than <code>max_int</code>.</p>\n", "kind": "module"}, {"path": "Pervasives", "name": "ref", "type": "type ref('a) = {mut contents: 'a}", "docs": "<p>The type of references (mutable indirection cells) containing a value of type <code>&#39;a</code>.</p>\n", "kind": "type"}, {"path": "Pervasives", "name": "ref", "type": "let ref: 'a => ref('a)", "docs": "<p>Return a fresh reference containing the given value.</p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Pervasives", "name": "!", "type": "let !: ref('a) => 'a", "docs": "<p><code>!r</code> returns the current contents of reference <code>r</code>. Equivalent to <code>fun r -&gt; r.contents</code>.</p>\n", "kind": "value", "args": [["", "ref('a)"]]}, {"path": "Pervasives", "name": ":=", "type": "let :=: (ref('a), 'a) => unit", "docs": "<p><code>r := a</code> stores the value of <code>a</code> in reference <code>r</code>. Equivalent to <code>fun r v -&gt; r.contents &lt;- v</code>.</p>\n", "kind": "value", "args": [["", "ref('a)"], ["", "'a"]]}, {"path": "Pervasives", "name": "incr", "type": "let incr: ref(int) => unit", "docs": "<p>Increment the integer contained in the given reference. Equivalent to <code>fun r -&gt; r := succ !r</code>.</p>\n", "kind": "value", "args": [["", "ref(int)"]]}, {"path": "Pervasives", "name": "decr", "type": "let decr: ref(int) => unit", "docs": "<p>Decrement the integer contained in the given reference. Equivalent to <code>fun r -&gt; r := pred !r</code>.</p>\n", "kind": "value", "args": [["", "ref(int)"]]}, {"path": "Pervasives", "name": "format6", "type": "type format6('a, 'b, 'c, 'd, 'e, 'f) = CamlinternalFormatBasics.format6('a, 'b, 'c, 'd, 'e, 'f)", "docs": null, "kind": "type"}, {"path": "Pervasives", "name": "format4", "type": "type format4('a, 'b, 'c, 'd) = format6('a, 'b, 'c, 'c, 'c, 'd)", "docs": null, "kind": "type"}, {"path": "Pervasives", "name": "format", "type": "type format('a, 'b, 'c) = format4('a, 'b, 'c, 'c)", "docs": null, "kind": "type"}, {"path": "Pervasives", "name": "string_of_format", "type": "let string_of_format: format6('a, 'b, 'c, 'd, 'e, 'f) => string", "docs": "<p>Converts a format string into a string.</p>\n", "kind": "value", "args": [["", "format6('a, 'b, 'c, 'd, 'e, 'f)"]]}, {"path": "Pervasives", "name": "format_of_string", "type": "let format_of_string: format6('a, 'b, 'c, 'd, 'e, 'f) => format6('a, 'b, 'c, 'd, 'e, 'f)", "docs": "<p><code>format_of_string s</code> returns a format string read from the string literal <code>s</code>. Note: <code>format_of_string</code> can not convert a string argument that is not a literal. If you need this functionality, use the more general format_from_string function.</p>\n", "kind": "value", "args": [["", "format6('a, 'b, 'c, 'd, 'e, 'f)"]]}, {"path": "Pervasives", "name": "^^", "type": "let ^^: (format6('a, 'b, 'c, 'd, 'e, 'f), format6('f, 'b, 'c, 'e, 'g, 'h)) => format6(\n  'a,\n  'b,\n  'c,\n  'd,\n  'g,\n  'h\n)", "docs": "<p><code>f1 ^^ f2</code> catenates format strings <code>f1</code> and <code>f2</code>. The result is a format string that behaves as the concatenation of format strings <code>f1</code> and <code>f2</code>: in case of formatted output, it accepts arguments from <code>f1</code>, then arguments from <code>f2</code>; in case of formatted input, it returns results from <code>f1</code>, then results from <code>f2</code>.</p>\n", "kind": "value", "args": [["", "format6('a, 'b, 'c, 'd, 'e, 'f)"], ["", "format6('f, 'b, 'c, 'e, 'g, 'h)"]]}, {"path": "Pervasives", "name": "exit", "type": "let exit: int => 'a", "docs": "<p>Terminate the process, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure. All open output channels are flushed with <code>flush_all</code>. An implicit <code>exit 0</code> is performed each time a program terminates normally. An implicit <code>exit 2</code> is performed if the program terminates early because of an uncaught exception.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Pervasives", "name": "at_exit", "type": "let at_exit: unit => unit => unit", "docs": "<p>Register the given function to be called at program termination time. The functions registered with <code>at_exit</code> will be called when the program executes exit, or terminates, either normally or because of an uncaught exception. The functions are called in &#39;last in, first out&#39; order: the function most recently added with <code>at_exit</code> is called first.</p>\n", "kind": "value", "args": [["", "unit => unit"]]}, {"path": "Pervasives", "name": "valid_float_lexem", "type": "let valid_float_lexem: string => string", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Pervasives", "name": "unsafe_really_input", "type": "let unsafe_really_input: (in_channel, bytes, int, int) => unit", "docs": null, "kind": "value", "args": [["", "in_channel"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Pervasives", "name": "do_at_exit", "type": "let do_at_exit: unit => unit", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "", "name": "Pervasives", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>!\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>!=\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>&\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>&&\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>*\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>**\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>*.\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>+\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>+.\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>-\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>-.\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>/\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>/.\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>:=\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span><\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span><=\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span><>\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>=\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>==\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>>\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>>=\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>@\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>@@\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>^\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>^^\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>__FILE__\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>__LINE_OF__\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>__LINE__\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>__LOC_OF__\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>__LOC__\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>__MODULE__\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>__POS_OF__\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>__POS__\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abs_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>acos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>asin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>asr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>at_exit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>atan\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>atan2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bool_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ceil\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>char_of_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>classify_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_in_noerr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_out_noerr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copysign\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cosh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>do_at_exit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>epsilon_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>expm1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>failwith\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>float_of_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>float_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>floor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flush\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flush_all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>frexp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fst\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hypot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ignore\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>in_channel_length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>incr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>infinity\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>input_binary_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>input_byte\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>input_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>input_line\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>input_value\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int_of_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int_of_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>invalid_arg\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>land\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ldexp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lnot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log10\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log1p\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lsl\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lsr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lxor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mod\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mod_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>modf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nan\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>neg_infinity\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>not\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_in_bin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_in_gen\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_out_bin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_out_gen\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>or\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>out_channel_length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output_binary_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output_byte\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output_bytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output_substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output_value\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pos_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pos_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pred\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>prerr_bytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>prerr_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>prerr_endline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>prerr_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>prerr_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>prerr_newline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>prerr_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_bytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_endline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_newline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>raise\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>raise_notrace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>read_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>read_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>read_line\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>really_input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>really_input_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ref\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>seek_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>seek_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_binary_mode_in\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_binary_mode_out\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sinh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>snd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sqrt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stderr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stdin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stdout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_bool\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>succ\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tan\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tanh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_really_input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valid_float_lexem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>|>\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>||\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>~+\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>~+.\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>~-\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>~-.\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>format\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>format4\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>format6\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>fpclass\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>in_channel\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>open_flag\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>out_channel\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>ref\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>LargeFile", "docs": null, "kind": "module"}, {"path": "Parsing", "name": "symbol_start", "type": "let symbol_start: unit => int", "docs": "<p><code>symbol_start</code> and symbol_end are to be called in the action part of a grammar rule only. They return the offset of the string that matches the left-hand side of the rule: <code>symbol_start()</code> returns the offset of the first character; <code>symbol_end()</code> returns the offset after the last character. The first character in a file is at offset 0.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Parsing", "name": "symbol_end", "type": "let symbol_end: unit => int", "docs": "<p>See symbol_start.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Parsing", "name": "rhs_start", "type": "let rhs_start: int => int", "docs": "<p>Same as symbol_start and symbol_end, but return the offset of the string matching the <code>n</code>th item on the right-hand side of the rule, where <code>n</code> is the integer parameter to <code>rhs_start</code> and <code>rhs_end</code>. <code>n</code> is 1 for the leftmost item.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Parsing", "name": "rhs_end", "type": "let rhs_end: int => int", "docs": "<p>See rhs_start.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Parsing", "name": "symbol_start_pos", "type": "let symbol_start_pos: unit => Lexing.position", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Parsing", "name": "symbol_end_pos", "type": "let symbol_end_pos: unit => Lexing.position", "docs": "<p>Same as <code>symbol_end</code>, but return a <code>position</code> instead of an offset.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Parsing", "name": "rhs_start_pos", "type": "let rhs_start_pos: int => Lexing.position", "docs": "<p>Same as <code>rhs_start</code>, but return a <code>position</code> instead of an offset.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Parsing", "name": "rhs_end_pos", "type": "let rhs_end_pos: int => Lexing.position", "docs": "<p>Same as <code>rhs_end</code>, but return a <code>position</code> instead of an offset.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Parsing", "name": "clear_parser", "type": "let clear_parser: unit => unit", "docs": "<p>Empty the parser stack. Call it just after a parsing function has returned, to remove all pointers from the parser stack to structures that were built by semantic actions during parsing. This is optional, but lowers the memory requirements of the programs.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Parsing", "name": "set_trace", "type": "let set_trace: bool => bool", "docs": "<p>Control debugging support for <code>ocamlyacc</code>-generated parsers. After <code>Parsing.set_trace true</code>, the pushdown automaton that executes the parsers prints a trace of its actions (reading a token, shifting a state, reducing by a rule) on standard output. <code>Parsing.set_trace false</code> turns this debugging trace off. The boolean returned is the previous state of the trace flag.</p>\nSince: 3.11.0", "kind": "value", "args": [["", "bool"]]}, {"path": "Parsing", "name": "parser_env", "type": "type parser_env", "docs": null, "kind": "type"}, {"path": "Parsing", "name": "parse_tables", "type": "type parse_tables = {\n  actions: array(parser_env => Obj.t),\n  transl_const: array(int),\n  transl_block: array(int),\n  lhs: string,\n  len: string,\n  defred: string,\n  dgoto: string,\n  sindex: string,\n  rindex: string,\n  gindex: string,\n  tablesize: int,\n  table: string,\n  check: string,\n  error_function: string => unit,\n  names_const: string,\n  names_block: string\n}", "docs": null, "kind": "type"}, {"path": "Parsing", "name": "yyparse", "type": "let yyparse: (parse_tables, int, Lexing.lexbuf => 'a, Lexing.lexbuf) => 'b", "docs": null, "kind": "value", "args": [["", "parse_tables"], ["", "int"], ["", "Lexing.lexbuf => 'a"], ["", "Lexing.lexbuf"]]}, {"path": "Parsing", "name": "peek_val", "type": "let peek_val: (parser_env, int) => 'a", "docs": null, "kind": "value", "args": [["", "parser_env"], ["", "int"]]}, {"path": "Parsing", "name": "is_current_lookahead", "type": "let is_current_lookahead: 'a => bool", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Parsing", "name": "parse_error", "type": "let parse_error: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "Parsing", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear_parser\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_current_lookahead\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parse_error\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>peek_val\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rhs_end\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rhs_end_pos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rhs_start\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rhs_start_pos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_trace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>symbol_end\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>symbol_end_pos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>symbol_start\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>symbol_start_pos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>yyparse\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>parse_tables\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>parser_env", "docs": null, "kind": "module"}, {"path": "Oo", "name": "copy", "type": "let copy: &lt; .. &gt; => &lt; .. &gt;", "docs": "<p><code>Oo.copy o</code> returns a copy of object <code>o</code>, that is a fresh object with the same methods and instance variables as <code>o</code>.</p>\n", "kind": "value", "args": [["", "&lt; .. &gt;"]]}, {"path": "Oo", "name": "id", "type": "let id: &lt; .. &gt; => int", "docs": "<p>Return an integer identifying this object, unique for the current execution of the program. The generic comparison and hashing functions are based on this integer. When an object is obtained by unmarshaling, the id is refreshed, and thus different from the original object. As a consequence, the internal invariants of data structures such as hash table or sets containing objects are broken after unmarshaling the data structures.</p>\n", "kind": "value", "args": [["", "&lt; .. &gt;"]]}, {"path": "Oo", "name": "new_method", "type": "let new_method: string => CamlinternalOO.tag", "docs": "<p>For internal use (CamlIDL)</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Oo", "name": "public_method_label", "type": "let public_method_label: string => CamlinternalOO.tag", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "Oo", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>id\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>new_method\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>public_method_label", "docs": null, "kind": "module"}, {"path": "Obj", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Obj", "name": "repr", "type": "let repr: 'a => t", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Obj", "name": "obj", "type": "let obj: t => 'a", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Obj", "name": "magic", "type": "let magic: 'a => 'b", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Obj", "name": "is_block", "type": "let is_block: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Obj", "name": "is_int", "type": "let is_int: t => bool", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Obj", "name": "tag", "type": "let tag: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Obj", "name": "set_tag", "type": "let set_tag: (t, int) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Obj", "name": "size", "type": "let size: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Obj", "name": "field", "type": "let field: (t, int) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Obj", "name": "set_field", "type": "let set_field: (t, int, t) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Obj", "name": "double_field", "type": "let double_field: (t, int) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Obj", "name": "set_double_field", "type": "let set_double_field: (t, int, float) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"], ["", "float"]]}, {"path": "Obj", "name": "new_block", "type": "let new_block: (int, int) => t", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Obj", "name": "dup", "type": "let dup: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Obj", "name": "truncate", "type": "let truncate: (t, int) => unit", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Obj", "name": "add_offset", "type": "let add_offset: (t, Int32.t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "Int32.t"]]}, {"path": "Obj", "name": "first_non_constant_constructor_tag", "type": "let first_non_constant_constructor_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "last_non_constant_constructor_tag", "type": "let last_non_constant_constructor_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "lazy_tag", "type": "let lazy_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "closure_tag", "type": "let closure_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "object_tag", "type": "let object_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "infix_tag", "type": "let infix_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "forward_tag", "type": "let forward_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "no_scan_tag", "type": "let no_scan_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "abstract_tag", "type": "let abstract_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "string_tag", "type": "let string_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "double_tag", "type": "let double_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "double_array_tag", "type": "let double_array_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "custom_tag", "type": "let custom_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "final_tag", "type": "let final_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "int_tag", "type": "let int_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "out_of_heap_tag", "type": "let out_of_heap_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "unaligned_tag", "type": "let unaligned_tag: int", "docs": null, "kind": "value"}, {"path": "Obj", "name": "extension_name", "type": "let extension_name: 'a => string", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Obj", "name": "extension_id", "type": "let extension_id: 'a => int", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Obj", "name": "extension_slot", "type": "let extension_slot: 'a => t", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Obj", "name": "marshal", "type": "let marshal: t => bytes", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Obj", "name": "unmarshal", "type": "let unmarshal: (bytes, int) => (t, int)", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "", "name": "Obj", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abstract_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_offset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>closure_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>custom_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>double_array_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>double_field\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>double_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dup\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>extension_id\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>extension_name\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>extension_slot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>field\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>final_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>first_non_constant_constructor_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forward_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>infix_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_block\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>last_non_constant_constructor_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lazy_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>magic\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>marshal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>new_block\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>no_scan_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>obj\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>object_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>out_of_heap_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>repr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_double_field\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_field\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>truncate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unaligned_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unmarshal\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Nativeint", "name": "zero", "type": "let zero: nativeint", "docs": "<p>The native integer 0.</p>\n", "kind": "value"}, {"path": "Nativeint", "name": "one", "type": "let one: nativeint", "docs": "<p>The native integer 1.</p>\n", "kind": "value"}, {"path": "Nativeint", "name": "minus_one", "type": "let minus_one: nativeint", "docs": "<p>The native integer -1.</p>\n", "kind": "value"}, {"path": "Nativeint", "name": "neg", "type": "let neg: nativeint => nativeint", "docs": "<p>Unary negation.</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Nativeint", "name": "add", "type": "let add: (nativeint, nativeint) => nativeint", "docs": "<p>Addition.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "nativeint"]]}, {"path": "Nativeint", "name": "sub", "type": "let sub: (nativeint, nativeint) => nativeint", "docs": "<p>Subtraction.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "nativeint"]]}, {"path": "Nativeint", "name": "mul", "type": "let mul: (nativeint, nativeint) => nativeint", "docs": "<p>Multiplication.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "nativeint"]]}, {"path": "Nativeint", "name": "div", "type": "let div: (nativeint, nativeint) => nativeint", "docs": "<p>Integer division. Raise <code>Division_by_zero</code> if the second argument is zero. This division rounds the real quotient of its arguments towards zero, as specified for (/).</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "nativeint"]]}, {"path": "Nativeint", "name": "rem", "type": "let rem: (nativeint, nativeint) => nativeint", "docs": "<p>Integer remainder. If <code>y</code> is not zero, the result of <code>Nativeint.rem x y</code> satisfies the following properties: <code>Nativeint.zero &lt;= Nativeint.rem x y &lt; Nativeint.abs y</code> and <code>x = Nativeint.add (Nativeint.mul (Nativeint.div x y) y)\n                      (Nativeint.rem x y)</code>. If <code>y = 0</code>, <code>Nativeint.rem x y</code> raises <code>Division_by_zero</code>.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "nativeint"]]}, {"path": "Nativeint", "name": "succ", "type": "let succ: nativeint => nativeint", "docs": "<p>Successor. <code>Nativeint.succ x</code> is <code>Nativeint.add x Nativeint.one</code>.</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Nativeint", "name": "pred", "type": "let pred: nativeint => nativeint", "docs": "<p>Predecessor. <code>Nativeint.pred x</code> is <code>Nativeint.sub x Nativeint.one</code>.</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Nativeint", "name": "abs", "type": "let abs: nativeint => nativeint", "docs": "<p>Return the absolute value of its argument.</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Nativeint", "name": "size", "type": "let size: int", "docs": "<p>The size in bits of a native integer. This is equal to <code>32</code> on a 32-bit platform and to <code>64</code> on a 64-bit platform.</p>\n", "kind": "value"}, {"path": "Nativeint", "name": "max_int", "type": "let max_int: nativeint", "docs": "<p>The greatest representable native integer, either 2Superscript - 1 on a 32-bit platform, or 2Superscript - 1 on a 64-bit platform.</p>\n", "kind": "value"}, {"path": "Nativeint", "name": "min_int", "type": "let min_int: nativeint", "docs": "<p>The greatest representable native integer, either -2Superscript on a 32-bit platform, or -2Superscript on a 64-bit platform.</p>\n", "kind": "value"}, {"path": "Nativeint", "name": "logand", "type": "let logand: (nativeint, nativeint) => nativeint", "docs": "<p>Bitwise logical and.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "nativeint"]]}, {"path": "Nativeint", "name": "logor", "type": "let logor: (nativeint, nativeint) => nativeint", "docs": "<p>Bitwise logical or.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "nativeint"]]}, {"path": "Nativeint", "name": "logxor", "type": "let logxor: (nativeint, nativeint) => nativeint", "docs": "<p>Bitwise logical exclusive or.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "nativeint"]]}, {"path": "Nativeint", "name": "lognot", "type": "let lognot: nativeint => nativeint", "docs": "<p>Bitwise logical negation</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Nativeint", "name": "shift_left", "type": "let shift_left: (nativeint, int) => nativeint", "docs": "<p><code>Nativeint.shift_left x y</code> shifts <code>x</code> to the left by <code>y</code> bits. The result is unspecified if <code>y &lt; 0</code> or <code>y &gt;= bitsize</code>, where <code>bitsize</code> is <code>32</code> on a 32-bit platform and <code>64</code> on a 64-bit platform.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "int"]]}, {"path": "Nativeint", "name": "shift_right", "type": "let shift_right: (nativeint, int) => nativeint", "docs": "<p><code>Nativeint.shift_right x y</code> shifts <code>x</code> to the right by <code>y</code> bits. This is an arithmetic shift: the sign bit of <code>x</code> is replicated and inserted in the vacated bits. The result is unspecified if <code>y &lt; 0</code> or <code>y &gt;= bitsize</code>.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "int"]]}, {"path": "Nativeint", "name": "shift_right_logical", "type": "let shift_right_logical: (nativeint, int) => nativeint", "docs": "<p><code>Nativeint.shift_right_logical x y</code> shifts <code>x</code> to the right by <code>y</code> bits. This is a logical shift: zeroes are inserted in the vacated bits regardless of the sign of <code>x</code>. The result is unspecified if <code>y &lt; 0</code> or <code>y &gt;= bitsize</code>.</p>\n", "kind": "value", "args": [["", "nativeint"], ["", "int"]]}, {"path": "Nativeint", "name": "of_int", "type": "let of_int: int => nativeint", "docs": "<p>Convert the given integer (type <code>int</code>) to a native integer (type <code>nativeint</code>).</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Nativeint", "name": "to_int", "type": "let to_int: nativeint => int", "docs": "<p>Convert the given native integer (type <code>nativeint</code>) to an integer (type <code>int</code>). The high-order bit is lost during the conversion.</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Nativeint", "name": "of_float", "type": "let of_float: float => nativeint", "docs": "<p>Convert the given floating-point number to a native integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [min_int, max_int].</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Nativeint", "name": "to_float", "type": "let to_float: nativeint => float", "docs": "<p>Convert the given native integer to a floating-point number.</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Nativeint", "name": "of_int32", "type": "let of_int32: int32 => nativeint", "docs": "<p>Convert the given 32-bit integer (type <code>int32</code>) to a native integer.</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Nativeint", "name": "to_int32", "type": "let to_int32: nativeint => int32", "docs": "<p>Convert the given native integer to a 32-bit integer (type <code>int32</code>). On 64-bit platforms, the 64-bit native integer is taken modulo 2Superscript, i.e. the top 32 bits are lost. On 32-bit platforms, the conversion is exact.</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Nativeint", "name": "of_string", "type": "let of_string: string => nativeint", "docs": "<p>Convert the given string to a native integer. The string is read in decimal (by default) or in hexadecimal, octal or binary if the string begins with <code>0x</code>, <code>0o</code> or <code>0b</code> respectively. Raise <code>Failure &quot;int_of_string&quot;</code> if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type <code>nativeint</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Nativeint", "name": "to_string", "type": "let to_string: nativeint => string", "docs": "<p>Return the string representation of its argument, in decimal.</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Nativeint", "name": "t", "type": "type t = nativeint", "docs": "<p>An alias for the type of native integers.</p>\n", "kind": "type"}, {"path": "Nativeint", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for native integers, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Nativeint</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Nativeint", "name": "format", "type": "let format: (string, nativeint) => string", "docs": "<p><code>Nativeint.format fmt n</code> return the string representation of the native integer <code>n</code> in the format specified by <code>fmt</code>. <code>fmt</code> is a <code>Printf</code>-style format consisting of exactly one <code>%d</code>, <code>%i</code>, <code>%u</code>, <code>%x</code>, <code>%X</code> or <code>%o</code> conversion specification. This function is deprecated; use sprintf with a <code>%nx</code> format instead.</p>\n", "kind": "value", "args": [["", "string"], ["", "nativeint"]]}, {"path": "", "name": "Nativeint", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>div\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logand\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lognot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logxor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minus_one\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mul\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>neg\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_int32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>one\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pred\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift_right_logical\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>succ\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_int32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zero\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "MoreLabels.Hashtbl", "name": "t", "type": "type t('a, 'b) = Hashtbl.t('a, 'b)", "docs": null, "kind": "type"}, {"path": "MoreLabels.Hashtbl", "name": "create", "type": "let create: (~?random: option(bool), int) => t('a, 'b)", "docs": null, "kind": "value", "args": [["random", "bool (optional)"], ["", "int"]]}, {"path": "MoreLabels.Hashtbl", "name": "clear", "type": "let clear: t('a, 'b) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "MoreLabels.Hashtbl", "name": "reset", "type": "let reset: t('a, 'b) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "MoreLabels.Hashtbl", "name": "copy", "type": "let copy: t('a, 'b) => t('a, 'b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "MoreLabels.Hashtbl", "name": "add", "type": "let add: (t('a, 'b), ~key: 'a, ~data: 'b) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["key", "'a"], ["data", "'b"]]}, {"path": "MoreLabels.Hashtbl", "name": "find", "type": "let find: (t('a, 'b), 'a) => 'b", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"]]}, {"path": "MoreLabels.Hashtbl", "name": "find_all", "type": "let find_all: (t('a, 'b), 'a) => list('b)", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"]]}, {"path": "MoreLabels.Hashtbl", "name": "mem", "type": "let mem: (t('a, 'b), 'a) => bool", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"]]}, {"path": "MoreLabels.Hashtbl", "name": "remove", "type": "let remove: (t('a, 'b), 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"]]}, {"path": "MoreLabels.Hashtbl", "name": "replace", "type": "let replace: (t('a, 'b), ~key: 'a, ~data: 'b) => unit", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"], ["key", "'a"], ["data", "'b"]]}, {"path": "MoreLabels.Hashtbl", "name": "iter", "type": "let iter: (~f: (~key: 'a, ~data: 'b) => unit, t('a, 'b)) => unit", "docs": null, "kind": "value", "args": [["f", "(~key: 'a, ~data: 'b) => unit"], ["", "t('a, 'b)"]]}, {"path": "MoreLabels.Hashtbl", "name": "fold", "type": "let fold: (~f: (~key: 'a, ~data: 'b, 'c) => 'c, t('a, 'b), ~init: 'c) => 'c", "docs": null, "kind": "value", "args": [["f", "(~key: 'a, ~data: 'b, 'c) => 'c"], ["", "t('a, 'b)"], ["init", "'c"]]}, {"path": "MoreLabels.Hashtbl", "name": "length", "type": "let length: t('a, 'b) => int", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "MoreLabels.Hashtbl", "name": "randomize", "type": "let randomize: unit => unit", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "MoreLabels.Hashtbl", "name": "statistics", "type": "type statistics = Hashtbl.statistics", "docs": null, "kind": "type"}, {"path": "MoreLabels.Hashtbl", "name": "stats", "type": "let stats: t('a, 'b) => statistics", "docs": null, "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "MoreLabels.Hashtbl", "name": "Make", "type": "", "docs": null, "kind": "module"}, {"path": "MoreLabels.Hashtbl", "name": "MakeSeeded", "type": "", "docs": null, "kind": "module"}, {"path": "MoreLabels.Hashtbl", "name": "hash", "type": "let hash: 'a => int", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "MoreLabels.Hashtbl", "name": "seeded_hash", "type": "let seeded_hash: (int, 'a) => int", "docs": null, "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "MoreLabels.Hashtbl", "name": "hash_param", "type": "let hash_param: (int, int, 'a) => int", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["", "'a"]]}, {"path": "MoreLabels.Hashtbl", "name": "seeded_hash_param", "type": "let seeded_hash_param: (int, int, int, 'a) => int", "docs": null, "kind": "value", "args": [["", "int"], ["", "int"], ["", "int"], ["", "'a"]]}, {"path": "MoreLabels", "name": "Hashtbl", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find_all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hash\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hash_param\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>randomize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>replace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>seeded_hash\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>seeded_hash_param\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stats\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>statistics\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Make\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeSeeded", "docs": null, "kind": "module"}, {"path": "MoreLabels.Map", "name": "Make", "type": "", "docs": null, "kind": "module"}, {"path": "MoreLabels", "name": "Map", "type": "<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Make", "docs": null, "kind": "module"}, {"path": "MoreLabels.Set", "name": "Make", "type": "", "docs": null, "kind": "module"}, {"path": "MoreLabels", "name": "Set", "type": "<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Make", "docs": null, "kind": "module"}, {"path": "", "name": "MoreLabels", "type": "<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Hashtbl\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Map\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Set", "docs": null, "kind": "module"}, {"path": "Marshal", "name": "extern_flags", "type": "type extern_flags = | No_sharing | Closures | Compat_32\n", "docs": "<p>The flags to the <code>Marshal.to_*</code> functions below.</p>\n", "kind": "type"}, {"path": "Marshal", "name": "to_channel", "type": "let to_channel: (Pervasives.out_channel, 'a, list(extern_flags)) => unit", "docs": "<p><code>Marshal.to_channel chan v flags</code> writes the representation of <code>v</code> on channel <code>chan</code>. The <code>flags</code> argument is a possibly empty list of flags that governs the marshaling behavior with respect to sharing, functional values, and compatibility between 32- and 64-bit platforms.</p>\n<p>If <code>flags</code> does not contain <code>Marshal.No_sharing</code>, circularities and sharing inside the value <code>v</code> are detected and preserved in the sequence of bytes produced. In particular, this guarantees that marshaling always terminates. Sharing between values marshaled by successive calls to <code>Marshal.to_channel</code> is neither detected nor preserved, though. If <code>flags</code> contains <code>Marshal.No_sharing</code>, sharing is ignored. This results in faster marshaling if <code>v</code> contains no shared substructures, but may cause slower marshaling and larger byte representations if <code>v</code> actually contains sharing, or even non-termination if <code>v</code> contains cycles.</p>\n<p>If <code>flags</code> does not contain <code>Marshal.Closures</code>, marshaling fails when it encounters a functional value inside <code>v</code>: only &#39;pure&#39; data structures, containing neither functions nor objects, can safely be transmitted between different programs. If <code>flags</code> contains <code>Marshal.Closures</code>, functional values will be marshaled as a the position in the code of the program together with the values corresponding to the free variables captured in the closure. In this case, the output of marshaling can only be read back in processes that run exactly the same program, with exactly the same compiled code. (This is checked at un-marshaling time, using an MD5 digest of the code transmitted along with the code position.)</p>\n<p>The exact definition of which free variables are captured in a closure is not specified and can very between bytecode and native code (and according to optimization flags). In particular, a function value accessing a global reference may or may not include the reference in its closure. If it does, unmarshaling the corresponding closure will create a new reference, different from the global one.</p>\n<p>If <code>flags</code> contains <code>Marshal.Compat_32</code>, marshaling fails when it encounters an integer value outside the range <code>[-2{^30}, 2{^30}-1]</code> of integers that are representable on a 32-bit platform. This ensures that marshaled data generated on a 64-bit platform can be safely read back on a 32-bit platform. If <code>flags</code> does not contain <code>Marshal.Compat_32</code>, integer values outside the range <code>[-2{^30}, 2{^30}-1]</code> are marshaled, and can be read back on a 64-bit platform, but will cause an error at un-marshaling time when read back on a 32-bit platform. The <code>Mashal.Compat_32</code> flag only matters when marshaling is performed on a 64-bit platform; it has no effect if marshaling is performed on a 32-bit platform.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"], ["", "'a"], ["", "list(extern_flags)"]]}, {"path": "Marshal", "name": "to_bytes", "type": "let to_bytes: ('a, list(extern_flags)) => bytes", "docs": "<p><code>Marshal.to_bytes v flags</code> returns a byte sequence containing the representation of <code>v</code>. The <code>flags</code> argument has the same meaning as for to_channel.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "'a"], ["", "list(extern_flags)"]]}, {"path": "Marshal", "name": "to_string", "type": "let to_string: ('a, list(extern_flags)) => string", "docs": "<p>Same as <code>to_bytes</code> but return the result as a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(extern_flags)"]]}, {"path": "Marshal", "name": "to_buffer", "type": "let to_buffer: (bytes, int, int, 'a, list(extern_flags)) => int", "docs": "<p><code>Marshal.to_buffer buff ofs len v flags</code> marshals the value <code>v</code>, storing its byte representation in the sequence <code>buff</code>, starting at index <code>ofs</code>, and writing at most <code>len</code> bytes. It returns the number of bytes actually written to the sequence. If the byte representation of <code>v</code> does not fit in <code>len</code> characters, the exception <code>Failure</code> is raised.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"], ["", "'a"], ["", "list(extern_flags)"]]}, {"path": "Marshal", "name": "from_channel", "type": "let from_channel: Pervasives.in_channel => 'a", "docs": "<p><code>Marshal.from_channel chan</code> reads from channel <code>chan</code> the byte representation of a structured value, as produced by one of the <code>Marshal.to_*</code> functions, and reconstructs and returns the corresponding value.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "Marshal", "name": "from_bytes", "type": "let from_bytes: (bytes, int) => 'a", "docs": "<p><code>Marshal.from_bytes buff ofs</code> unmarshals a structured value like from_channel does, except that the byte representation is not read from a channel, but taken from the byte sequence <code>buff</code>, starting at position <code>ofs</code>. The byte sequence is not mutated.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "Marshal", "name": "from_string", "type": "let from_string: (string, int) => 'a", "docs": "<p>Same as <code>from_bytes</code> but take a string as argument instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"]]}, {"path": "Marshal", "name": "header_size", "type": "let header_size: int", "docs": "<p>The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header. header_size is the size, in bytes, of the header. data_size<code> buff ofs</code> is the size, in bytes, of the data part, assuming a valid header is stored in <code>buff</code> starting at position <code>ofs</code>. Finally, total_size <code>buff ofs</code> is the total size, in bytes, of the marshaled value. Both data_size and total_size raise <code>Failure</code> if <code>buff</code>, <code>ofs</code> does not contain a valid header.</p>\n<p>To read the byte representation of a marshaled value into a byte sequence, the program needs to read first header_size bytes into the sequence, then determine the length of the remainder of the representation using data_size, make sure the sequence is large enough to hold the remaining data, then read it, and finally call from_bytes to unmarshal the value.</p>\n", "kind": "value"}, {"path": "Marshal", "name": "data_size", "type": "let data_size: (bytes, int) => int", "docs": "<p>See header_size.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "Marshal", "name": "total_size", "type": "let total_size: (bytes, int) => int", "docs": "<p>See header_size.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "", "name": "Marshal", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>data_size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_bytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>header_size\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_buffer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_bytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>total_size\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>extern_flags", "docs": null, "kind": "module"}, {"path": "Map", "name": "Make", "type": "", "docs": "<p>Functor building an implementation of the map structure given a totally ordered type.</p>\n", "kind": "module"}, {"path": "", "name": "Map", "type": "<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Make", "docs": null, "kind": "module"}, {"path": "ListLabels", "name": "length", "type": "let length: list('a) => int", "docs": "<p>Return the length (number of elements) of the given list.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "ListLabels", "name": "hd", "type": "let hd: list('a) => 'a", "docs": "<p>Return the first element of the given list. Raise <code>Failure &quot;hd&quot;</code> if the list is empty.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "ListLabels", "name": "tl", "type": "let tl: list('a) => list('a)", "docs": "<p>Return the given list without its first element. Raise <code>Failure &quot;tl&quot;</code> if the list is empty.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "ListLabels", "name": "nth", "type": "let nth: (list('a), int) => 'a", "docs": "<p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Raise <code>Failure &quot;nth&quot;</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "int"]]}, {"path": "ListLabels", "name": "rev", "type": "let rev: list('a) => list('a)", "docs": "<p>List reversal.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "ListLabels", "name": "append", "type": "let append: (list('a), list('a)) => list('a)", "docs": "<p>Catenate two lists. Same function as the infix operator <code>@</code>. Not tail-recursive (length of the first argument). The <code>@</code> operator is not tail-recursive either.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "rev_append", "type": "let rev_append: (list('a), list('a)) => list('a)", "docs": "<p><code>ListLabels.rev_append l1 l2</code> reverses <code>l1</code> and concatenates it to <code>l2</code>. This is equivalent to rev<code> l1 @ l2</code>, but <code>rev_append</code> is tail-recursive and more efficient.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "concat", "type": "let concat: list(list('a)) => list('a)", "docs": "<p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</p>\n", "kind": "value", "args": [["", "list(list('a))"]]}, {"path": "ListLabels", "name": "flatten", "type": "let flatten: list(list('a)) => list('a)", "docs": "<p>Same as <code>concat</code>. Not tail-recursive (length of the argument + length of the longest sub-list).</p>\n", "kind": "value", "args": [["", "list(list('a))"]]}, {"path": "ListLabels", "name": "iter", "type": "let iter: (~f: 'a => unit, list('a)) => unit", "docs": "<p><code>ListLabels.iter f [a1; ...; an]</code> applies function <code>f</code> in turn to <code>a1; ...; an</code>. It is equivalent to <code>begin f a1; f a2; ...; f an; () end</code>.</p>\n", "kind": "value", "args": [["f", "'a => unit"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "iteri", "type": "let iteri: (~f: (int, 'a) => unit, list('a)) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p>\nSince: 4.00.0", "kind": "value", "args": [["f", "(int, 'a) => unit"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "map", "type": "let map: (~f: 'a => 'b, list('a)) => list('b)", "docs": "<p><code>ListLabels.map f [a1; ...; an]</code> applies function <code>f</code> to <code>a1, ..., an</code>, and builds the list <code>[f a1; ...; f an]</code> with the results returned by <code>f</code>. Not tail-recursive.</p>\n", "kind": "value", "args": [["f", "'a => 'b"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "mapi", "type": "let mapi: (~f: (int, 'a) => 'b, list('a)) => list('b)", "docs": "<p>Same as map, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p>\nSince: 4.00.0", "kind": "value", "args": [["f", "(int, 'a) => 'b"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "rev_map", "type": "let rev_map: (~f: 'a => 'b, list('a)) => list('b)", "docs": "<p><code>ListLabels.rev_map f l</code> gives the same result as rev<code> (</code>map<code> f l)</code>, but is tail-recursive and more efficient.</p>\n", "kind": "value", "args": [["f", "'a => 'b"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "fold_left", "type": "let fold_left: (~f: ('a, 'b) => 'a, ~init: 'a, list('b)) => 'a", "docs": "<p><code>ListLabels.fold_left f a [b1; ...; bn]</code> is <code>f (... (f (f a b1) b2) ...) bn</code>.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'a"], ["init", "'a"], ["", "list('b)"]]}, {"path": "ListLabels", "name": "fold_right", "type": "let fold_right: (~f: ('a, 'b) => 'b, list('a), ~init: 'b) => 'b", "docs": "<p><code>ListLabels.fold_right f [a1; ...; an] b</code> is <code>f a1 (f a2 (... (f an b) ...))</code>. Not tail-recursive.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'b"], ["", "list('a)"], ["init", "'b"]]}, {"path": "ListLabels", "name": "iter2", "type": "let iter2: (~f: ('a, 'b) => unit, list('a), list('b)) => unit", "docs": "<p><code>ListLabels.iter2 f [a1; ...; an] [b1; ...; bn]</code> calls in turn <code>f a1 b1; ...; f an bn</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => unit"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "ListLabels", "name": "map2", "type": "let map2: (~f: ('a, 'b) => 'c, list('a), list('b)) => list('c)", "docs": "<p><code>ListLabels.map2 f [a1; ...; an] [b1; ...; bn]</code> is <code>[f a1 b1; ...; f an bn]</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'c"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "ListLabels", "name": "rev_map2", "type": "let rev_map2: (~f: ('a, 'b) => 'c, list('a), list('b)) => list('c)", "docs": "<p><code>ListLabels.rev_map2 f l1 l2</code> gives the same result as rev<code> (</code>map2<code> f l1 l2)</code>, but is tail-recursive and more efficient.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'c"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "ListLabels", "name": "fold_left2", "type": "let fold_left2: (~f: ('a, 'b, 'c) => 'a, ~init: 'a, list('b), list('c)) => 'a", "docs": "<p><code>ListLabels.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</code> is <code>f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["f", "('a, 'b, 'c) => 'a"], ["init", "'a"], ["", "list('b)"], ["", "list('c)"]]}, {"path": "ListLabels", "name": "fold_right2", "type": "let fold_right2: (~f: ('a, 'b, 'c) => 'c, list('a), list('b), ~init: 'c) => 'c", "docs": "<p><code>ListLabels.fold_right2 f [a1; ...; an] [b1; ...; bn] c</code> is <code>f a1 b1 (f a2 b2 (... (f an bn c) ...))</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>\n", "kind": "value", "args": [["f", "('a, 'b, 'c) => 'c"], ["", "list('a)"], ["", "list('b)"], ["init", "'c"]]}, {"path": "ListLabels", "name": "for_all", "type": "let for_all: (~f: 'a => bool, list('a)) => bool", "docs": "<p><code>for_all p [a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code>p</code>. That is, it returns <code>(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)</code>.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "exists", "type": "let exists: (~f: 'a => bool, list('a)) => bool", "docs": "<p><code>exists p [a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code>p</code>. That is, it returns <code>(p a1) || (p a2) || ... || (p an)</code>.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "for_all2", "type": "let for_all2: (~f: ('a, 'b) => bool, list('a), list('b)) => bool", "docs": "<p>Same as for_all, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => bool"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "ListLabels", "name": "exists2", "type": "let exists2: (~f: ('a, 'b) => bool, list('a), list('b)) => bool", "docs": "<p>Same as exists, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => bool"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "ListLabels", "name": "mem", "type": "let mem: ('a, ~set: list('a)) => bool", "docs": "<p><code>mem a l</code> is true if and only if <code>a</code> is equal to an element of <code>l</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["set", "list('a)"]]}, {"path": "ListLabels", "name": "memq", "type": "let memq: ('a, ~set: list('a)) => bool", "docs": "<p>Same as mem, but uses physical equality instead of structural equality to compare list elements.</p>\n", "kind": "value", "args": [["", "'a"], ["set", "list('a)"]]}, {"path": "ListLabels", "name": "find", "type": "let find: (~f: 'a => bool, list('a)) => 'a", "docs": "<p><code>find p l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>p</code>. Raise <code>Not_found</code> if there is no value that satisfies <code>p</code> in the list <code>l</code>.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "filter", "type": "let filter: (~f: 'a => bool, list('a)) => list('a)", "docs": "<p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "find_all", "type": "let find_all: (~f: 'a => bool, list('a)) => list('a)", "docs": "<p><code>find_all</code> is another name for filter.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "partition", "type": "let partition: (~f: 'a => bool, list('a)) => (list('a), list('a))", "docs": "<p><code>partition p l</code> returns a pair of lists <code>(l1, l2)</code>, where <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate <code>p</code>, and <code>l2</code> is the list of all the elements of <code>l</code> that do not satisfy <code>p</code>. The order of the elements in the input list is preserved.</p>\n", "kind": "value", "args": [["f", "'a => bool"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "assoc", "type": "let assoc: ('a, list(('a, 'b))) => 'b", "docs": "<p><code>assoc a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc a [ ...; (a,b); ...] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Raise <code>Not_found</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "ListLabels", "name": "assq", "type": "let assq: ('a, list(('a, 'b))) => 'b", "docs": "<p>Same as assoc, but uses physical equality instead of structural equality to compare keys.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "ListLabels", "name": "mem_assoc", "type": "let mem_assoc: ('a, ~map: list(('a, 'b))) => bool", "docs": "<p>Same as assoc, but simply return true if a binding exists, and false if no bindings exist for the given key.</p>\n", "kind": "value", "args": [["", "'a"], ["map", "list(('a, 'b))"]]}, {"path": "ListLabels", "name": "mem_assq", "type": "let mem_assq: ('a, ~map: list(('a, 'b))) => bool", "docs": "<p>Same as mem_assoc, but uses physical equality instead of structural equality to compare keys.</p>\n", "kind": "value", "args": [["", "'a"], ["map", "list(('a, 'b))"]]}, {"path": "ListLabels", "name": "remove_assoc", "type": "let remove_assoc: ('a, list(('a, 'b))) => list(('a, 'b))", "docs": "<p><code>remove_assoc a l</code> returns the list of pairs <code>l</code> without the first pair with key <code>a</code>, if any. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "ListLabels", "name": "remove_assq", "type": "let remove_assq: ('a, list(('a, 'b))) => list(('a, 'b))", "docs": "<p>Same as remove_assoc, but uses physical equality instead of structural equality to compare keys. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "ListLabels", "name": "split", "type": "let split: list(('a, 'b)) => (list('a), list('b))", "docs": "<p>Transform a list of pairs into a pair of lists: <code>split [(a1,b1); ...; (an,bn)]</code> is <code>([a1; ...; an], [b1; ...; bn])</code>. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "list(('a, 'b))"]]}, {"path": "ListLabels", "name": "combine", "type": "let combine: (list('a), list('b)) => list(('a, 'b))", "docs": "<p>Transform a pair of lists into a list of pairs: <code>combine [a1; ...; an] [b1; ...; bn]</code> is <code>[(a1,b1); ...; (an,bn)]</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('b)"]]}, {"path": "ListLabels", "name": "sort", "type": "let sort: (~cmp: ('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, compare is a suitable comparison function. The resulting list is sorted in increasing order. <code>ListLabels.sort</code> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p>\n<p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "stable_sort", "type": "let stable_sort: (~cmp: ('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Same as sort, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .</p>\n<p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "fast_sort", "type": "let fast_sort: (~cmp: ('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Same as sort or stable_sort, whichever is faster on typical input.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "ListLabels", "name": "merge", "type": "let merge: (~cmp: ('a, 'a) => int, list('a), list('a)) => list('a)", "docs": "<p>Merge two lists: Assuming that <code>l1</code> and <code>l2</code> are sorted according to the comparison function <code>cmp</code>, <code>merge cmp l1 l2</code> will return a sorted list containting all the elements of <code>l1</code> and <code>l2</code>. If several elements compare equal, the elements of <code>l1</code> will be before the elements of <code>l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "list('a)"], ["", "list('a)"]]}, {"path": "", "name": "ListLabels", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>assoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>assq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>combine\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exists\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exists2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fast_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find_all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatten\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_left2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_right2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>for_all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>for_all2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem_assoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem_assq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>memq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove_assoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove_assq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_map2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stable_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tl", "docs": null, "kind": "module"}, {"path": "List", "name": "length", "type": "let length: list('a) => int", "docs": "<p>Return the length (number of elements) of the given list.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "List", "name": "hd", "type": "let hd: list('a) => 'a", "docs": "<p>Return the first element of the given list. Raise <code>Failure &quot;hd&quot;</code> if the list is empty.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "List", "name": "tl", "type": "let tl: list('a) => list('a)", "docs": "<p>Return the given list without its first element. Raise <code>Failure &quot;tl&quot;</code> if the list is empty.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "List", "name": "nth", "type": "let nth: (list('a), int) => 'a", "docs": "<p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Raise <code>Failure &quot;nth&quot;</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "int"]]}, {"path": "List", "name": "rev", "type": "let rev: list('a) => list('a)", "docs": "<p>List reversal.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "List", "name": "append", "type": "let append: (list('a), list('a)) => list('a)", "docs": "<p>Catenate two lists. Same function as the infix operator <code>@</code>. Not tail-recursive (length of the first argument). The <code>@</code> operator is not tail-recursive either.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('a)"]]}, {"path": "List", "name": "rev_append", "type": "let rev_append: (list('a), list('a)) => list('a)", "docs": "<p><code>List.rev_append l1 l2</code> reverses <code>l1</code> and concatenates it to <code>l2</code>. This is equivalent to rev<code> l1 @ l2</code>, but <code>rev_append</code> is tail-recursive and more efficient.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('a)"]]}, {"path": "List", "name": "concat", "type": "let concat: list(list('a)) => list('a)", "docs": "<p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</p>\n", "kind": "value", "args": [["", "list(list('a))"]]}, {"path": "List", "name": "flatten", "type": "let flatten: list(list('a)) => list('a)", "docs": "<p>Same as <code>concat</code>. Not tail-recursive (length of the argument + length of the longest sub-list).</p>\n", "kind": "value", "args": [["", "list(list('a))"]]}, {"path": "List", "name": "iter", "type": "let iter: ('a => unit, list('a)) => unit", "docs": "<p><code>List.iter f [a1; ...; an]</code> applies function <code>f</code> in turn to <code>a1; ...; an</code>. It is equivalent to <code>begin f a1; f a2; ...; f an; () end</code>.</p>\n", "kind": "value", "args": [["", "'a => unit"], ["", "list('a)"]]}, {"path": "List", "name": "iteri", "type": "let iteri: ((int, 'a) => unit, list('a)) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "(int, 'a) => unit"], ["", "list('a)"]]}, {"path": "List", "name": "map", "type": "let map: ('a => 'b, list('a)) => list('b)", "docs": "<p><code>List.map f [a1; ...; an]</code> applies function <code>f</code> to <code>a1, ..., an</code>, and builds the list <code>[f a1; ...; f an]</code> with the results returned by <code>f</code>. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "'a => 'b"], ["", "list('a)"]]}, {"path": "List", "name": "mapi", "type": "let mapi: ((int, 'a) => 'b, list('a)) => list('b)", "docs": "<p>Same as map, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument. Not tail-recursive.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "(int, 'a) => 'b"], ["", "list('a)"]]}, {"path": "List", "name": "rev_map", "type": "let rev_map: ('a => 'b, list('a)) => list('b)", "docs": "<p><code>List.rev_map f l</code> gives the same result as rev<code> (</code>map<code> f l)</code>, but is tail-recursive and more efficient.</p>\n", "kind": "value", "args": [["", "'a => 'b"], ["", "list('a)"]]}, {"path": "List", "name": "fold_left", "type": "let fold_left: (('a, 'b) => 'a, 'a, list('b)) => 'a", "docs": "<p><code>List.fold_left f a [b1; ...; bn]</code> is <code>f (... (f (f a b1) b2) ...) bn</code>.</p>\n", "kind": "value", "args": [["", "('a, 'b) => 'a"], ["", "'a"], ["", "list('b)"]]}, {"path": "List", "name": "fold_right", "type": "let fold_right: (('a, 'b) => 'b, list('a), 'b) => 'b", "docs": "<p><code>List.fold_right f [a1; ...; an] b</code> is <code>f a1 (f a2 (... (f an b) ...))</code>. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "('a, 'b) => 'b"], ["", "list('a)"], ["", "'b"]]}, {"path": "List", "name": "iter2", "type": "let iter2: (('a, 'b) => unit, list('a), list('b)) => unit", "docs": "<p><code>List.iter2 f [a1; ...; an] [b1; ...; bn]</code> calls in turn <code>f a1 b1; ...; f an bn</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["", "('a, 'b) => unit"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "List", "name": "map2", "type": "let map2: (('a, 'b) => 'c, list('a), list('b)) => list('c)", "docs": "<p><code>List.map2 f [a1; ...; an] [b1; ...; bn]</code> is <code>[f a1 b1; ...; f an bn]</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "('a, 'b) => 'c"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "List", "name": "rev_map2", "type": "let rev_map2: (('a, 'b) => 'c, list('a), list('b)) => list('c)", "docs": "<p><code>List.rev_map2 f l1 l2</code> gives the same result as rev<code> (</code>map2<code> f l1 l2)</code>, but is tail-recursive and more efficient.</p>\n", "kind": "value", "args": [["", "('a, 'b) => 'c"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "List", "name": "fold_left2", "type": "let fold_left2: (('a, 'b, 'c) => 'a, 'a, list('b), list('c)) => 'a", "docs": "<p><code>List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</code> is <code>f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["", "('a, 'b, 'c) => 'a"], ["", "'a"], ["", "list('b)"], ["", "list('c)"]]}, {"path": "List", "name": "fold_right2", "type": "let fold_right2: (('a, 'b, 'c) => 'c, list('a), list('b), 'c) => 'c", "docs": "<p><code>List.fold_right2 f [a1; ...; an] [b1; ...; bn] c</code> is <code>f a1 b1 (f a2 b2 (... (f an bn c) ...))</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "('a, 'b, 'c) => 'c"], ["", "list('a)"], ["", "list('b)"], ["", "'c"]]}, {"path": "List", "name": "for_all", "type": "let for_all: ('a => bool, list('a)) => bool", "docs": "<p><code>for_all p [a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code>p</code>. That is, it returns <code>(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)</code>.</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "list('a)"]]}, {"path": "List", "name": "exists", "type": "let exists: ('a => bool, list('a)) => bool", "docs": "<p><code>exists p [a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code>p</code>. That is, it returns <code>(p a1) || (p a2) || ... || (p an)</code>.</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "list('a)"]]}, {"path": "List", "name": "for_all2", "type": "let for_all2: (('a, 'b) => bool, list('a), list('b)) => bool", "docs": "<p>Same as for_all, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["", "('a, 'b) => bool"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "List", "name": "exists2", "type": "let exists2: (('a, 'b) => bool, list('a), list('b)) => bool", "docs": "<p>Same as exists, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>\n", "kind": "value", "args": [["", "('a, 'b) => bool"], ["", "list('a)"], ["", "list('b)"]]}, {"path": "List", "name": "mem", "type": "let mem: ('a, list('a)) => bool", "docs": "<p><code>mem a l</code> is true if and only if <code>a</code> is equal to an element of <code>l</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list('a)"]]}, {"path": "List", "name": "memq", "type": "let memq: ('a, list('a)) => bool", "docs": "<p>Same as mem, but uses physical equality instead of structural equality to compare list elements.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list('a)"]]}, {"path": "List", "name": "find", "type": "let find: ('a => bool, list('a)) => 'a", "docs": "<p><code>find p l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>p</code>. Raise <code>Not_found</code> if there is no value that satisfies <code>p</code> in the list <code>l</code>.</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "list('a)"]]}, {"path": "List", "name": "filter", "type": "let filter: ('a => bool, list('a)) => list('a)", "docs": "<p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "list('a)"]]}, {"path": "List", "name": "find_all", "type": "let find_all: ('a => bool, list('a)) => list('a)", "docs": "<p><code>find_all</code> is another name for filter.</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "list('a)"]]}, {"path": "List", "name": "partition", "type": "let partition: ('a => bool, list('a)) => (list('a), list('a))", "docs": "<p><code>partition p l</code> returns a pair of lists <code>(l1, l2)</code>, where <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate <code>p</code>, and <code>l2</code> is the list of all the elements of <code>l</code> that do not satisfy <code>p</code>. The order of the elements in the input list is preserved.</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "list('a)"]]}, {"path": "List", "name": "assoc", "type": "let assoc: ('a, list(('a, 'b))) => 'b", "docs": "<p><code>assoc a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc a [ ...; (a,b); ...] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Raise <code>Not_found</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "List", "name": "assq", "type": "let assq: ('a, list(('a, 'b))) => 'b", "docs": "<p>Same as assoc, but uses physical equality instead of structural equality to compare keys.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "List", "name": "mem_assoc", "type": "let mem_assoc: ('a, list(('a, 'b))) => bool", "docs": "<p>Same as assoc, but simply return true if a binding exists, and false if no bindings exist for the given key.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "List", "name": "mem_assq", "type": "let mem_assq: ('a, list(('a, 'b))) => bool", "docs": "<p>Same as mem_assoc, but uses physical equality instead of structural equality to compare keys.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "List", "name": "remove_assoc", "type": "let remove_assoc: ('a, list(('a, 'b))) => list(('a, 'b))", "docs": "<p><code>remove_assoc a l</code> returns the list of pairs <code>l</code> without the first pair with key <code>a</code>, if any. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "List", "name": "remove_assq", "type": "let remove_assq: ('a, list(('a, 'b))) => list(('a, 'b))", "docs": "<p>Same as remove_assoc, but uses physical equality instead of structural equality to compare keys. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "'a"], ["", "list(('a, 'b))"]]}, {"path": "List", "name": "split", "type": "let split: list(('a, 'b)) => (list('a), list('b))", "docs": "<p>Transform a list of pairs into a pair of lists: <code>split [(a1,b1); ...; (an,bn)]</code> is <code>([a1; ...; an], [b1; ...; bn])</code>. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "list(('a, 'b))"]]}, {"path": "List", "name": "combine", "type": "let combine: (list('a), list('b)) => list(('a, 'b))", "docs": "<p>Transform a pair of lists into a list of pairs: <code>combine [a1; ...; an] [b1; ...; bn]</code> is <code>[(a1,b1); ...; (an,bn)]</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>\n", "kind": "value", "args": [["", "list('a)"], ["", "list('b)"]]}, {"path": "List", "name": "sort", "type": "let sort: (('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, compare is a suitable comparison function. The resulting list is sorted in increasing order. <code>List.sort</code> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p>\n<p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p>\n", "kind": "value", "args": [["", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "List", "name": "stable_sort", "type": "let stable_sort: (('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Same as sort, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .</p>\n<p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p>\n", "kind": "value", "args": [["", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "List", "name": "fast_sort", "type": "let fast_sort: (('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Same as sort or stable_sort, whichever is faster on typical input.</p>\n", "kind": "value", "args": [["", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "List", "name": "sort_uniq", "type": "let sort_uniq: (('a, 'a) => int, list('a)) => list('a)", "docs": "<p>Same as sort, but also remove duplicates.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "('a, 'a) => int"], ["", "list('a)"]]}, {"path": "List", "name": "merge", "type": "let merge: (('a, 'a) => int, list('a), list('a)) => list('a)", "docs": "<p>Merge two lists: Assuming that <code>l1</code> and <code>l2</code> are sorted according to the comparison function <code>cmp</code>, <code>merge cmp l1 l2</code> will return a sorted list containting all the elements of <code>l1</code> and <code>l2</code>. If several elements compare equal, the elements of <code>l1</code> will be before the elements of <code>l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p>\n", "kind": "value", "args": [["", "('a, 'a) => int"], ["", "list('a)"], ["", "list('a)"]]}, {"path": "", "name": "List", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>assoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>assq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>combine\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exists\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exists2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fast_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find_all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatten\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_left2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_right2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>for_all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>for_all2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem_assoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem_assq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>memq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>merge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>partition\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove_assoc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove_assq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_map2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sort_uniq\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stable_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tl", "docs": null, "kind": "module"}, {"path": "Lexing", "name": "position", "type": "type position = {pos_fname: string, pos_lnum: int, pos_bol: int, pos_cnum: int}", "docs": "<p>A value of type <code>position</code> describes a point in a source file. <code>pos_fname</code> is the file name; <code>pos_lnum</code> is the line number; <code>pos_bol</code> is the offset of the beginning of the line (number of characters between the beginning of the lexbuf and the beginning of the line); <code>pos_cnum</code> is the offset of the position (number of characters between the beginning of the lexbuf and the position). The difference between <code>pos_cnum</code> and <code>pos_bol</code> is the character offset within the line (i.e. the column number, assuming each character is one column wide).</p>\n<p>See the documentation of type <code>lexbuf</code> for information about how the lexing engine will manage positions.</p>\n", "kind": "type"}, {"path": "Lexing", "name": "dummy_pos", "type": "let dummy_pos: position", "docs": null, "kind": "value"}, {"path": "Lexing", "name": "lexbuf", "type": "type lexbuf = {\n  refill_buff: lexbuf => unit,\n  mut lex_buffer: bytes,\n  mut lex_buffer_len: int,\n  mut lex_abs_pos: int,\n  mut lex_start_pos: int,\n  mut lex_curr_pos: int,\n  mut lex_last_pos: int,\n  mut lex_last_action: int,\n  mut lex_eof_reached: bool,\n  mut lex_mem: array(int),\n  mut lex_start_p: position,\n  mut lex_curr_p: position\n}", "docs": "<p>The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated scanners. The lexer buffer holds the current state of the scanner, plus a function to refill the buffer from the input.</p>\n<p>At each token, the lexing engine will copy <code>lex_curr_p</code> to <code>lex_start_p</code>, then change the <code>pos_cnum</code> field of <code>lex_curr_p</code> by updating it with the number of characters read since the start of the <code>lexbuf</code>. The other fields are left unchanged by the lexing engine. In order to keep them accurate, they must be initialised before the first use of the lexbuf, and updated by the relevant lexer actions (i.e. at each end of line -- see also <code>new_line</code>).</p>\n", "kind": "type"}, {"path": "Lexing", "name": "from_channel", "type": "let from_channel: Pervasives.in_channel => lexbuf", "docs": "<p>Create a lexer buffer on the given input channel. <code>Lexing.from_channel inchan</code> returns a lexer buffer which reads from the input channel <code>inchan</code>, at the current reading position.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "Lexing", "name": "from_string", "type": "let from_string: string => lexbuf", "docs": "<p>Create a lexer buffer which reads from the given string. Reading starts from the first character in the string. An end-of-input condition is generated when the end of the string is reached.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Lexing", "name": "from_function", "type": "let from_function: (bytes, int) => int => lexbuf", "docs": "<p>Create a lexer buffer with the given function as its reading method. When the scanner needs more characters, it will call the given function, giving it a byte sequence <code>s</code> and a byte count <code>n</code>. The function should put <code>n</code> bytes or fewer in <code>s</code>, starting at index 0, and return the number of bytes provided. A return value of 0 means end of input.</p>\n", "kind": "value", "args": [["", "(bytes, int) => int"]]}, {"path": "Lexing", "name": "lexeme", "type": "let lexeme: lexbuf => string", "docs": "<p><code>Lexing.lexeme lexbuf</code> returns the string matched by the regular expression.</p>\n", "kind": "value", "args": [["", "lexbuf"]]}, {"path": "Lexing", "name": "lexeme_char", "type": "let lexeme_char: (lexbuf, int) => char", "docs": "<p><code>Lexing.lexeme_char lexbuf i</code> returns character number <code>i</code> in the matched string.</p>\n", "kind": "value", "args": [["", "lexbuf"], ["", "int"]]}, {"path": "Lexing", "name": "lexeme_start", "type": "let lexeme_start: lexbuf => int", "docs": "<p><code>Lexing.lexeme_start lexbuf</code> returns the offset in the input stream of the first character of the matched string. The first character of the stream has offset 0.</p>\n", "kind": "value", "args": [["", "lexbuf"]]}, {"path": "Lexing", "name": "lexeme_end", "type": "let lexeme_end: lexbuf => int", "docs": "<p><code>Lexing.lexeme_end lexbuf</code> returns the offset in the input stream of the character following the last character of the matched string. The first character of the stream has offset 0.</p>\n", "kind": "value", "args": [["", "lexbuf"]]}, {"path": "Lexing", "name": "lexeme_start_p", "type": "let lexeme_start_p: lexbuf => position", "docs": "<p>Like <code>lexeme_start</code>, but return a complete <code>position</code> instead of an offset.</p>\n", "kind": "value", "args": [["", "lexbuf"]]}, {"path": "Lexing", "name": "lexeme_end_p", "type": "let lexeme_end_p: lexbuf => position", "docs": "<p>Like <code>lexeme_end</code>, but return a complete <code>position</code> instead of an offset.</p>\n", "kind": "value", "args": [["", "lexbuf"]]}, {"path": "Lexing", "name": "new_line", "type": "let new_line: lexbuf => unit", "docs": "<p>Update the <code>lex_curr_p</code> field of the lexbuf to reflect the start of a new line. You can call this function in the semantic action of the rule that matches the end-of-line character.</p>\nSince: 3.11.0", "kind": "value", "args": [["", "lexbuf"]]}, {"path": "Lexing", "name": "flush_input", "type": "let flush_input: lexbuf => unit", "docs": "<p>Discard the contents of the buffer and reset the current position to 0. The next use of the lexbuf will trigger a refill.</p>\n", "kind": "value", "args": [["", "lexbuf"]]}, {"path": "Lexing", "name": "sub_lexeme", "type": "let sub_lexeme: (lexbuf, int, int) => string", "docs": null, "kind": "value", "args": [["", "lexbuf"], ["", "int"], ["", "int"]]}, {"path": "Lexing", "name": "sub_lexeme_opt", "type": "let sub_lexeme_opt: (lexbuf, int, int) => option(string)", "docs": null, "kind": "value", "args": [["", "lexbuf"], ["", "int"], ["", "int"]]}, {"path": "Lexing", "name": "sub_lexeme_char", "type": "let sub_lexeme_char: (lexbuf, int) => char", "docs": null, "kind": "value", "args": [["", "lexbuf"], ["", "int"]]}, {"path": "Lexing", "name": "sub_lexeme_char_opt", "type": "let sub_lexeme_char_opt: (lexbuf, int) => option(char)", "docs": null, "kind": "value", "args": [["", "lexbuf"], ["", "int"]]}, {"path": "Lexing", "name": "lex_tables", "type": "type lex_tables = {\n  lex_base: string,\n  lex_backtrk: string,\n  lex_default: string,\n  lex_trans: string,\n  lex_check: string,\n  lex_base_code: string,\n  lex_backtrk_code: string,\n  lex_default_code: string,\n  lex_trans_code: string,\n  lex_check_code: string,\n  lex_code: string\n}", "docs": null, "kind": "type"}, {"path": "Lexing", "name": "engine", "type": "let engine: (lex_tables, int, lexbuf) => int", "docs": null, "kind": "value", "args": [["", "lex_tables"], ["", "int"], ["", "lexbuf"]]}, {"path": "Lexing", "name": "new_engine", "type": "let new_engine: (lex_tables, int, lexbuf) => int", "docs": null, "kind": "value", "args": [["", "lex_tables"], ["", "int"], ["", "lexbuf"]]}, {"path": "", "name": "Lexing", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dummy_pos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>engine\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flush_input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_function\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lexeme\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lexeme_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lexeme_end\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lexeme_end_p\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lexeme_start\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lexeme_start_p\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>new_engine\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>new_line\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_lexeme\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_lexeme_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_lexeme_char_opt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_lexeme_opt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>lex_tables\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>lexbuf\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>position", "docs": null, "kind": "module"}, {"path": "Lazy", "name": "t", "type": "type t('a) = lazy_t('a)", "docs": null, "kind": "type"}, {"path": "Lazy", "name": "force", "type": "let force: t('a) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Lazy", "name": "force_val", "type": "let force_val: t('a) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Lazy", "name": "from_fun", "type": "let from_fun: unit => 'a => t('a)", "docs": null, "kind": "value", "args": [["", "unit => 'a"]]}, {"path": "Lazy", "name": "from_val", "type": "let from_val: 'a => t('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Lazy", "name": "is_val", "type": "let is_val: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Lazy", "name": "lazy_from_fun", "type": "let lazy_from_fun: unit => 'a => t('a)", "docs": null, "kind": "value", "args": [["", "unit => 'a"]]}, {"path": "Lazy", "name": "lazy_from_val", "type": "let lazy_from_val: 'a => t('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Lazy", "name": "lazy_is_val", "type": "let lazy_is_val: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "", "name": "Lazy", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>force\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>force_val\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_fun\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_val\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_val\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lazy_from_fun\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lazy_from_val\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lazy_is_val\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Int64", "name": "zero", "type": "let zero: int64", "docs": "<p>The 64-bit integer 0.</p>\n", "kind": "value"}, {"path": "Int64", "name": "one", "type": "let one: int64", "docs": "<p>The 64-bit integer 1.</p>\n", "kind": "value"}, {"path": "Int64", "name": "minus_one", "type": "let minus_one: int64", "docs": "<p>The 64-bit integer -1.</p>\n", "kind": "value"}, {"path": "Int64", "name": "neg", "type": "let neg: int64 => int64", "docs": "<p>Unary negation.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "add", "type": "let add: (int64, int64) => int64", "docs": "<p>Addition.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int64"]]}, {"path": "Int64", "name": "sub", "type": "let sub: (int64, int64) => int64", "docs": "<p>Subtraction.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int64"]]}, {"path": "Int64", "name": "mul", "type": "let mul: (int64, int64) => int64", "docs": "<p>Multiplication.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int64"]]}, {"path": "Int64", "name": "div", "type": "let div: (int64, int64) => int64", "docs": "<p>Integer division. Raise <code>Division_by_zero</code> if the second argument is zero. This division rounds the real quotient of its arguments towards zero, as specified for (/).</p>\n", "kind": "value", "args": [["", "int64"], ["", "int64"]]}, {"path": "Int64", "name": "rem", "type": "let rem: (int64, int64) => int64", "docs": "<p>Integer remainder. If <code>y</code> is not zero, the result of <code>Int64.rem x y</code> satisfies the following property: <code>x = Int64.add (Int64.mul (Int64.div x y) y) (Int64.rem x y)</code>. If <code>y = 0</code>, <code>Int64.rem x y</code> raises <code>Division_by_zero</code>.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int64"]]}, {"path": "Int64", "name": "succ", "type": "let succ: int64 => int64", "docs": "<p>Successor. <code>Int64.succ x</code> is <code>Int64.add x Int64.one</code>.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "pred", "type": "let pred: int64 => int64", "docs": "<p>Predecessor. <code>Int64.pred x</code> is <code>Int64.sub x Int64.one</code>.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "abs", "type": "let abs: int64 => int64", "docs": "<p>Return the absolute value of its argument.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "max_int", "type": "let max_int: int64", "docs": "<p>The greatest representable 64-bit integer, 2Superscript - 1.</p>\n", "kind": "value"}, {"path": "Int64", "name": "min_int", "type": "let min_int: int64", "docs": "<p>The smallest representable 64-bit integer, -2Superscript.</p>\n", "kind": "value"}, {"path": "Int64", "name": "logand", "type": "let logand: (int64, int64) => int64", "docs": "<p>Bitwise logical and.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int64"]]}, {"path": "Int64", "name": "logor", "type": "let logor: (int64, int64) => int64", "docs": "<p>Bitwise logical or.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int64"]]}, {"path": "Int64", "name": "logxor", "type": "let logxor: (int64, int64) => int64", "docs": "<p>Bitwise logical exclusive or.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int64"]]}, {"path": "Int64", "name": "lognot", "type": "let lognot: int64 => int64", "docs": "<p>Bitwise logical negation</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "shift_left", "type": "let shift_left: (int64, int) => int64", "docs": "<p><code>Int64.shift_left x y</code> shifts <code>x</code> to the left by <code>y</code> bits. The result is unspecified if <code>y &lt; 0</code> or <code>y &gt;= 64</code>.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int"]]}, {"path": "Int64", "name": "shift_right", "type": "let shift_right: (int64, int) => int64", "docs": "<p><code>Int64.shift_right x y</code> shifts <code>x</code> to the right by <code>y</code> bits. This is an arithmetic shift: the sign bit of <code>x</code> is replicated and inserted in the vacated bits. The result is unspecified if <code>y &lt; 0</code> or <code>y &gt;= 64</code>.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int"]]}, {"path": "Int64", "name": "shift_right_logical", "type": "let shift_right_logical: (int64, int) => int64", "docs": "<p><code>Int64.shift_right_logical x y</code> shifts <code>x</code> to the right by <code>y</code> bits. This is a logical shift: zeroes are inserted in the vacated bits regardless of the sign of <code>x</code>. The result is unspecified if <code>y &lt; 0</code> or <code>y &gt;= 64</code>.</p>\n", "kind": "value", "args": [["", "int64"], ["", "int"]]}, {"path": "Int64", "name": "of_int", "type": "let of_int: int => int64", "docs": "<p>Convert the given integer (type <code>int</code>) to a 64-bit integer (type <code>int64</code>).</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Int64", "name": "to_int", "type": "let to_int: int64 => int", "docs": "<p>Convert the given 64-bit integer (type <code>int64</code>) to an integer (type <code>int</code>). On 64-bit platforms, the 64-bit integer is taken modulo 2Superscript, i.e. the high-order bit is lost during the conversion. On 32-bit platforms, the 64-bit integer is taken modulo 2Superscript, i.e. the top 33 bits are lost during the conversion.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "of_float", "type": "let of_float: float => int64", "docs": "<p>Convert the given floating-point number to a 64-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [min_int, max_int].</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Int64", "name": "to_float", "type": "let to_float: int64 => float", "docs": "<p>Convert the given 64-bit integer to a floating-point number.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "of_int32", "type": "let of_int32: int32 => int64", "docs": "<p>Convert the given 32-bit integer (type <code>int32</code>) to a 64-bit integer (type <code>int64</code>).</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int64", "name": "to_int32", "type": "let to_int32: int64 => int32", "docs": "<p>Convert the given 64-bit integer (type <code>int64</code>) to a 32-bit integer (type <code>int32</code>). The 64-bit integer is taken modulo 2Superscript, i.e. the top 32 bits are lost during the conversion.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "of_nativeint", "type": "let of_nativeint: nativeint => int64", "docs": "<p>Convert the given native integer (type <code>nativeint</code>) to a 64-bit integer (type <code>int64</code>).</p>\n", "kind": "value", "args": [["", "nativeint"]]}, {"path": "Int64", "name": "to_nativeint", "type": "let to_nativeint: int64 => nativeint", "docs": "<p>Convert the given 64-bit integer (type <code>int64</code>) to a native integer. On 32-bit platforms, the 64-bit integer is taken modulo 2Superscript. On 64-bit platforms, the conversion is exact.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "of_string", "type": "let of_string: string => int64", "docs": "<p>Convert the given string to a 64-bit integer. The string is read in decimal (by default) or in hexadecimal, octal or binary if the string begins with <code>0x</code>, <code>0o</code> or <code>0b</code> respectively. Raise <code>Failure &quot;int_of_string&quot;</code> if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type <code>int64</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Int64", "name": "to_string", "type": "let to_string: int64 => string", "docs": "<p>Return the string representation of its argument, in decimal.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "bits_of_float", "type": "let bits_of_float: float => int64", "docs": "<p>Return the internal representation of the given float according to the IEEE 754 floating-point &#39;double format&#39; bit layout. Bit 63 of the result represents the sign of the float; bits 62 to 52 represent the (biased) exponent; bits 51 to 0 represent the mantissa.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Int64", "name": "float_of_bits", "type": "let float_of_bits: int64 => float", "docs": "<p>Return the floating-point number whose internal representation, according to the IEEE 754 floating-point &#39;double format&#39; bit layout, is the given <code>int64</code>.</p>\n", "kind": "value", "args": [["", "int64"]]}, {"path": "Int64", "name": "t", "type": "type t = int64", "docs": "<p>An alias for the type of 64-bit integers.</p>\n", "kind": "type"}, {"path": "Int64", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for 64-bit integers, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Int64</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Int64", "name": "format", "type": "let format: (string, int64) => string", "docs": "<p>Do not use this deprecated function. Instead, used sprintf with a <code>%L...</code> format.</p>\n", "kind": "value", "args": [["", "string"], ["", "int64"]]}, {"path": "", "name": "Int64", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bits_of_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>div\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>float_of_bits\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logand\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lognot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logxor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minus_one\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mul\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>neg\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_int32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_nativeint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>one\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pred\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift_right_logical\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>succ\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_int32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_nativeint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zero\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Int32", "name": "zero", "type": "let zero: int32", "docs": "<p>The 32-bit integer 0.</p>\n", "kind": "value"}, {"path": "Int32", "name": "one", "type": "let one: int32", "docs": "<p>The 32-bit integer 1.</p>\n", "kind": "value"}, {"path": "Int32", "name": "minus_one", "type": "let minus_one: int32", "docs": "<p>The 32-bit integer -1.</p>\n", "kind": "value"}, {"path": "Int32", "name": "neg", "type": "let neg: int32 => int32", "docs": "<p>Unary negation.</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int32", "name": "add", "type": "let add: (int32, int32) => int32", "docs": "<p>Addition.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int32"]]}, {"path": "Int32", "name": "sub", "type": "let sub: (int32, int32) => int32", "docs": "<p>Subtraction.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int32"]]}, {"path": "Int32", "name": "mul", "type": "let mul: (int32, int32) => int32", "docs": "<p>Multiplication.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int32"]]}, {"path": "Int32", "name": "div", "type": "let div: (int32, int32) => int32", "docs": "<p>Integer division. Raise <code>Division_by_zero</code> if the second argument is zero. This division rounds the real quotient of its arguments towards zero, as specified for (/).</p>\n", "kind": "value", "args": [["", "int32"], ["", "int32"]]}, {"path": "Int32", "name": "rem", "type": "let rem: (int32, int32) => int32", "docs": "<p>Integer remainder. If <code>y</code> is not zero, the result of <code>Int32.rem x y</code> satisfies the following property: <code>x = Int32.add (Int32.mul (Int32.div x y) y) (Int32.rem x y)</code>. If <code>y = 0</code>, <code>Int32.rem x y</code> raises <code>Division_by_zero</code>.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int32"]]}, {"path": "Int32", "name": "succ", "type": "let succ: int32 => int32", "docs": "<p>Successor. <code>Int32.succ x</code> is <code>Int32.add x Int32.one</code>.</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int32", "name": "pred", "type": "let pred: int32 => int32", "docs": "<p>Predecessor. <code>Int32.pred x</code> is <code>Int32.sub x Int32.one</code>.</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int32", "name": "abs", "type": "let abs: int32 => int32", "docs": "<p>Return the absolute value of its argument.</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int32", "name": "max_int", "type": "let max_int: int32", "docs": "<p>The greatest representable 32-bit integer, 2Superscript - 1.</p>\n", "kind": "value"}, {"path": "Int32", "name": "min_int", "type": "let min_int: int32", "docs": "<p>The smallest representable 32-bit integer, -2Superscript.</p>\n", "kind": "value"}, {"path": "Int32", "name": "logand", "type": "let logand: (int32, int32) => int32", "docs": "<p>Bitwise logical and.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int32"]]}, {"path": "Int32", "name": "logor", "type": "let logor: (int32, int32) => int32", "docs": "<p>Bitwise logical or.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int32"]]}, {"path": "Int32", "name": "logxor", "type": "let logxor: (int32, int32) => int32", "docs": "<p>Bitwise logical exclusive or.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int32"]]}, {"path": "Int32", "name": "lognot", "type": "let lognot: int32 => int32", "docs": "<p>Bitwise logical negation</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int32", "name": "shift_left", "type": "let shift_left: (int32, int) => int32", "docs": "<p><code>Int32.shift_left x y</code> shifts <code>x</code> to the left by <code>y</code> bits. The result is unspecified if <code>y &lt; 0</code> or <code>y &gt;= 32</code>.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int"]]}, {"path": "Int32", "name": "shift_right", "type": "let shift_right: (int32, int) => int32", "docs": "<p><code>Int32.shift_right x y</code> shifts <code>x</code> to the right by <code>y</code> bits. This is an arithmetic shift: the sign bit of <code>x</code> is replicated and inserted in the vacated bits. The result is unspecified if <code>y &lt; 0</code> or <code>y &gt;= 32</code>.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int"]]}, {"path": "Int32", "name": "shift_right_logical", "type": "let shift_right_logical: (int32, int) => int32", "docs": "<p><code>Int32.shift_right_logical x y</code> shifts <code>x</code> to the right by <code>y</code> bits. This is a logical shift: zeroes are inserted in the vacated bits regardless of the sign of <code>x</code>. The result is unspecified if <code>y &lt; 0</code> or <code>y &gt;= 32</code>.</p>\n", "kind": "value", "args": [["", "int32"], ["", "int"]]}, {"path": "Int32", "name": "of_int", "type": "let of_int: int => int32", "docs": "<p>Convert the given integer (type <code>int</code>) to a 32-bit integer (type <code>int32</code>).</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Int32", "name": "to_int", "type": "let to_int: int32 => int", "docs": "<p>Convert the given 32-bit integer (type <code>int32</code>) to an integer (type <code>int</code>). On 32-bit platforms, the 32-bit integer is taken modulo 2Superscript, i.e. the high-order bit is lost during the conversion. On 64-bit platforms, the conversion is exact.</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int32", "name": "of_float", "type": "let of_float: float => int32", "docs": "<p>Convert the given floating-point number to a 32-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [min_int, max_int].</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Int32", "name": "to_float", "type": "let to_float: int32 => float", "docs": "<p>Convert the given 32-bit integer to a floating-point number.</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int32", "name": "of_string", "type": "let of_string: string => int32", "docs": "<p>Convert the given string to a 32-bit integer. The string is read in decimal (by default) or in hexadecimal, octal or binary if the string begins with <code>0x</code>, <code>0o</code> or <code>0b</code> respectively. Raise <code>Failure &quot;int_of_string&quot;</code> if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type <code>int32</code>.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Int32", "name": "to_string", "type": "let to_string: int32 => string", "docs": "<p>Return the string representation of its argument, in signed decimal.</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int32", "name": "bits_of_float", "type": "let bits_of_float: float => int32", "docs": "<p>Return the internal representation of the given float according to the IEEE 754 floating-point &#39;single format&#39; bit layout. Bit 31 of the result represents the sign of the float; bits 30 to 23 represent the (biased) exponent; bits 22 to 0 represent the mantissa.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Int32", "name": "float_of_bits", "type": "let float_of_bits: int32 => float", "docs": "<p>Return the floating-point number whose internal representation, according to the IEEE 754 floating-point &#39;single format&#39; bit layout, is the given <code>int32</code>.</p>\n", "kind": "value", "args": [["", "int32"]]}, {"path": "Int32", "name": "t", "type": "type t = int32", "docs": "<p>An alias for the type of 32-bit integers.</p>\n", "kind": "type"}, {"path": "Int32", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for 32-bit integers, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Int32</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Int32", "name": "format", "type": "let format: (string, int32) => string", "docs": "<p>Do not use this deprecated function. Instead, used sprintf with a <code>%l...</code> format.</p>\n", "kind": "value", "args": [["", "string"], ["", "int32"]]}, {"path": "", "name": "Int32", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bits_of_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>div\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>float_of_bits\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logand\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lognot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logxor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minus_one\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mul\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>neg\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>one\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pred\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift_right_logical\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>succ\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zero\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Hashtbl", "name": "t", "type": "type t('a, 'b)", "docs": "<p>The type of hash tables from type <code>&#39;a</code> to type <code>&#39;b</code>.</p>\n", "kind": "type"}, {"path": "Hashtbl", "name": "create", "type": "let create: (~?random: option(bool), int) => t('a, 'b)", "docs": "<p><code>Hashtbl.create n</code> creates a new, empty hash table, with initial size <code>n</code>. For best results, <code>n</code> should be on the order of the expected number of elements that will be in the table. The table grows as needed, so <code>n</code> is just an initial guess.</p>\n<p>The optional <code>random</code> parameter (a boolean) controls whether the internal organization of the hash table is randomized at each execution of <code>Hashtbl.create</code> or deterministic over all executions.</p>\n<p>A hash table that is created with <code>~random:false</code> uses a fixed hash function (hash) to distribute keys among buckets. As a consequence, collisions between keys happen deterministically. In Web-facing applications or other security-sensitive applications, the deterministic collision patterns can be exploited by a malicious user to create a denial-of-service attack: the attacker sends input crafted to create many collisions in the table, slowing the application down.</p>\n<p>A hash table that is created with <code>~random:true</code> uses the seeded hash function seeded_hash with a seed that is randomly chosen at hash table creation time. In effect, the hash function used is randomly selected among <code>2^{30}</code> different hash functions. All these hash functions have different collision patterns, rendering ineffective the denial-of-service attack described above. However, because of randomization, enumerating all elements of the hash table using fold or iter is no longer deterministic: elements are enumerated in different orders at different runs of the program.</p>\n<p>If no <code>~random</code> parameter is given, hash tables are created in non-random mode by default. This default can be changed either programmatically by calling randomize or by setting the <code>R</code> flag in the <code>OCAMLRUNPARAM</code> environment variable.</p>\nUnhandled tag", "kind": "value", "args": [["random", "bool (optional)"], ["", "int"]]}, {"path": "Hashtbl", "name": "clear", "type": "let clear: t('a, 'b) => unit", "docs": "<p>Empty a hash table. Use <code>reset</code> instead of <code>clear</code> to shrink the size of the bucket table to its initial size.</p>\n", "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Hashtbl", "name": "reset", "type": "let reset: t('a, 'b) => unit", "docs": "<p>Empty a hash table and shrink the size of the bucket table to its initial size.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Hashtbl", "name": "copy", "type": "let copy: t('a, 'b) => t('a, 'b)", "docs": "<p>Return a copy of the given hashtable.</p>\n", "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Hashtbl", "name": "add", "type": "let add: (t('a, 'b), 'a, 'b) => unit", "docs": "<p><code>Hashtbl.add tbl x y</code> adds a binding of <code>x</code> to <code>y</code> in table <code>tbl</code>. Previous bindings for <code>x</code> are not removed, but simply hidden. That is, after performing remove<code> tbl x</code>, the previous binding for <code>x</code>, if any, is restored. (Same behavior as with association lists.)</p>\n", "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"]]}, {"path": "Hashtbl", "name": "find", "type": "let find: (t('a, 'b), 'a) => 'b", "docs": "<p><code>Hashtbl.find tbl x</code> returns the current binding of <code>x</code> in <code>tbl</code>, or raises <code>Not_found</code> if no such binding exists.</p>\n", "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"]]}, {"path": "Hashtbl", "name": "find_all", "type": "let find_all: (t('a, 'b), 'a) => list('b)", "docs": "<p><code>Hashtbl.find_all tbl x</code> returns the list of all data associated with <code>x</code> in <code>tbl</code>. The current binding is returned first, then the previous bindings, in reverse order of introduction in the table.</p>\n", "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"]]}, {"path": "Hashtbl", "name": "mem", "type": "let mem: (t('a, 'b), 'a) => bool", "docs": "<p><code>Hashtbl.mem tbl x</code> checks if <code>x</code> is bound in <code>tbl</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"]]}, {"path": "Hashtbl", "name": "remove", "type": "let remove: (t('a, 'b), 'a) => unit", "docs": "<p><code>Hashtbl.remove tbl x</code> removes the current binding of <code>x</code> in <code>tbl</code>, restoring the previous binding if it exists. It does nothing if <code>x</code> is not bound in <code>tbl</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"]]}, {"path": "Hashtbl", "name": "replace", "type": "let replace: (t('a, 'b), 'a, 'b) => unit", "docs": "<p><code>Hashtbl.replace tbl x y</code> replaces the current binding of <code>x</code> in <code>tbl</code> by a binding of <code>x</code> to <code>y</code>. If <code>x</code> is unbound in <code>tbl</code>, a binding of <code>x</code> to <code>y</code> is added to <code>tbl</code>. This is functionally equivalent to remove<code> tbl x</code> followed by add<code> tbl x y</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b)"], ["", "'a"], ["", "'b"]]}, {"path": "Hashtbl", "name": "iter", "type": "let iter: (('a, 'b) => unit, t('a, 'b)) => unit", "docs": "<p><code>Hashtbl.iter f tbl</code> applies <code>f</code> to all bindings in table <code>tbl</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to <code>f</code>.</p>\n<p>The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p>\n<p>If the hash table was created in non-randomized mode, the order in which the bindings are enumerated is reproducible between successive runs of the program, and even between minor versions of OCaml. For randomized hash tables, the order of enumeration is entirely random.</p>\n", "kind": "value", "args": [["", "('a, 'b) => unit"], ["", "t('a, 'b)"]]}, {"path": "Hashtbl", "name": "fold", "type": "let fold: (('a, 'b, 'c) => 'c, t('a, 'b), 'c) => 'c", "docs": "<p><code>Hashtbl.fold f tbl init</code> computes <code>(f kN dN ... (f k1 d1 init)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>tbl</code>, and <code>d1 ... dN</code> are the associated values. Each binding is presented exactly once to <code>f</code>.</p>\n<p>The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p>\n<p>If the hash table was created in non-randomized mode, the order in which the bindings are enumerated is reproducible between successive runs of the program, and even between minor versions of OCaml. For randomized hash tables, the order of enumeration is entirely random.</p>\n", "kind": "value", "args": [["", "('a, 'b, 'c) => 'c"], ["", "t('a, 'b)"], ["", "'c"]]}, {"path": "Hashtbl", "name": "length", "type": "let length: t('a, 'b) => int", "docs": "<p><code>Hashtbl.length tbl</code> returns the number of bindings in <code>tbl</code>. It takes constant time. Multiple bindings are counted once each, so <code>Hashtbl.length</code> gives the number of times <code>Hashtbl.iter</code> calls its first argument.</p>\n", "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Hashtbl", "name": "randomize", "type": "let randomize: unit => unit", "docs": "<p>After a call to <code>Hashtbl.randomize()</code>, hash tables are created in randomized mode by default: create returns randomized hash tables, unless the <code>~random:false</code> optional parameter is given. The same effect can be achieved by setting the <code>R</code> parameter in the <code>OCAMLRUNPARAM</code> environment variable.</p>\n<p>It is recommended that applications or Web frameworks that need to protect themselves against the denial-of-service attack described in create call <code>Hashtbl.randomize()</code> at initialization time.</p>\n<p>Note that once <code>Hashtbl.randomize()</code> was called, there is no way to revert to the non-randomized default behavior of create. This is intentional. Non-randomized hash tables can still be created using <code>Hashtbl.create ~random:false</code>.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "unit"]]}, {"path": "Hashtbl", "name": "statistics", "type": "type statistics = {\n  num_bindings: int,\n  num_buckets: int,\n  max_bucket_length: int,\n  bucket_histogram: array(int)\n}", "docs": null, "kind": "type"}, {"path": "Hashtbl", "name": "stats", "type": "let stats: t('a, 'b) => statistics", "docs": "<p><code>Hashtbl.stats tbl</code> returns statistics about the table <code>tbl</code>: number of buckets, size of the biggest bucket, distribution of buckets by size.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "t('a, 'b)"]]}, {"path": "Hashtbl", "name": "Make", "type": "", "docs": "<p>Functor building an implementation of the hashtable structure. The functor <code>Hashtbl.Make</code> returns a structure containing a type <code>key</code> of keys and a type <code>&#39;a t</code> of hash tables associating data of type <code>&#39;a</code> to keys of type <code>key</code>. The operations perform similarly to those of the generic interface, but use the hashing and equality functions specified in the functor argument <code>H</code> instead of generic equality and hashing. Since the hash function is not seeded, the <code>create</code> operation of the result structure always returns non-randomized hash tables.</p>\n", "kind": "module"}, {"path": "Hashtbl", "name": "MakeSeeded", "type": "", "docs": "<p>Functor building an implementation of the hashtable structure. The functor <code>Hashtbl.MakeSeeded</code> returns a structure containing a type <code>key</code> of keys and a type <code>&#39;a t</code> of hash tables associating data of type <code>&#39;a</code> to keys of type <code>key</code>. The operations perform similarly to those of the generic interface, but use the seeded hashing and equality functions specified in the functor argument <code>H</code> instead of generic equality and hashing. The <code>create</code> operation of the result structure supports the <code>~random</code> optional parameter and returns randomized hash tables if <code>~random:true</code> is passed or if randomization is globally on (see randomize).</p>\nSince: 4.00.0", "kind": "module"}, {"path": "Hashtbl", "name": "hash", "type": "let hash: 'a => int", "docs": "<p><code>Hashtbl.hash x</code> associates a nonnegative integer to any value of any type. It is guaranteed that if <code>x = y</code> or <code>Pervasives.compare x y = 0</code>, then <code>hash x = hash y</code>. Moreover, <code>hash</code> always terminates, even on cyclic structures.</p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Hashtbl", "name": "seeded_hash", "type": "let seeded_hash: (int, 'a) => int", "docs": "<p>A variant of hash that is further parameterized by an integer seed.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Hashtbl", "name": "hash_param", "type": "let hash_param: (int, int, 'a) => int", "docs": "<p><code>Hashtbl.hash_param meaningful total x</code> computes a hash value for <code>x</code>, with the same properties as for <code>hash</code>. The two extra integer parameters <code>meaningful</code> and <code>total</code> give more precise control over hashing. Hashing performs a breadth-first, left-to-right traversal of the structure <code>x</code>, stopping after <code>meaningful</code> meaningful nodes were encountered, or <code>total</code> nodes (meaningful or not) were encountered. If <code>total</code> as specified by the user exceeds a certain value, currently 256, then it is capped to that value. Meaningful nodes are: integers; floating-point numbers; strings; characters; booleans; and constant constructors. Larger values of <code>meaningful</code> and <code>total</code> means that more nodes are taken into account to compute the final hash value, and therefore collisions are less likely to happen. However, hashing takes longer. The parameters <code>meaningful</code> and <code>total</code> govern the tradeoff between accuracy and speed. As default choices, hash and seeded_hash take <code>meaningful = 10</code> and <code>total = 100</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "'a"]]}, {"path": "Hashtbl", "name": "seeded_hash_param", "type": "let seeded_hash_param: (int, int, int, 'a) => int", "docs": "<p>A variant of hash_param that is further parameterized by an integer seed. Usage: <code>Hashtbl.seeded_hash_param meaningful total seed x</code>.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "int"], ["", "int"], ["", "int"], ["", "'a"]]}, {"path": "", "name": "Hashtbl", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find_all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hash\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hash_param\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mem\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>randomize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>remove\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>replace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>seeded_hash\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>seeded_hash_param\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stats\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>statistics\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Make\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MakeSeeded", "docs": null, "kind": "module"}, {"path": "Genlex", "name": "token", "type": "type token = | Kwd(string) | Ident(string) | Int(int) | Float(float) | String(string) | Char(char)\n", "docs": "<p>The type of tokens. The lexical classes are: <code>Int</code> and <code>Float</code> for integer and floating-point numbers; <code>String</code> for string literals, enclosed in double quotes; <code>Char</code> for character literals, enclosed in single quotes; <code>Ident</code> for identifiers (either sequences of letters, digits, underscores and quotes, or sequences of &#39;operator characters&#39; such as <code>+</code>, <code>*</code>, etc); and <code>Kwd</code> for keywords (either identifiers or single &#39;special characters&#39; such as <code>(</code>, <code>}</code>, etc).</p>\n", "kind": "type"}, {"path": "Genlex", "name": "make_lexer", "type": "let make_lexer: (list(string), Stream.t(char)) => Stream.t(token)", "docs": "<p>Construct the lexer function. The first argument is the list of keywords. An identifier <code>s</code> is returned as <code>Kwd s</code> if <code>s</code> belongs to this list, and as <code>Ident s</code> otherwise. A special character <code>s</code> is returned as <code>Kwd s</code> if <code>s</code> belongs to this list, and cause a lexical error (exception <code>Stream.Error</code> with the offending lexeme as its parameter) otherwise. Blanks and newlines are skipped. Comments delimited by <code>(*</code> and <code>*)</code> are skipped as well, and can be nested. A <code>Stream.Failure</code> exception is raised if end of stream is unexpectedly reached.</p>\n", "kind": "value", "args": [["", "list(string)"], ["", "Stream.t(char)"]]}, {"path": "", "name": "Genlex", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_lexer\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>token", "docs": null, "kind": "module"}, {"path": "Gc", "name": "stat", "type": "type stat = {\n  minor_words: float,\n  promoted_words: float,\n  major_words: float,\n  minor_collections: int,\n  major_collections: int,\n  heap_words: int,\n  heap_chunks: int,\n  live_words: int,\n  live_blocks: int,\n  free_words: int,\n  free_blocks: int,\n  largest_free: int,\n  fragments: int,\n  compactions: int,\n  top_heap_words: int,\n  stack_size: int\n}", "docs": "<p>The memory management counters are returned in a <code>stat</code> record.</p>\n<p>The total amount of memory allocated by the program since it was started is (in words) <code>minor_words + major_words - promoted_words</code>. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.</p>\n", "kind": "type"}, {"path": "Gc", "name": "control", "type": "type control = {\n  mut minor_heap_size: int,\n  mut major_heap_increment: int,\n  mut space_overhead: int,\n  mut verbose: int,\n  mut max_overhead: int,\n  mut stack_limit: int,\n  mut allocation_policy: int\n}", "docs": "<p>The GC parameters are given as a <code>control</code> record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of <code>ocamlrun</code>.</p>\n", "kind": "type"}, {"path": "Gc", "name": "stat", "type": "let stat: unit => stat", "docs": "<p>Return the current values of the memory management counters in a <code>stat</code> record. This function examines every heap block to get the statistics.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "quick_stat", "type": "let quick_stat: unit => stat", "docs": "<p>Same as <code>stat</code> except that <code>live_words</code>, <code>live_blocks</code>, <code>free_words</code>, <code>free_blocks</code>, <code>largest_free</code>, and <code>fragments</code> are set to 0. This function is much faster than <code>stat</code> because it does not need to go through the heap.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "counters", "type": "let counters: unit => (float, float, float)", "docs": "<p>Return <code>(minor_words, promoted_words, major_words)</code>. This function is as fast as <code>quick_stat</code>.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "get", "type": "let get: unit => control", "docs": "<p>Return the current values of the GC parameters in a <code>control</code> record.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "set", "type": "let set: control => unit", "docs": "<p><code>set r</code> changes the GC parameters according to the <code>control</code> record <code>r</code>. The normal usage is: <code>Gc.set { (Gc.get()) with Gc.verbose = 0x00d }</code></p>\n", "kind": "value", "args": [["", "control"]]}, {"path": "Gc", "name": "minor", "type": "let minor: unit => unit", "docs": "<p>Trigger a minor collection.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "major_slice", "type": "let major_slice: int => int", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Gc", "name": "major", "type": "let major: unit => unit", "docs": "<p>Do a minor collection and finish the current major collection cycle.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "full_major", "type": "let full_major: unit => unit", "docs": "<p>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "compact", "type": "let compact: unit => unit", "docs": "<p>Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "print_stat", "type": "let print_stat: Pervasives.out_channel => unit", "docs": "<p>Print the current values of the memory management counters (in human-readable form) into the channel argument.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"]]}, {"path": "Gc", "name": "allocated_bytes", "type": "let allocated_bytes: unit => float", "docs": "<p>Return the total number of bytes allocated since the program was started. It is returned as a <code>float</code> to avoid overflow problems with <code>int</code> on 32-bit machines.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "finalise", "type": "let finalise: ('a => unit, 'a) => unit", "docs": "<p><code>finalise f v</code> registers <code>f</code> as a finalisation function for <code>v</code>. <code>v</code> must be heap-allocated. <code>f</code> will be called with <code>v</code> as argument at some point between the first time <code>v</code> becomes unreachable and the time <code>v</code> is collected by the GC. Several functions can be registered for the same value, or even several instances of the same function. Each instance will be called once (or never, if the program terminates before <code>v</code> becomes unreachable).</p>\n<p>The GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to <code>finalise</code>. If <code>finalise</code> is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.</p>\n<p>In the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.</p>\n<p>Anything reachable from the closure of finalisation functions is considered reachable, so the following code will not work as expected:</p>\n<ul><li><p><code> let v = ... in Gc.finalise (fun x -&gt; ... v ...) v </code></p>\n</li></ul><p>Instead you should make sure that <code>v</code> is not in the closure of the finalisation function by writing:</p>\n<ul><li><p><code> let f = fun x -&gt; ... ;; let v = ... in Gc.finalise f v </code></p>\n</li></ul><p>The <code>f</code> function can use all features of OCaml, including assignments that make the value reachable again. It can also loop forever (in this case, the other finalisation functions will not be called during the execution of f, unless it calls <code>finalise_release</code>). It can call <code>finalise</code> on <code>v</code> or other values to register other functions or even itself. It can raise an exception; in this case the exception will interrupt whatever the program was doing when the function was called.</p>\n<p><code>finalise</code> will raise <code>Invalid_argument</code> if <code>v</code> is not heap-allocated. Some examples of values that are not heap-allocated are integers, constant constructors, booleans, the empty array, the empty list, the unit value. The exact list of what is heap-allocated or not is implementation-dependent. Some constant values can be heap-allocated but never deallocated during the lifetime of the program, for example a list of integer constants; this is also implementation-dependent. You should also be aware that compiler optimisations may duplicate some immutable values, for example floating-point numbers when stored into arrays, so they can be finalised and collected while another copy is still in use by the program.</p>\n<p>The results of calling make, make, create, make, and ref are guaranteed to be heap-allocated and non-constant except when the length argument is <code>0</code>.</p>\n", "kind": "value", "args": [["", "'a => unit"], ["", "'a"]]}, {"path": "Gc", "name": "finalise_release", "type": "let finalise_release: unit => unit", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "Gc", "name": "alarm", "type": "type alarm", "docs": "<p>An alarm is a piece of data that calls a user function at the end of each major GC cycle. The following functions are provided to create and delete alarms.</p>\n", "kind": "type"}, {"path": "Gc", "name": "create_alarm", "type": "let create_alarm: unit => unit => alarm", "docs": "<p><code>create_alarm f</code> will arrange for <code>f</code> to be called at the end of each major GC cycle, starting with the current cycle or the next one. A value of type <code>alarm</code> is returned that you can use to call <code>delete_alarm</code>.</p>\n", "kind": "value", "args": [["", "unit => unit"]]}, {"path": "Gc", "name": "delete_alarm", "type": "let delete_alarm: alarm => unit", "docs": "<p><code>delete_alarm a</code> will stop the calls to the function associated to <code>a</code>. Calling <code>delete_alarm a</code> again has no effect.</p>\n", "kind": "value", "args": [["", "alarm"]]}, {"path": "", "name": "Gc", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>allocated_bytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compact\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>counters\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_alarm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>delete_alarm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>finalise\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>finalise_release\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>full_major\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>major\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>major_slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_stat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>quick_stat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stat\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>alarm\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>control\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>stat", "docs": null, "kind": "module"}, {"path": "Format", "name": "open_box", "type": "let open_box: int => unit", "docs": "<p><code>open_box d</code> opens a new pretty-printing box with offset <code>d</code>. This box is the general purpose pretty-printing box. Material in this box is displayed &#39;horizontal or vertical&#39;: break hints inside the box may lead to a new line, if there is no more room on the line to print the remainder of the box, or if a new line may lead to a new indentation (demonstrating the indentation of the box). When a new line is printed in the box, <code>d</code> is added to the current indentation.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Format", "name": "close_box", "type": "let close_box: unit => unit", "docs": "<p>Closes the most recently opened pretty-printing box.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "print_string", "type": "let print_string: string => unit", "docs": "<p><code>print_string str</code> prints <code>str</code> in the current box.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Format", "name": "print_as", "type": "let print_as: (int, string) => unit", "docs": "<p><code>print_as len str</code> prints <code>str</code> in the current box. The pretty-printer formats <code>str</code> as if it were of length <code>len</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "string"]]}, {"path": "Format", "name": "print_int", "type": "let print_int: int => unit", "docs": "<p>Prints an integer in the current box.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Format", "name": "print_float", "type": "let print_float: float => unit", "docs": "<p>Prints a floating point number in the current box.</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Format", "name": "print_char", "type": "let print_char: char => unit", "docs": "<p>Prints a character in the current box.</p>\n", "kind": "value", "args": [["", "char"]]}, {"path": "Format", "name": "print_bool", "type": "let print_bool: bool => unit", "docs": "<p>Prints a boolean in the current box.</p>\n", "kind": "value", "args": [["", "bool"]]}, {"path": "Format", "name": "print_space", "type": "let print_space: unit => unit", "docs": "<p><code>print_space ()</code> is used to separate items (typically to print a space between two words). It indicates that the line may be split at this point. It either prints one space or splits the line. It is equivalent to <code>print_break 1 0</code>.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "print_cut", "type": "let print_cut: unit => unit", "docs": "<p><code>print_cut ()</code> is used to mark a good break position. It indicates that the line may be split at this point. It either prints nothing or splits the line. This allows line splitting at the current point, without printing spaces or adding indentation. It is equivalent to <code>print_break 0 0</code>.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "print_break", "type": "let print_break: (int, int) => unit", "docs": "<p>Inserts a break hint in a pretty-printing box. <code>print_break nspaces offset</code> indicates that the line may be split (a newline character is printed) at this point, if the contents of the current box does not fit on the current line. If the line is split at that point, <code>offset</code> is added to the current indentation. If the line is not split, <code>nspaces</code> spaces are printed.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Format", "name": "print_flush", "type": "let print_flush: unit => unit", "docs": "<p>Flushes the pretty printer: all opened boxes are closed, and all pending text is displayed.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "print_newline", "type": "let print_newline: unit => unit", "docs": "<p>Equivalent to <code>print_flush</code> followed by a new line.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "force_newline", "type": "let force_newline: unit => unit", "docs": "<p>Forces a newline in the current box. Not the normal way of pretty-printing, you should prefer break hints.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "print_if_newline", "type": "let print_if_newline: unit => unit", "docs": "<p>Executes the next formatting command if the preceding line has just been split. Otherwise, ignore the next formatting command.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "set_margin", "type": "let set_margin: int => unit", "docs": "<p><code>set_margin d</code> sets the value of the right margin to <code>d</code> (in characters): this value is used to detect line overflows that leads to split lines. Nothing happens if <code>d</code> is smaller than 2. If <code>d</code> is too large, the right margin is set to the maximum admissible value (which is greater than <code>10^9</code>).</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Format", "name": "get_margin", "type": "let get_margin: unit => int", "docs": "<p>Returns the position of the right margin.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "set_max_indent", "type": "let set_max_indent: int => unit", "docs": "<p><code>set_max_indent d</code> sets the value of the maximum indentation limit to <code>d</code> (in characters): once this limit is reached, boxes are rejected to the left, if they do not fit on the current line. Nothing happens if <code>d</code> is smaller than 2. If <code>d</code> is too large, the limit is set to the maximum admissible value (which is greater than <code>10^9</code>).</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Format", "name": "get_max_indent", "type": "let get_max_indent: unit => int", "docs": "<p>Return the value of the maximum indentation limit (in characters).</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "set_max_boxes", "type": "let set_max_boxes: int => unit", "docs": "<p><code>set_max_boxes max</code> sets the maximum number of boxes simultaneously opened. Material inside boxes nested deeper is printed as an ellipsis (more precisely as the text returned by <code>get_ellipsis_text ()</code>). Nothing happens if <code>max</code> is smaller than 2.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Format", "name": "get_max_boxes", "type": "let get_max_boxes: unit => int", "docs": "<p>Returns the maximum number of boxes allowed before ellipsis.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "over_max_boxes", "type": "let over_max_boxes: unit => bool", "docs": "<p>Tests if the maximum number of boxes allowed have already been opened.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "open_hbox", "type": "let open_hbox: unit => unit", "docs": "<p><code>open_hbox ()</code> opens a new pretty-printing box. This box is &#39;horizontal&#39;: the line is not split in this box (new lines may still occur inside boxes nested deeper).</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "open_vbox", "type": "let open_vbox: int => unit", "docs": "<p><code>open_vbox d</code> opens a new pretty-printing box with offset <code>d</code>. This box is &#39;vertical&#39;: every break hint inside this box leads to a new line. When a new line is printed in the box, <code>d</code> is added to the current indentation.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Format", "name": "open_hvbox", "type": "let open_hvbox: int => unit", "docs": "<p><code>open_hvbox d</code> opens a new pretty-printing box with offset <code>d</code>. This box is &#39;horizontal-vertical&#39;: it behaves as an &#39;horizontal&#39; box if it fits on a single line, otherwise it behaves as a &#39;vertical&#39; box. When a new line is printed in the box, <code>d</code> is added to the current indentation.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Format", "name": "open_hovbox", "type": "let open_hovbox: int => unit", "docs": "<p><code>open_hovbox d</code> opens a new pretty-printing box with offset <code>d</code>. This box is &#39;horizontal or vertical&#39;: break hints inside this box may lead to a new line, if there is no more room on the line to print the remainder of the box. When a new line is printed in the box, <code>d</code> is added to the current indentation.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Format", "name": "open_tbox", "type": "let open_tbox: unit => unit", "docs": "<p>Opens a tabulation box.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "close_tbox", "type": "let close_tbox: unit => unit", "docs": "<p>Closes the most recently opened tabulation box.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "print_tbreak", "type": "let print_tbreak: (int, int) => unit", "docs": "<p>Break hint in a tabulation box. <code>print_tbreak spaces offset</code> moves the insertion point to the next tabulation (<code>spaces</code> being added to this position). Nothing occurs if insertion point is already on a tabulation mark. If there is no next tabulation on the line, then a newline is printed and the insertion point moves to the first tabulation of the box. If a new line is printed, <code>offset</code> is added to the current indentation.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Format", "name": "set_tab", "type": "let set_tab: unit => unit", "docs": "<p>Sets a tabulation mark at the current insertion point.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "print_tab", "type": "let print_tab: unit => unit", "docs": "<p><code>print_tab ()</code> is equivalent to <code>print_tbreak 0 0</code>.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "set_ellipsis_text", "type": "let set_ellipsis_text: string => unit", "docs": "<p>Set the text of the ellipsis printed when too many boxes are opened (a single dot, <code>.</code>, by default).</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Format", "name": "get_ellipsis_text", "type": "let get_ellipsis_text: unit => string", "docs": "<p>Return the text of the ellipsis.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "tag", "type": "type tag = string", "docs": null, "kind": "type"}, {"path": "Format", "name": "open_tag", "type": "let open_tag: tag => unit", "docs": "<p><code>open_tag t</code> opens the tag named <code>t</code>; the <code>print_open_tag</code> function of the formatter is called with <code>t</code> as argument; the tag marker <code>mark_open_tag t</code> will be flushed into the output device of the formatter.</p>\n", "kind": "value", "args": [["", "tag"]]}, {"path": "Format", "name": "close_tag", "type": "let close_tag: unit => unit", "docs": "<p><code>close_tag ()</code> closes the most recently opened tag <code>t</code>. In addition, the <code>print_close_tag</code> function of the formatter is called with <code>t</code> as argument. The marker <code>mark_close_tag t</code> will be flushed into the output device of the formatter.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "set_tags", "type": "let set_tags: bool => unit", "docs": "<p><code>set_tags b</code> turns on or off the treatment of tags (default is off).</p>\n", "kind": "value", "args": [["", "bool"]]}, {"path": "Format", "name": "set_print_tags", "type": "let set_print_tags: bool => unit", "docs": "<p><code>set_print_tags b</code> turns on or off the printing of tags.</p>\n", "kind": "value", "args": [["", "bool"]]}, {"path": "Format", "name": "set_mark_tags", "type": "let set_mark_tags: bool => unit", "docs": "<p><code>set_mark_tags b</code> turns on or off the output of tag markers.</p>\n", "kind": "value", "args": [["", "bool"]]}, {"path": "Format", "name": "get_print_tags", "type": "let get_print_tags: unit => bool", "docs": "<p>Return the current status of tags printing.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "get_mark_tags", "type": "let get_mark_tags: unit => bool", "docs": "<p>Return the current status of tags marking.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "set_formatter_out_channel", "type": "let set_formatter_out_channel: Pervasives.out_channel => unit", "docs": "<p>Redirect the pretty-printer output to the given channel. (All the output functions of the standard formatter are set to the default output functions printing to the given channel.)</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"]]}, {"path": "Format", "name": "set_formatter_output_functions", "type": "let set_formatter_output_functions: ((string, int, int) => unit, unit => unit) => unit", "docs": "<p><code>set_formatter_output_functions out flush</code> redirects the pretty-printer output functions to the functions <code>out</code> and <code>flush</code>.</p>\n<p>The <code>out</code> function performs all the pretty-printer string output. It is called with a string <code>s</code>, a start position <code>p</code>, and a number of characters <code>n</code>; it is supposed to output characters <code>p</code> to <code>p + n - 1</code> of <code>s</code>.</p>\n<p>The <code>flush</code> function is called whenever the pretty-printer is flushed (via conversion <code>%!</code>, or pretty-printing indications <code>@?</code> or <code>@.</code>, or using low level functions <code>print_flush</code> or <code>print_newline</code>).</p>\n", "kind": "value", "args": [["", "(string, int, int) => unit"], ["", "unit => unit"]]}, {"path": "Format", "name": "get_formatter_output_functions", "type": "let get_formatter_output_functions: unit => ((string, int, int) => unit, unit => unit)", "docs": "<p>Return the current output functions of the pretty-printer.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "formatter_out_functions", "type": "type formatter_out_functions = {\n  out_string: (string, int, int) => unit,\n  out_flush: unit => unit,\n  out_newline: unit => unit,\n  out_spaces: int => unit\n}", "docs": null, "kind": "type"}, {"path": "Format", "name": "set_formatter_out_functions", "type": "let set_formatter_out_functions: formatter_out_functions => unit", "docs": "<p><code>set_formatter_out_functions f</code> Redirect the pretty-printer output to the functions <code>f.out_string</code> and <code>f.out_flush</code> as described in <code>set_formatter_output_functions</code>. In addition, the pretty-printer function that outputs a newline is set to the function <code>f.out_newline</code> and the function that outputs indentation spaces is set to the function <code>f.out_spaces</code>.</p>\n<p>This way, you can change the meaning of indentation (which can be something else than just printing space characters) and the meaning of new lines opening (which can be connected to any other action needed by the application at hand). The two functions <code>f.out_spaces</code> and <code>f.out_newline</code> are normally connected to <code>f.out_string</code> and <code>f.out_flush</code>: respective default values for <code>f.out_space</code> and <code>f.out_newline</code> are <code>f.out_string (String.make n &#39; &#39;) 0 n</code> and <code>f.out_string &quot;\n&quot; 0 1</code>.</p>\n", "kind": "value", "args": [["", "formatter_out_functions"]]}, {"path": "Format", "name": "get_formatter_out_functions", "type": "let get_formatter_out_functions: unit => formatter_out_functions", "docs": "<p>Return the current output functions of the pretty-printer, including line breaking and indentation functions. Useful to record the current setting and restore it afterwards.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "formatter_tag_functions", "type": "type formatter_tag_functions = {\n  mark_open_tag: tag => string,\n  mark_close_tag: tag => string,\n  print_open_tag: tag => unit,\n  print_close_tag: tag => unit\n}", "docs": "<p>The tag handling functions specific to a formatter: <code>mark</code> versions are the &#39;tag marking&#39; functions that associate a string marker to a tag in order for the pretty-printing engine to flush those markers as 0 length tokens in the output device of the formatter. <code>print</code> versions are the &#39;tag printing&#39; functions that can perform regular printing when a tag is closed or opened.</p>\n", "kind": "type"}, {"path": "Format", "name": "set_formatter_tag_functions", "type": "let set_formatter_tag_functions: formatter_tag_functions => unit", "docs": "<p><code>set_formatter_tag_functions tag_funs</code> changes the meaning of opening and closing tags to use the functions in <code>tag_funs</code>.</p>\n<p>When opening a tag name <code>t</code>, the string <code>t</code> is passed to the opening tag marking function (the <code>mark_open_tag</code> field of the record <code>tag_funs</code>), that must return the opening tag marker for that name. When the next call to <code>close_tag ()</code> happens, the tag name <code>t</code> is sent back to the closing tag marking function (the <code>mark_close_tag</code> field of record <code>tag_funs</code>), that must return a closing tag marker for that name.</p>\n<p>The <code>print_</code> field of the record contains the functions that are called at tag opening and tag closing time, to output regular material in the pretty-printer queue.</p>\n", "kind": "value", "args": [["", "formatter_tag_functions"]]}, {"path": "Format", "name": "get_formatter_tag_functions", "type": "let get_formatter_tag_functions: unit => formatter_tag_functions", "docs": "<p>Return the current tag functions of the pretty-printer.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "formatter", "type": "type formatter", "docs": "<p>Abstract data corresponding to a pretty-printer (also called a formatter) and all its machinery.</p>\n<p>Defining new pretty-printers permits unrelated output of material in parallel on several output channels. All the parameters of a pretty-printer are local to this pretty-printer: margin, maximum indentation limit, maximum number of boxes simultaneously opened, ellipsis, and so on, are specific to each pretty-printer and may be fixed independently. Given a <code>Pervasives.out_channel</code> output channel <code>oc</code>, a new formatter writing to that channel is simply obtained by calling <code>formatter_of_out_channel oc</code>. Alternatively, the <code>make_formatter</code> function allocates a new formatter with explicit output and flushing functions (convenient to output material to strings for instance).</p>\n", "kind": "type"}, {"path": "Format", "name": "formatter_of_out_channel", "type": "let formatter_of_out_channel: Pervasives.out_channel => formatter", "docs": "<p><code>formatter_of_out_channel oc</code> returns a new formatter that writes to the corresponding channel <code>oc</code>.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"]]}, {"path": "Format", "name": "std_formatter", "type": "let std_formatter: formatter", "docs": "<p>The standard formatter used by the formatting functions above. It is defined as <code>formatter_of_out_channel stdout</code>.</p>\n", "kind": "value"}, {"path": "Format", "name": "err_formatter", "type": "let err_formatter: formatter", "docs": "<p>A formatter to use with formatting functions below for output to standard error. It is defined as <code>formatter_of_out_channel stderr</code>.</p>\n", "kind": "value"}, {"path": "Format", "name": "formatter_of_buffer", "type": "let formatter_of_buffer: Buffer.t => formatter", "docs": "<p><code>formatter_of_buffer b</code> returns a new formatter writing to buffer <code>b</code>. As usual, the formatter has to be flushed at the end of pretty printing, using <code>pp_print_flush</code> or <code>pp_print_newline</code>, to display all the pending material.</p>\n", "kind": "value", "args": [["", "Buffer.t"]]}, {"path": "Format", "name": "stdbuf", "type": "let stdbuf: Buffer.t", "docs": "<p>The string buffer in which <code>str_formatter</code> writes.</p>\n", "kind": "value"}, {"path": "Format", "name": "str_formatter", "type": "let str_formatter: formatter", "docs": "<p>A formatter to use with formatting functions below for output to the <code>stdbuf</code> string buffer. <code>str_formatter</code> is defined as <code>formatter_of_buffer stdbuf</code>.</p>\n", "kind": "value"}, {"path": "Format", "name": "flush_str_formatter", "type": "let flush_str_formatter: unit => string", "docs": "<p>Returns the material printed with <code>str_formatter</code>, flushes the formatter and resets the corresponding buffer.</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "make_formatter", "type": "let make_formatter: ((string, int, int) => unit, unit => unit) => formatter", "docs": "<p><code>make_formatter out flush</code> returns a new formatter that writes according to the output function <code>out</code>, and the flushing function <code>flush</code>. For instance, a formatter to the <code>Pervasives.out_channel</code> <code>oc</code> is returned by <code>make_formatter (Pervasives.output oc) (fun () -&gt; Pervasives.flush oc)</code>.</p>\n", "kind": "value", "args": [["", "(string, int, int) => unit"], ["", "unit => unit"]]}, {"path": "Format", "name": "pp_open_hbox", "type": "let pp_open_hbox: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_open_vbox", "type": "let pp_open_vbox: (formatter, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"]]}, {"path": "Format", "name": "pp_open_hvbox", "type": "let pp_open_hvbox: (formatter, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"]]}, {"path": "Format", "name": "pp_open_hovbox", "type": "let pp_open_hovbox: (formatter, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"]]}, {"path": "Format", "name": "pp_open_box", "type": "let pp_open_box: (formatter, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"]]}, {"path": "Format", "name": "pp_close_box", "type": "let pp_close_box: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_open_tag", "type": "let pp_open_tag: (formatter, string) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "string"]]}, {"path": "Format", "name": "pp_close_tag", "type": "let pp_close_tag: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_print_string", "type": "let pp_print_string: (formatter, string) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "string"]]}, {"path": "Format", "name": "pp_print_as", "type": "let pp_print_as: (formatter, int, string) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"], ["", "string"]]}, {"path": "Format", "name": "pp_print_int", "type": "let pp_print_int: (formatter, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"]]}, {"path": "Format", "name": "pp_print_float", "type": "let pp_print_float: (formatter, float) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "float"]]}, {"path": "Format", "name": "pp_print_char", "type": "let pp_print_char: (formatter, char) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "char"]]}, {"path": "Format", "name": "pp_print_bool", "type": "let pp_print_bool: (formatter, bool) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "bool"]]}, {"path": "Format", "name": "pp_print_break", "type": "let pp_print_break: (formatter, int, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"], ["", "int"]]}, {"path": "Format", "name": "pp_print_cut", "type": "let pp_print_cut: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_print_space", "type": "let pp_print_space: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_force_newline", "type": "let pp_force_newline: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_print_flush", "type": "let pp_print_flush: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_print_newline", "type": "let pp_print_newline: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_print_if_newline", "type": "let pp_print_if_newline: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_open_tbox", "type": "let pp_open_tbox: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_close_tbox", "type": "let pp_close_tbox: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_print_tbreak", "type": "let pp_print_tbreak: (formatter, int, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"], ["", "int"]]}, {"path": "Format", "name": "pp_set_tab", "type": "let pp_set_tab: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_print_tab", "type": "let pp_print_tab: (formatter, unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_set_tags", "type": "let pp_set_tags: (formatter, bool) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "bool"]]}, {"path": "Format", "name": "pp_set_print_tags", "type": "let pp_set_print_tags: (formatter, bool) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "bool"]]}, {"path": "Format", "name": "pp_set_mark_tags", "type": "let pp_set_mark_tags: (formatter, bool) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "bool"]]}, {"path": "Format", "name": "pp_get_print_tags", "type": "let pp_get_print_tags: (formatter, unit) => bool", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_get_mark_tags", "type": "let pp_get_mark_tags: (formatter, unit) => bool", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_set_margin", "type": "let pp_set_margin: (formatter, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"]]}, {"path": "Format", "name": "pp_get_margin", "type": "let pp_get_margin: (formatter, unit) => int", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_set_max_indent", "type": "let pp_set_max_indent: (formatter, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"]]}, {"path": "Format", "name": "pp_get_max_indent", "type": "let pp_get_max_indent: (formatter, unit) => int", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_set_max_boxes", "type": "let pp_set_max_boxes: (formatter, int) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "int"]]}, {"path": "Format", "name": "pp_get_max_boxes", "type": "let pp_get_max_boxes: (formatter, unit) => int", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_over_max_boxes", "type": "let pp_over_max_boxes: (formatter, unit) => bool", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_set_ellipsis_text", "type": "let pp_set_ellipsis_text: (formatter, string) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "string"]]}, {"path": "Format", "name": "pp_get_ellipsis_text", "type": "let pp_get_ellipsis_text: (formatter, unit) => string", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_set_formatter_out_channel", "type": "let pp_set_formatter_out_channel: (formatter, Pervasives.out_channel) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "Pervasives.out_channel"]]}, {"path": "Format", "name": "pp_set_formatter_output_functions", "type": "let pp_set_formatter_output_functions: (formatter, (string, int, int) => unit, unit => unit) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "(string, int, int) => unit"], ["", "unit => unit"]]}, {"path": "Format", "name": "pp_get_formatter_output_functions", "type": "let pp_get_formatter_output_functions: (formatter, unit) => (\n  (string, int, int) => unit,\n  unit => unit\n)", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_set_formatter_tag_functions", "type": "let pp_set_formatter_tag_functions: (formatter, formatter_tag_functions) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "formatter_tag_functions"]]}, {"path": "Format", "name": "pp_get_formatter_tag_functions", "type": "let pp_get_formatter_tag_functions: (formatter, unit) => formatter_tag_functions", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_set_formatter_out_functions", "type": "let pp_set_formatter_out_functions: (formatter, formatter_out_functions) => unit", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "formatter_out_functions"]]}, {"path": "Format", "name": "pp_get_formatter_out_functions", "type": "let pp_get_formatter_out_functions: (formatter, unit) => formatter_out_functions", "docs": "<p>These functions are the basic ones: usual functions operating on the standard formatter are defined via partial evaluation of these primitives. For instance, <code>print_string</code> is equal to <code>pp_print_string std_formatter</code>.</p>\n", "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "Format", "name": "pp_print_list", "type": "let pp_print_list: (\n  ~?pp_sep: option((formatter, unit) => unit),\n  (formatter, 'a) => unit,\n  formatter,\n  list('a)\n) => unit", "docs": "<p><code>pp_print_list ?pp_sep pp_v ppf l</code> prints the list <code>l</code>. <code>pp_v</code> is used on the elements of <code>l</code> and each element is separated by a call to <code>pp_sep</code> (defaults to pp_print_cut). Does nothing on empty lists.</p>\nSince: 4.02.0", "kind": "value", "args": [["pp_sep", "(formatter, unit) => unit (optional)"], ["", "(formatter, 'a) => unit"], ["", "formatter"], ["", "list('a)"]]}, {"path": "Format", "name": "pp_print_text", "type": "let pp_print_text: (formatter, string) => unit", "docs": "<p><code>pp_print_text ppf s</code> prints <code>s</code> with spaces and newlines respectively printed with pp_print_space and pp_force_newline.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "formatter"], ["", "string"]]}, {"path": "Format", "name": "fprintf", "type": "let fprintf: (formatter, Pervasives.format('a, formatter, unit)) => 'a", "docs": null, "kind": "value", "args": [["", "formatter"], ["", "Pervasives.format('a, formatter, unit)"]]}, {"path": "Format", "name": "printf", "type": "let printf: Pervasives.format('a, formatter, unit) => 'a", "docs": "<p>Same as <code>fprintf</code> above, but output on <code>std_formatter</code>.</p>\n", "kind": "value", "args": [["", "Pervasives.format('a, formatter, unit)"]]}, {"path": "Format", "name": "eprintf", "type": "let eprintf: Pervasives.format('a, formatter, unit) => 'a", "docs": "<p>Same as <code>fprintf</code> above, but output on <code>err_formatter</code>.</p>\n", "kind": "value", "args": [["", "Pervasives.format('a, formatter, unit)"]]}, {"path": "Format", "name": "sprintf", "type": "let sprintf: Pervasives.format('a, unit, string) => 'a", "docs": "<p>Same as <code>printf</code> above, but instead of printing on a formatter, returns a string containing the result of formatting the arguments. Note that the pretty-printer queue is flushed at the end of <em>each call</em> to <code>sprintf</code>.</p>\n<p>In case of multiple and related calls to <code>sprintf</code> to output material on a single string, you should consider using <code>fprintf</code> with the predefined formatter <code>str_formatter</code> and call <code>flush_str_formatter ()</code> to get the final result.</p>\n<p>Alternatively, you can use <code>Format.fprintf</code> with a formatter writing to a buffer of your own: flushing the formatter and the buffer at the end of pretty-printing returns the desired string.</p>\n", "kind": "value", "args": [["", "Pervasives.format('a, unit, string)"]]}, {"path": "Format", "name": "asprintf", "type": "let asprintf: Pervasives.format4('a, formatter, unit, string) => 'a", "docs": "<p>Same as <code>printf</code> above, but instead of printing on a formatter, returns a string containing the result of formatting the arguments. The type of <code>asprintf</code> is general enough to interact nicely with <code>%a</code> conversions.</p>\nSince: 4.01.0", "kind": "value", "args": [["", "Pervasives.format4('a, formatter, unit, string)"]]}, {"path": "Format", "name": "ifprintf", "type": "let ifprintf: (formatter, Pervasives.format('a, formatter, unit)) => 'a", "docs": "<p>Same as <code>fprintf</code> above, but does not print anything. Useful to ignore some material when conditionally printing.</p>\nSince: 3.10.0", "kind": "value", "args": [["", "formatter"], ["", "Pervasives.format('a, formatter, unit)"]]}, {"path": "Format", "name": "kfprintf", "type": "let kfprintf: (formatter => 'a, formatter, Pervasives.format4('b, formatter, unit, 'a)) => 'b", "docs": "<p>Same as <code>fprintf</code> above, but instead of returning immediately, passes the formatter to its first argument at the end of printing.</p>\n", "kind": "value", "args": [["", "formatter => 'a"], ["", "formatter"], ["", "Pervasives.format4('b, formatter, unit, 'a)"]]}, {"path": "Format", "name": "ikfprintf", "type": "let ikfprintf: (formatter => 'a, formatter, Pervasives.format4('b, formatter, unit, 'a)) => 'b", "docs": "<p>Same as <code>kfprintf</code> above, but does not print anything. Useful to ignore some material when conditionally printing.</p>\nSince: 3.12.0", "kind": "value", "args": [["", "formatter => 'a"], ["", "formatter"], ["", "Pervasives.format4('b, formatter, unit, 'a)"]]}, {"path": "Format", "name": "ksprintf", "type": "let ksprintf: (string => 'a, Pervasives.format4('b, unit, string, 'a)) => 'b", "docs": "<p>Same as <code>sprintf</code> above, but instead of returning the string, passes it to the first argument.</p>\n", "kind": "value", "args": [["", "string => 'a"], ["", "Pervasives.format4('b, unit, string, 'a)"]]}, {"path": "Format", "name": "bprintf", "type": "let bprintf: (Buffer.t, Pervasives.format('a, formatter, unit)) => 'a", "docs": "<p>Deprecated: <p>This function is error prone. Do not use it.</p>\n<p>If you need to print to some buffer <code>b</code>, you must first define a formatter writing to <code>b</code>, using <code>let to_b = formatter_of_buffer b</code>; then use regular calls to <code>Format.fprintf</code> on formatter <code>to_b</code>.</p></p>\n", "kind": "value", "args": [["", "Buffer.t"], ["", "Pervasives.format('a, formatter, unit)"]]}, {"path": "Format", "name": "kprintf", "type": "let kprintf: (string => 'a, Pervasives.format4('b, unit, string, 'a)) => 'b", "docs": "<p>Deprecated: <p>An alias for <code>ksprintf</code>.</p></p>\n", "kind": "value", "args": [["", "string => 'a"], ["", "Pervasives.format4('b, unit, string, 'a)"]]}, {"path": "Format", "name": "set_all_formatter_output_functions", "type": "let set_all_formatter_output_functions: (\n  ~out: (string, int, int) => unit,\n  ~flush: unit => unit,\n  ~newline: unit => unit,\n  ~spaces: int => unit\n) => unit", "docs": "<p>Deprecated: <p>Subsumed by <code>set_formatter_out_functions</code>.</p></p>\n", "kind": "value", "args": [["out", "(string, int, int) => unit"], ["flush", "unit => unit"], ["newline", "unit => unit"], ["spaces", "int => unit"]]}, {"path": "Format", "name": "get_all_formatter_output_functions", "type": "let get_all_formatter_output_functions: unit => (\n  (string, int, int) => unit,\n  unit => unit,\n  unit => unit,\n  int => unit\n)", "docs": "<p>Deprecated: <p>Subsumed by <code>get_formatter_out_functions</code>.</p></p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Format", "name": "pp_set_all_formatter_output_functions", "type": "let pp_set_all_formatter_output_functions: (\n  formatter,\n  ~out: (string, int, int) => unit,\n  ~flush: unit => unit,\n  ~newline: unit => unit,\n  ~spaces: int => unit\n) => unit", "docs": "<p>Deprecated: <p>Subsumed by <code>pp_set_formatter_out_functions</code>.</p></p>\n", "kind": "value", "args": [["", "formatter"], ["out", "(string, int, int) => unit"], ["flush", "unit => unit"], ["newline", "unit => unit"], ["spaces", "int => unit"]]}, {"path": "Format", "name": "pp_get_all_formatter_output_functions", "type": "let pp_get_all_formatter_output_functions: (formatter, unit) => (\n  (string, int, int) => unit,\n  unit => unit,\n  unit => unit,\n  int => unit\n)", "docs": "<p>Deprecated: <p>Subsumed by <code>pp_get_formatter_out_functions</code>.</p></p>\n", "kind": "value", "args": [["", "formatter"], ["", "unit"]]}, {"path": "", "name": "Format", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>asprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_box\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>close_tbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>err_formatter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flush_str_formatter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>force_newline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>formatter_of_buffer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>formatter_of_out_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_all_formatter_output_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_ellipsis_text\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_formatter_out_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_formatter_output_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_formatter_tag_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_margin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_mark_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_max_boxes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_max_indent\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_print_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ifprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ikfprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kfprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ksprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_formatter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_box\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_hbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_hovbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_hvbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_tbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_vbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>over_max_boxes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_close_box\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_close_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_close_tbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_force_newline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_all_formatter_output_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_ellipsis_text\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_formatter_out_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_formatter_output_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_formatter_tag_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_margin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_mark_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_max_boxes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_max_indent\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_get_print_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_open_box\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_open_hbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_open_hovbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_open_hvbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_open_tag\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_open_tbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_open_vbox\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_over_max_boxes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_as\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_bool\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_break\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_cut\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_flush\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_if_newline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_list\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_newline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_space\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_tab\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_tbreak\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_print_text\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_all_formatter_output_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_ellipsis_text\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_formatter_out_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_formatter_out_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_formatter_output_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_formatter_tag_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_margin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_mark_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_max_boxes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_max_indent\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_print_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_tab\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pp_set_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_as\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_bool\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_break\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_cut\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_flush\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_if_newline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_newline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_space\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_tab\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>print_tbreak\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>printf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_all_formatter_output_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_ellipsis_text\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_formatter_out_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_formatter_out_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_formatter_output_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_formatter_tag_functions\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_margin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_mark_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_max_boxes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_max_indent\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_print_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_tab\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_tags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sprintf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>std_formatter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stdbuf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>str_formatter\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>formatter\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>formatter_out_functions\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>formatter_tag_functions\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>tag", "docs": null, "kind": "module"}, {"path": "Filename", "name": "current_dir_name", "type": "let current_dir_name: string", "docs": "<p>The conventional name for the current directory (e.g. <code>.</code> in Unix).</p>\n", "kind": "value"}, {"path": "Filename", "name": "parent_dir_name", "type": "let parent_dir_name: string", "docs": "<p>The conventional name for the parent of the current directory (e.g. <code>..</code> in Unix).</p>\n", "kind": "value"}, {"path": "Filename", "name": "dir_sep", "type": "let dir_sep: string", "docs": "failed to parse: File &quot;&quot;, line 0, characters 44-58:\n&#39;@since&#39; must begin on its own line", "kind": "value"}, {"path": "Filename", "name": "concat", "type": "let concat: (string, string) => string", "docs": "<p><code>concat dir file</code> returns a file name that designates file <code>file</code> in directory <code>dir</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Filename", "name": "is_relative", "type": "let is_relative: string => bool", "docs": "<p>Return <code>true</code> if the file name is relative to the current directory, <code>false</code> if it is absolute (i.e. in Unix, starts with <code>/</code>).</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Filename", "name": "is_implicit", "type": "let is_implicit: string => bool", "docs": "<p>Return <code>true</code> if the file name is relative and does not start with an explicit reference to the current directory (<code>./</code> or <code>../</code> in Unix), <code>false</code> if it starts with an explicit reference to the root directory or the current directory.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Filename", "name": "check_suffix", "type": "let check_suffix: (string, string) => bool", "docs": "<p><code>check_suffix name suff</code> returns <code>true</code> if the filename <code>name</code> ends with the suffix <code>suff</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Filename", "name": "chop_suffix", "type": "let chop_suffix: (string, string) => string", "docs": "<p><code>chop_suffix name suff</code> removes the suffix <code>suff</code> from the filename <code>name</code>. The behavior is undefined if <code>name</code> does not end with the suffix <code>suff</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "string"]]}, {"path": "Filename", "name": "chop_extension", "type": "let chop_extension: string => string", "docs": "<p>Return the given file name without its extension. The extension is the shortest suffix starting with a period and not including a directory separator, <code>.xyz</code> for instance.</p>\n<p>Raise <code>Invalid_argument</code> if the given name does not contain an extension.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Filename", "name": "basename", "type": "let basename: string => string", "docs": "<p>Split a file name into directory name / base file name. If <code>name</code> is a valid file name, then <code>concat (dirname name) (basename name)</code> returns a file name which is equivalent to <code>name</code>. Moreover, after setting the current directory to <code>dirname name</code> (with chdir), references to <code>basename name</code> (which is a relative file name) designate the same file as <code>name</code> before the call to chdir.</p>\n<p>This function conforms to the specification of POSIX.1-2008 for the <code>basename</code> utility.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Filename", "name": "dirname", "type": "let dirname: string => string", "docs": "<p>See basename. This function conforms to the specification of POSIX.1-2008 for the <code>dirname</code> utility.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Filename", "name": "temp_file", "type": "let temp_file: (~?temp_dir: option(string), string, string) => string", "docs": "<p><code>temp_file prefix suffix</code> returns the name of a fresh temporary file in the temporary directory. The base name of the temporary file is formed by concatenating <code>prefix</code>, then a suitably chosen integer number, then <code>suffix</code>. The optional argument <code>temp_dir</code> indicates the temporary directory to use, defaulting to the current result of get_temp_dir_name. The temporary file is created empty, with permissions <code>0o600</code> (readable and writable only by the file owner). The file is guaranteed to be different from any other file that existed when <code>temp_file</code> was called. Raise <code>Sys_error</code> if the file could not be created.</p>\nUnhandled tag", "kind": "value", "args": [["temp_dir", "string (optional)"], ["", "string"], ["", "string"]]}, {"path": "Filename", "name": "open_temp_file", "type": "let open_temp_file: (\n  ~?mode: option(list(Pervasives.open_flag)),\n  ~?temp_dir: option(string),\n  string,\n  string\n) => (string, Pervasives.out_channel)", "docs": "<p>Same as temp_file, but returns both the name of a fresh temporary file, and an output channel opened (atomically) on this file. This function is more secure than <code>temp_file</code>: there is no risk that the temporary file will be modified (e.g. replaced by a symbolic link) before the program opens it. The optional argument <code>mode</code> is a list of additional flags to control the opening of the file. It can contain one or several of <code>Open_append</code>, <code>Open_binary</code>, and <code>Open_text</code>. The default is <code>[Open_text]</code> (open in text mode). Raise <code>Sys_error</code> if the file could not be opened.</p>\nUnhandled tag", "kind": "value", "args": [["mode", "list(Pervasives.open_flag) (optional)"], ["temp_dir", "string (optional)"], ["", "string"], ["", "string"]]}, {"path": "Filename", "name": "get_temp_dir_name", "type": "let get_temp_dir_name: unit => string", "docs": "<p>The name of the temporary directory: Under Unix, the value of the <code>TMPDIR</code> environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the <code>TEMP</code> environment variable, or &quot;.&quot; if the variable is not set. The temporary directory can be changed with set_temp_dir_name.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "unit"]]}, {"path": "Filename", "name": "set_temp_dir_name", "type": "let set_temp_dir_name: string => unit", "docs": "<p>Change the temporary directory returned by get_temp_dir_name and used by temp_file and open_temp_file.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "string"]]}, {"path": "Filename", "name": "temp_dir_name", "type": "let temp_dir_name: string", "docs": "<p>The name of the initial temporary directory: Under Unix, the value of the <code>TMPDIR</code> environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the <code>TEMP</code> environment variable, or &quot;.&quot; if the variable is not set.</p>\n<p>Deprecated: <p>You should use get_temp_dir_name instead.</p></p>\nSince: 3.09.1", "kind": "value"}, {"path": "Filename", "name": "quote", "type": "let quote: string => string", "docs": "<p>Return a quoted version of a file name, suitable for use as one argument in a command line, escaping all meta-characters. Warning: under Windows, the output is only suitable for use with programs that follow the standard Windows quoting conventions.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "Filename", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>basename\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>check_suffix\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chop_extension\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chop_suffix\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>current_dir_name\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dir_sep\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dirname\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_temp_dir_name\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_implicit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_relative\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_temp_file\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parent_dir_name\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>quote\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_temp_dir_name\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>temp_dir_name\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>temp_file", "docs": null, "kind": "module"}, {"path": "Digest", "name": "t", "type": "type t = string", "docs": "<p>The type of digests: 16-character strings.</p>\n", "kind": "type"}, {"path": "Digest", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for 16-character digest, with the same specification as compare and the implementation shared with compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Digest</code> to be passed as argument to the functors Make and Make.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Digest", "name": "string", "type": "let string: string => t", "docs": "<p>Return the digest of the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Digest", "name": "bytes", "type": "let bytes: bytes => t", "docs": "<p>Return the digest of the given byte sequence.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "bytes"]]}, {"path": "Digest", "name": "substring", "type": "let substring: (string, int, int) => t", "docs": "<p><code>Digest.substring s ofs len</code> returns the digest of the substring of <code>s</code> starting at index <code>ofs</code> and containing <code>len</code> characters.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "int"]]}, {"path": "Digest", "name": "subbytes", "type": "let subbytes: (bytes, int, int) => t", "docs": "<p><code>Digest.subbytes s ofs len</code> returns the digest of the subsequence of <code>s</code> starting at index <code>ofs</code> and containing <code>len</code> bytes.</p>\nSince: 4.02.0", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Digest", "name": "channel", "type": "let channel: (Pervasives.in_channel, int) => t", "docs": "<p>If <code>len</code> is nonnegative, <code>Digest.channel ic len</code> reads <code>len</code> characters from channel <code>ic</code> and returns their digest, or raises <code>End_of_file</code> if end-of-file is reached before <code>len</code> characters are read. If <code>len</code> is negative, <code>Digest.channel ic len</code> reads all characters from <code>ic</code> until end-of-file is reached and return their digest.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"], ["", "int"]]}, {"path": "Digest", "name": "file", "type": "let file: string => t", "docs": "<p>Return the digest of the file whose name is given.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Digest", "name": "output", "type": "let output: (Pervasives.out_channel, t) => unit", "docs": "<p>Write a digest on the given output channel.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"], ["", "t"]]}, {"path": "Digest", "name": "input", "type": "let input: Pervasives.in_channel => t", "docs": "<p>Read a digest from the given input channel.</p>\n", "kind": "value", "args": [["", "Pervasives.in_channel"]]}, {"path": "Digest", "name": "to_hex", "type": "let to_hex: t => string", "docs": "<p>Return the printable hexadecimal representation of the given digest.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Digest", "name": "from_hex", "type": "let from_hex: string => t", "docs": "<p>Convert a hexadecimal representation back into the corresponding digest. Raise <code>Invalid_argument</code> if the argument is not exactly 32 hexadecimal characters.</p>\nSince: 4.00.0", "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "Digest", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>file\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_hex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>subbytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_hex\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Complex", "name": "t", "type": "type t = {re: float, im: float}", "docs": "<p>The type of complex numbers. <code>re</code> is the real part and <code>im</code> the imaginary part.</p>\n", "kind": "type"}, {"path": "Complex", "name": "zero", "type": "let zero: t", "docs": "<p>The complex number <code>0</code>.</p>\n", "kind": "value"}, {"path": "Complex", "name": "one", "type": "let one: t", "docs": "<p>The complex number <code>1</code>.</p>\n", "kind": "value"}, {"path": "Complex", "name": "i", "type": "let i: t", "docs": "<p>The complex number <code>i</code>.</p>\n", "kind": "value"}, {"path": "Complex", "name": "neg", "type": "let neg: t => t", "docs": "<p>Unary negation.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Complex", "name": "conj", "type": "let conj: t => t", "docs": "<p>Conjugate: given the complex <code>x + i.y</code>, returns <code>x - i.y</code>.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Complex", "name": "add", "type": "let add: (t, t) => t", "docs": "<p>Addition</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Complex", "name": "sub", "type": "let sub: (t, t) => t", "docs": "<p>Subtraction</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Complex", "name": "mul", "type": "let mul: (t, t) => t", "docs": "<p>Multiplication</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Complex", "name": "inv", "type": "let inv: t => t", "docs": "<p>Multiplicative inverse (<code>1/z</code>).</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Complex", "name": "div", "type": "let div: (t, t) => t", "docs": "<p>Division</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Complex", "name": "sqrt", "type": "let sqrt: t => t", "docs": "<p>Square root. The result <code>x + i.y</code> is such that <code>x &gt; 0</code> or <code>x = 0</code> and <code>y &gt;= 0</code>. This function has a discontinuity along the negative real axis.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Complex", "name": "norm2", "type": "let norm2: t => float", "docs": "<p>Norm squared: given <code>x + i.y</code>, returns <code>x^2 + y^2</code>.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Complex", "name": "norm", "type": "let norm: t => float", "docs": "<p>Norm: given <code>x + i.y</code>, returns <code>sqrt(x^2 + y^2)</code>.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Complex", "name": "arg", "type": "let arg: t => float", "docs": "<p>Argument. The argument of a complex number is the angle in the complex plane between the positive real axis and a line passing through zero and the number. This angle ranges from <code>-pi</code> to <code>pi</code>. This function has a discontinuity along the negative real axis.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Complex", "name": "polar", "type": "let polar: (float, float) => t", "docs": "<p><code>polar norm arg</code> returns the complex having norm <code>norm</code> and argument <code>arg</code>.</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Complex", "name": "exp", "type": "let exp: t => t", "docs": "<p>Exponentiation. <code>exp z</code> returns <code>e</code> to the <code>z</code> power.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Complex", "name": "log", "type": "let log: t => t", "docs": "<p>Natural logarithm (in base <code>e</code>).</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Complex", "name": "pow", "type": "let pow: (t, t) => t", "docs": "<p>Power function. <code>pow z1 z2</code> returns <code>z1</code> to the <code>z2</code> power.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "", "name": "Complex", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>arg\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>conj\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>div\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>i\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mul\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>neg\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>norm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>norm2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>one\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>polar\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pow\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sqrt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>zero\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Char", "name": "code", "type": "let code: char => int", "docs": "<p>Return the ASCII code of the argument.</p>\n", "kind": "value", "args": [["", "char"]]}, {"path": "Char", "name": "chr", "type": "let chr: int => char", "docs": "<p>Return the character with the given ASCII code. Raise <code>Invalid_argument &quot;Char.chr&quot;</code> if the argument is outside the range 0--255.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Char", "name": "escaped", "type": "let escaped: char => string", "docs": "<p>Return a string representing the given character, with special characters escaped following the lexical conventions of OCaml.</p>\n", "kind": "value", "args": [["", "char"]]}, {"path": "Char", "name": "lowercase", "type": "let lowercase: char => char", "docs": "<p>Convert the given character to its equivalent lowercase character.</p>\n", "kind": "value", "args": [["", "char"]]}, {"path": "Char", "name": "uppercase", "type": "let uppercase: char => char", "docs": "<p>Convert the given character to its equivalent uppercase character.</p>\n", "kind": "value", "args": [["", "char"]]}, {"path": "Char", "name": "t", "type": "type t = char", "docs": "<p>An alias for the type of characters.</p>\n", "kind": "type"}, {"path": "Char", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for characters, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Char</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Char", "name": "unsafe_chr", "type": "let unsafe_chr: int => char", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "", "name": "Char", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>chr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>code\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>escaped\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lowercase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_chr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uppercase\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "CamlinternalOO", "name": "tag", "type": "type tag", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "label", "type": "type label", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "table", "type": "type table", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "meth", "type": "type meth", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "obj", "type": "type obj", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "closure", "type": "type closure", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "public_method_label", "type": "let public_method_label: string => tag", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "CamlinternalOO", "name": "new_method", "type": "let new_method: table => label", "docs": null, "kind": "value", "args": [["", "table"]]}, {"path": "CamlinternalOO", "name": "new_variable", "type": "let new_variable: (table, string) => int", "docs": null, "kind": "value", "args": [["", "table"], ["", "string"]]}, {"path": "CamlinternalOO", "name": "new_methods_variables", "type": "let new_methods_variables: (table, array(string), array(string)) => array(label)", "docs": null, "kind": "value", "args": [["", "table"], ["", "array(string)"], ["", "array(string)"]]}, {"path": "CamlinternalOO", "name": "get_variable", "type": "let get_variable: (table, string) => int", "docs": null, "kind": "value", "args": [["", "table"], ["", "string"]]}, {"path": "CamlinternalOO", "name": "get_variables", "type": "let get_variables: (table, array(string)) => array(int)", "docs": null, "kind": "value", "args": [["", "table"], ["", "array(string)"]]}, {"path": "CamlinternalOO", "name": "get_method_label", "type": "let get_method_label: (table, string) => label", "docs": null, "kind": "value", "args": [["", "table"], ["", "string"]]}, {"path": "CamlinternalOO", "name": "get_method_labels", "type": "let get_method_labels: (table, array(string)) => array(label)", "docs": null, "kind": "value", "args": [["", "table"], ["", "array(string)"]]}, {"path": "CamlinternalOO", "name": "get_method", "type": "let get_method: (table, label) => meth", "docs": null, "kind": "value", "args": [["", "table"], ["", "label"]]}, {"path": "CamlinternalOO", "name": "set_method", "type": "let set_method: (table, label, meth) => unit", "docs": null, "kind": "value", "args": [["", "table"], ["", "label"], ["", "meth"]]}, {"path": "CamlinternalOO", "name": "set_methods", "type": "let set_methods: (table, array(label)) => unit", "docs": null, "kind": "value", "args": [["", "table"], ["", "array(label)"]]}, {"path": "CamlinternalOO", "name": "narrow", "type": "let narrow: (table, array(string), array(string), array(string)) => unit", "docs": null, "kind": "value", "args": [["", "table"], ["", "array(string)"], ["", "array(string)"], ["", "array(string)"]]}, {"path": "CamlinternalOO", "name": "widen", "type": "let widen: table => unit", "docs": null, "kind": "value", "args": [["", "table"]]}, {"path": "CamlinternalOO", "name": "add_initializer", "type": "let add_initializer: (table, obj => unit) => unit", "docs": null, "kind": "value", "args": [["", "table"], ["", "obj => unit"]]}, {"path": "CamlinternalOO", "name": "dummy_table", "type": "let dummy_table: table", "docs": null, "kind": "value"}, {"path": "CamlinternalOO", "name": "create_table", "type": "let create_table: array(string) => table", "docs": null, "kind": "value", "args": [["", "array(string)"]]}, {"path": "CamlinternalOO", "name": "init_class", "type": "let init_class: table => unit", "docs": null, "kind": "value", "args": [["", "table"]]}, {"path": "CamlinternalOO", "name": "inherits", "type": "let inherits: (\n  table,\n  array(string),\n  array(string),\n  array(string),\n  (t, (table, obj) => Obj.t, t, obj),\n  bool\n) => array(Obj.t)", "docs": null, "kind": "value", "args": [["", "table"], ["", "array(string)"], ["", "array(string)"], ["", "array(string)"], ["", "(t, (table, obj) => Obj.t, t, obj)"], ["", "bool"]]}, {"path": "CamlinternalOO", "name": "make_class", "type": "let make_class: (array(string), (table, Obj.t) => t) => (t, (table, Obj.t) => t, Obj.t => t, Obj.t)", "docs": null, "kind": "value", "args": [["", "array(string)"], ["", "(table, Obj.t) => t"]]}, {"path": "CamlinternalOO", "name": "init_table", "type": "type init_table", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "make_class_store", "type": "let make_class_store: (array(string), table => t, init_table) => unit", "docs": null, "kind": "value", "args": [["", "array(string)"], ["", "table => t"], ["", "init_table"]]}, {"path": "CamlinternalOO", "name": "copy", "type": "let copy: &lt; .. &gt; => &lt; .. &gt;", "docs": null, "kind": "value", "args": [["", "&lt; .. &gt;"]]}, {"path": "CamlinternalOO", "name": "create_object", "type": "let create_object: table => obj", "docs": null, "kind": "value", "args": [["", "table"]]}, {"path": "CamlinternalOO", "name": "create_object_opt", "type": "let create_object_opt: (obj, table) => obj", "docs": null, "kind": "value", "args": [["", "obj"], ["", "table"]]}, {"path": "CamlinternalOO", "name": "run_initializers", "type": "let run_initializers: (obj, table) => unit", "docs": null, "kind": "value", "args": [["", "obj"], ["", "table"]]}, {"path": "CamlinternalOO", "name": "run_initializers_opt", "type": "let run_initializers_opt: (obj, obj, table) => obj", "docs": null, "kind": "value", "args": [["", "obj"], ["", "obj"], ["", "table"]]}, {"path": "CamlinternalOO", "name": "create_object_and_run_initializers", "type": "let create_object_and_run_initializers: (obj, table) => obj", "docs": null, "kind": "value", "args": [["", "obj"], ["", "table"]]}, {"path": "CamlinternalOO", "name": "sendcache", "type": "let sendcache: (obj, tag, t, int) => t", "docs": null, "kind": "value", "args": [["", "obj"], ["", "tag"], ["", "t"], ["", "int"]]}, {"path": "CamlinternalOO", "name": "sendself", "type": "let sendself: (obj, label) => t", "docs": null, "kind": "value", "args": [["", "obj"], ["", "label"]]}, {"path": "CamlinternalOO", "name": "get_public_method", "type": "let get_public_method: (obj, tag) => closure", "docs": null, "kind": "value", "args": [["", "obj"], ["", "tag"]]}, {"path": "CamlinternalOO", "name": "tables", "type": "type tables", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "lookup_tables", "type": "let lookup_tables: (tables, array(closure)) => tables", "docs": null, "kind": "value", "args": [["", "tables"], ["", "array(closure)"]]}, {"path": "CamlinternalOO", "name": "impl", "type": "type impl = \n  | GetConst\n  | GetVar\n  | GetEnv\n  | GetMeth\n  | SetVar\n  | AppConst\n  | AppVar\n  | AppEnv\n  | AppMeth\n  | AppConstConst\n  | AppConstVar\n  | AppConstEnv\n  | AppConstMeth\n  | AppVarConst\n  | AppEnvConst\n  | AppMethConst\n  | MethAppConst\n  | MethAppVar\n  | MethAppEnv\n  | MethAppMeth\n  | SendConst\n  | SendVar\n  | SendEnv\n  | SendMeth\n  | Closure(closure)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "params", "type": "type params = {\n  mut compact_table: bool,\n  mut copy_parent: bool,\n  mut clean_when_copying: bool,\n  mut retry_count: int,\n  mut bucket_small_size: int\n}", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "params", "type": "let params: params", "docs": null, "kind": "value"}, {"path": "CamlinternalOO", "name": "stats", "type": "type stats = {classes: int, methods: int, inst_vars: int}", "docs": null, "kind": "type"}, {"path": "CamlinternalOO", "name": "stats", "type": "let stats: unit => stats", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "", "name": "CamlinternalOO", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_initializer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_object\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_object_and_run_initializers\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_object_opt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_table\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dummy_table\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_method\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_method_label\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_method_labels\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_public_method\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_variable\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get_variables\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>inherits\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init_class\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lookup_tables\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_class\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_class_store\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>narrow\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>new_method\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>new_methods_variables\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>new_variable\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>params\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>public_method_label\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>run_initializers\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>run_initializers_opt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sendcache\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sendself\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_method\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set_methods\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stats\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>widen\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>closure\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>impl\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>init_table\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>label\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>meth\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>obj\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>params\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>stats\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>table\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>tables\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>tag", "docs": null, "kind": "module"}, {"path": "CamlinternalMod", "name": "shape", "type": "type shape = | Function | Lazy | Class | Module(array(shape)) | Value(Obj.t)\n", "docs": null, "kind": "type"}, {"path": "", "name": "CamlinternalMod", "type": "<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>shape", "docs": null, "kind": "module"}, {"path": "CamlinternalLazy", "name": "force_lazy_block", "type": "let force_lazy_block: lazy_t('a) => 'a", "docs": null, "kind": "value", "args": [["", "lazy_t('a)"]]}, {"path": "CamlinternalLazy", "name": "force_val_lazy_block", "type": "let force_val_lazy_block: lazy_t('a) => 'a", "docs": null, "kind": "value", "args": [["", "lazy_t('a)"]]}, {"path": "CamlinternalLazy", "name": "force", "type": "let force: lazy_t('a) => 'a", "docs": null, "kind": "value", "args": [["", "lazy_t('a)"]]}, {"path": "CamlinternalLazy", "name": "force_val", "type": "let force_val: lazy_t('a) => 'a", "docs": null, "kind": "value", "args": [["", "lazy_t('a)"]]}, {"path": "", "name": "CamlinternalLazy", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>force\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>force_lazy_block\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>force_val\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>force_val_lazy_block", "docs": null, "kind": "module"}, {"path": "CamlinternalFormatBasics", "name": "padty", "type": "type padty = | Left | Right | Zeros\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "int_conv", "type": "type int_conv = \n  | Int_d\n  | Int_pd\n  | Int_sd\n  | Int_i\n  | Int_pi\n  | Int_si\n  | Int_x\n  | Int_Cx\n  | Int_X\n  | Int_CX\n  | Int_o\n  | Int_Co\n  | Int_u\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "float_conv", "type": "type float_conv = \n  | Float_f\n  | Float_pf\n  | Float_sf\n  | Float_e\n  | Float_pe\n  | Float_se\n  | Float_E\n  | Float_pE\n  | Float_sE\n  | Float_g\n  | Float_pg\n  | Float_sg\n  | Float_G\n  | Float_pG\n  | Float_sG\n  | Float_F\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "char_set", "type": "type char_set = string", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "counter", "type": "type counter = | Line_counter | Char_counter | Token_counter\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "padding", "type": "type padding('a, 'b) = \n  | No_padding: padding('a, 'a)\n  | Lit_padding(padty, int): padding('a, 'a)\n  | Arg_padding(padty): padding(int => 'a, 'a)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "pad_option", "type": "type pad_option = option(int)", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "precision", "type": "type precision('a, 'b) = \n  | No_precision: precision('a, 'a)\n  | Lit_precision(int): precision('a, 'a)\n  | Arg_precision: precision(int => 'a, 'a)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "prec_option", "type": "type prec_option = option(int)", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "custom_arity", "type": "type custom_arity('a, 'b, 'c) = \n  | Custom_zero: custom_arity('a, string, 'a)\n  | Custom_succ(custom_arity('a, 'b, 'c)): custom_arity('a, 'x => 'b, 'x => 'c)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "block_type", "type": "type block_type = | Pp_hbox | Pp_vbox | Pp_hvbox | Pp_hovbox | Pp_box | Pp_fits\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "formatting_lit", "type": "type formatting_lit = \n  | Close_box\n  | Close_tag\n  | Break(string, int, int)\n  | FFlush\n  | Force_newline\n  | Flush_newline\n  | Magic_size(string, int)\n  | Escaped_at\n  | Escaped_percent\n  | Scan_indic(char)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "formatting_gen", "type": "type formatting_gen('a, 'b, 'c, 'd, 'e, 'f) = \n  | Open_tag(format6('a, 'b, 'c, 'd, 'e, 'f)): formatting_gen('a, 'b, 'c, 'd, 'e, 'f)\n  | Open_box(format6('a, 'b, 'c, 'd, 'e, 'f)): formatting_gen('a, 'b, 'c, 'd, 'e, 'f)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "fmtty", "type": "type fmtty('a, 'b, 'c, 'd, 'e, 'f) = fmtty_rel('a, 'b, 'c, 'd, 'e, 'f, 'a, 'b, 'c, 'd, 'e, 'f)", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "fmtty_rel", "type": "type fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) = \n  | Char_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    char => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    char => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | String_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    string => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    string => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Int_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    int => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    int => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Int32_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    int32 => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    int32 => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Nativeint_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    nativeint => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    nativeint => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Int64_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    int64 => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    int64 => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Float_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    float => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    float => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Bool_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    bool => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    bool => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Format_arg_ty(\n    fmtty('g, 'h, 'i, 'j, 'k, 'l),\n    fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)\n  ): fmtty_rel(\n    format6('g, 'h, 'i, 'j, 'k, 'l) => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    format6('g, 'h, 'i, 'j, 'k, 'l) => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Format_subst_ty(\n    fmtty_rel('g, 'h, 'i, 'j, 'k, 'l, 'g1, 'b1, 'c1, 'j1, 'd1, 'a1),\n    fmtty_rel('g, 'h, 'i, 'j, 'k, 'l, 'g2, 'b2, 'c2, 'j2, 'd2, 'a2),\n    fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)\n  ): fmtty_rel(\n    format6('g, 'h, 'i, 'j, 'k, 'l) => 'g1,\n    'b1,\n    'c1,\n    'j1,\n    'e1,\n    'f1,\n    format6('g, 'h, 'i, 'j, 'k, 'l) => 'g2,\n    'b2,\n    'c2,\n    'j2,\n    'e2,\n    'f2\n  )\n  | Alpha_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    (('b1, 'x) => 'c1, 'x) => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    (('b2, 'x) => 'c2, 'x) => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Theta_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    'b1 => 'c1 => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    'b2 => 'c2 => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Any_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    'x => 'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    'x => 'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n  | Reader_ty(fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)): fmtty_rel(\n    'x => 'a1,\n    'b1,\n    'c1,\n    'b1 => 'x => 'd1,\n    'e1,\n    'f1,\n    'x => 'a2,\n    'b2,\n    'c2,\n    'b2 => 'x => 'd2,\n    'e2,\n    'f2\n  )\n  | Ignored_reader_ty(\n    fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)\n  ): fmtty_rel('a1, 'b1, 'c1, 'b1 => 'x => 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'b2 => 'x => 'd2, 'e2, 'f2)\n  | End_of_fmtty: fmtty_rel('f1, 'b1, 'c1, 'd1, 'd1, 'f1, 'f2, 'b2, 'c2, 'd2, 'd2, 'f2)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "fmt", "type": "type fmt('a, 'b, 'c, 'd, 'e, 'f) = \n  | Char(fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(char => 'a, 'b, 'c, 'd, 'e, 'f)\n  | Caml_char(fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(char => 'a, 'b, 'c, 'd, 'e, 'f)\n  | String(padding('x, string => 'a), fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt('x, 'b, 'c, 'd, 'e, 'f)\n  | Caml_string(padding('x, string => 'a), fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt('x, 'b, 'c, 'd, 'e, 'f)\n  | Int(int_conv, padding('x, 'y), precision('y, int => 'a), fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(\n    'x,\n    'b,\n    'c,\n    'd,\n    'e,\n    'f\n  )\n  | Int32(int_conv, padding('x, 'y), precision('y, int32 => 'a), fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(\n    'x,\n    'b,\n    'c,\n    'd,\n    'e,\n    'f\n  )\n  | Nativeint(\n    int_conv,\n    padding('x, 'y),\n    precision('y, nativeint => 'a),\n    fmt('a, 'b, 'c, 'd, 'e, 'f)\n  ): fmt('x, 'b, 'c, 'd, 'e, 'f)\n  | Int64(int_conv, padding('x, 'y), precision('y, int64 => 'a), fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(\n    'x,\n    'b,\n    'c,\n    'd,\n    'e,\n    'f\n  )\n  | Float(\n    float_conv,\n    padding('x, 'y),\n    precision('y, float => 'a),\n    fmt('a, 'b, 'c, 'd, 'e, 'f)\n  ): fmt('x, 'b, 'c, 'd, 'e, 'f)\n  | Bool(fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(bool => 'a, 'b, 'c, 'd, 'e, 'f)\n  | Flush(fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt('a, 'b, 'c, 'd, 'e, 'f)\n  | String_literal(string, fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt('a, 'b, 'c, 'd, 'e, 'f)\n  | Char_literal(char, fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt('a, 'b, 'c, 'd, 'e, 'f)\n  | Format_arg(pad_option, fmtty('g, 'h, 'i, 'j, 'k, 'l), fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(\n    format6('g, 'h, 'i, 'j, 'k, 'l) => 'a,\n    'b,\n    'c,\n    'd,\n    'e,\n    'f\n  )\n  | Format_subst(\n    pad_option,\n    fmtty_rel('g, 'h, 'i, 'j, 'k, 'l, 'g2, 'b, 'c, 'j2, 'd, 'a),\n    fmt('a, 'b, 'c, 'd, 'e, 'f)\n  ): fmt(format6('g, 'h, 'i, 'j, 'k, 'l) => 'g2, 'b, 'c, 'j2, 'e, 'f)\n  | Alpha(fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt((('b, 'x) => 'c, 'x) => 'a, 'b, 'c, 'd, 'e, 'f)\n  | Theta(fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt('b => 'c => 'a, 'b, 'c, 'd, 'e, 'f)\n  | Formatting_lit(formatting_lit, fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt('a, 'b, 'c, 'd, 'e, 'f)\n  | Formatting_gen(\n    formatting_gen('a1, 'b, 'c, 'd1, 'e1, 'f1),\n    fmt('f1, 'b, 'c, 'e1, 'e2, 'f2)\n  ): fmt('a1, 'b, 'c, 'd1, 'e2, 'f2)\n  | Reader(fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt('x => 'a, 'b, 'c, 'b => 'x => 'd, 'e, 'f)\n  | Scan_char_set(pad_option, char_set, fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(\n    string => 'a,\n    'b,\n    'c,\n    'd,\n    'e,\n    'f\n  )\n  | Scan_get_counter(counter, fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(int => 'a, 'b, 'c, 'd, 'e, 'f)\n  | Scan_next_char(fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(char => 'a, 'b, 'c, 'd, 'e, 'f)\n  | Ignored_param(ignored('a, 'b, 'c, 'd, 'y, 'x), fmt('x, 'b, 'c, 'y, 'e, 'f)): fmt(\n    'a,\n    'b,\n    'c,\n    'd,\n    'e,\n    'f\n  )\n  | Custom(custom_arity('a, 'x, 'y), unit => 'x, fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt(\n    'y,\n    'b,\n    'c,\n    'd,\n    'e,\n    'f\n  )\n  | End_of_format: fmt('f, 'b, 'c, 'e, 'e, 'f)\n", "docs": "<p>List of format elements.</p>\n", "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "ignored", "type": "type ignored('a, 'b, 'c, 'd, 'e, 'f) = \n  | Ignored_char: ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_caml_char: ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_string(pad_option): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_caml_string(pad_option): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_int(int_conv, pad_option): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_int32(int_conv, pad_option): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_nativeint(int_conv, pad_option): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_int64(int_conv, pad_option): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_float(pad_option, prec_option): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_bool: ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_format_arg(pad_option, fmtty('g, 'h, 'i, 'j, 'k, 'l)): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_format_subst(pad_option, fmtty('a, 'b, 'c, 'd, 'e, 'f)): ignored('a, 'b, 'c, 'd, 'e, 'f)\n  | Ignored_reader: ignored('a, 'b, 'c, 'b => 'x => 'd, 'd, 'a)\n  | Ignored_scan_char_set(pad_option, char_set): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_scan_get_counter(counter): ignored('a, 'b, 'c, 'd, 'd, 'a)\n  | Ignored_scan_next_char: ignored('a, 'b, 'c, 'd, 'd, 'a)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "format6", "type": "type format6('a, 'b, 'c, 'd, 'e, 'f) = | Format(fmt('a, 'b, 'c, 'd, 'e, 'f), string)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormatBasics", "name": "concat_fmtty", "type": "let concat_fmtty: (\n  fmtty_rel('g1, 'b1, 'c1, 'j1, 'd1, 'a1, 'g2, 'b2, 'c2, 'j2, 'd2, 'a2),\n  fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)\n) => fmtty_rel('g1, 'b1, 'c1, 'j1, 'e1, 'f1, 'g2, 'b2, 'c2, 'j2, 'e2, 'f2)", "docs": null, "kind": "value", "args": [["", "fmtty_rel('g1, 'b1, 'c1, 'j1, 'd1, 'a1, 'g2, 'b2, 'c2, 'j2, 'd2, 'a2)"], ["", "fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)"]]}, {"path": "CamlinternalFormatBasics", "name": "erase_rel", "type": "let erase_rel: fmtty_rel('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l) => fmtty(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n)", "docs": null, "kind": "value", "args": [["", "fmtty_rel('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l)"]]}, {"path": "CamlinternalFormatBasics", "name": "concat_fmt", "type": "let concat_fmt: (fmt('a, 'b, 'c, 'd, 'e, 'f), fmt('f, 'b, 'c, 'e, 'g, 'h)) => fmt(\n  'a,\n  'b,\n  'c,\n  'd,\n  'g,\n  'h\n)", "docs": null, "kind": "value", "args": [["", "fmt('a, 'b, 'c, 'd, 'e, 'f)"], ["", "fmt('f, 'b, 'c, 'e, 'g, 'h)"]]}, {"path": "", "name": "CamlinternalFormatBasics", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat_fmt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat_fmtty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>erase_rel\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>block_type\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>char_set\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>counter\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>custom_arity\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>float_conv\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>fmt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>fmtty\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>fmtty_rel\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>format6\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>formatting_gen\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>formatting_lit\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>ignored\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>int_conv\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>pad_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>padding\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>padty\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>prec_option\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>precision", "docs": null, "kind": "module"}, {"path": "CamlinternalFormat", "name": "is_in_char_set", "type": "let is_in_char_set: (CamlinternalFormatBasics.char_set, char) => bool", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.char_set"], ["", "char"]]}, {"path": "CamlinternalFormat", "name": "rev_char_set", "type": "let rev_char_set: CamlinternalFormatBasics.char_set => CamlinternalFormatBasics.char_set", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.char_set"]]}, {"path": "CamlinternalFormat", "name": "mutable_char_set", "type": "type mutable_char_set = bytes", "docs": null, "kind": "type"}, {"path": "CamlinternalFormat", "name": "create_char_set", "type": "let create_char_set: unit => mutable_char_set", "docs": null, "kind": "value", "args": [["", "unit"]]}, {"path": "CamlinternalFormat", "name": "add_in_char_set", "type": "let add_in_char_set: (mutable_char_set, char) => unit", "docs": null, "kind": "value", "args": [["", "mutable_char_set"], ["", "char"]]}, {"path": "CamlinternalFormat", "name": "freeze_char_set", "type": "let freeze_char_set: mutable_char_set => CamlinternalFormatBasics.char_set", "docs": null, "kind": "value", "args": [["", "mutable_char_set"]]}, {"path": "CamlinternalFormat", "name": "param_format_ebb", "type": "type param_format_ebb('a, 'b, 'c, 'd, 'e, 'f) = \n  | Param_format_EBB(CamlinternalFormatBasics.fmt('x => 'a, 'b, 'c, 'd, 'e, 'f)): param_format_ebb(\n    'a,\n    'b,\n    'c,\n    'd,\n    'e,\n    'f\n  )\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormat", "name": "param_format_of_ignored_format", "type": "let param_format_of_ignored_format: (\n  CamlinternalFormatBasics.ignored('a, 'b, 'c, 'd, 'y, 'x),\n  CamlinternalFormatBasics.fmt('x, 'b, 'c, 'y, 'e, 'f)\n) => param_format_ebb('a, 'b, 'c, 'd, 'e, 'f)", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.ignored('a, 'b, 'c, 'd, 'y, 'x)"], ["", "CamlinternalFormatBasics.fmt('x, 'b, 'c, 'y, 'e, 'f)"]]}, {"path": "CamlinternalFormat", "name": "acc_formatting_gen", "type": "type acc_formatting_gen('b, 'c) = | Acc_open_tag(acc('b, 'c)) | Acc_open_box(acc('b, 'c))\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormat", "name": "acc", "type": "type acc('b, 'c) = \n  | Acc_formatting_lit(acc('b, 'c), CamlinternalFormatBasics.formatting_lit)\n  | Acc_formatting_gen(acc('b, 'c), acc_formatting_gen('b, 'c))\n  | Acc_string_literal(acc('b, 'c), string)\n  | Acc_char_literal(acc('b, 'c), char)\n  | Acc_data_string(acc('b, 'c), string)\n  | Acc_data_char(acc('b, 'c), char)\n  | Acc_delay(acc('b, 'c), 'b => 'c)\n  | Acc_flush(acc('b, 'c))\n  | Acc_invalid_arg(acc('b, 'c), string)\n  | End_of_acc\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormat", "name": "heter_list", "type": "type heter_list('a, 'b) = \n  | Cons('c, heter_list('a, 'b)): heter_list('c => 'a, 'b)\n  | Nil: heter_list('b, 'b)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormat", "name": "fmt_ebb", "type": "type fmt_ebb('b, 'c, 'e, 'f) = \n  | Fmt_EBB(CamlinternalFormatBasics.fmt('a, 'b, 'c, 'd, 'e, 'f)): fmt_ebb('b, 'c, 'e, 'f)\n", "docs": null, "kind": "type"}, {"path": "CamlinternalFormat", "name": "make_printf", "type": "let make_printf: (\n  ('b, acc('b, 'c)) => 'd,\n  'b,\n  acc('b, 'c),\n  CamlinternalFormatBasics.fmt('a, 'b, 'c, 'c, 'c, 'd)\n) => 'a", "docs": null, "kind": "value", "args": [["", "('b, acc('b, 'c)) => 'd"], ["", "'b"], ["", "acc('b, 'c)"], ["", "CamlinternalFormatBasics.fmt('a, 'b, 'c, 'c, 'c, 'd)"]]}, {"path": "CamlinternalFormat", "name": "output_acc", "type": "let output_acc: (Pervasives.out_channel, acc(Pervasives.out_channel, unit)) => unit", "docs": null, "kind": "value", "args": [["", "Pervasives.out_channel"], ["", "acc(Pervasives.out_channel, unit)"]]}, {"path": "CamlinternalFormat", "name": "bufput_acc", "type": "let bufput_acc: (Buffer.t, acc(Buffer.t, unit)) => unit", "docs": null, "kind": "value", "args": [["", "Buffer.t"], ["", "acc(Buffer.t, unit)"]]}, {"path": "CamlinternalFormat", "name": "strput_acc", "type": "let strput_acc: (Buffer.t, acc(unit, string)) => unit", "docs": null, "kind": "value", "args": [["", "Buffer.t"], ["", "acc(unit, string)"]]}, {"path": "CamlinternalFormat", "name": "type_format", "type": "let type_format: (\n  CamlinternalFormatBasics.fmt('x, 'b, 'c, 't, 'u, 'v),\n  CamlinternalFormatBasics.fmtty('a, 'b, 'c, 'd, 'e, 'f)\n) => CamlinternalFormatBasics.fmt('a, 'b, 'c, 'd, 'e, 'f)", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.fmt('x, 'b, 'c, 't, 'u, 'v)"], ["", "CamlinternalFormatBasics.fmtty('a, 'b, 'c, 'd, 'e, 'f)"]]}, {"path": "CamlinternalFormat", "name": "fmt_ebb_of_string", "type": "let fmt_ebb_of_string: (~?legacy_behavior: option(bool), string) => fmt_ebb('b, 'c, 'e, 'f)", "docs": null, "kind": "value", "args": [["legacy_behavior", "bool (optional)"], ["", "string"]]}, {"path": "CamlinternalFormat", "name": "format_of_string_fmtty", "type": "let format_of_string_fmtty: (\n  string,\n  CamlinternalFormatBasics.fmtty('a, 'b, 'c, 'd, 'e, 'f)\n) => CamlinternalFormatBasics.format6('a, 'b, 'c, 'd, 'e, 'f)", "docs": null, "kind": "value", "args": [["", "string"], ["", "CamlinternalFormatBasics.fmtty('a, 'b, 'c, 'd, 'e, 'f)"]]}, {"path": "CamlinternalFormat", "name": "format_of_string_format", "type": "let format_of_string_format: (\n  string,\n  CamlinternalFormatBasics.format6('a, 'b, 'c, 'd, 'e, 'f)\n) => CamlinternalFormatBasics.format6('a, 'b, 'c, 'd, 'e, 'f)", "docs": null, "kind": "value", "args": [["", "string"], ["", "CamlinternalFormatBasics.format6('a, 'b, 'c, 'd, 'e, 'f)"]]}, {"path": "CamlinternalFormat", "name": "char_of_iconv", "type": "let char_of_iconv: CamlinternalFormatBasics.int_conv => char", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.int_conv"]]}, {"path": "CamlinternalFormat", "name": "string_of_formatting_lit", "type": "let string_of_formatting_lit: CamlinternalFormatBasics.formatting_lit => string", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.formatting_lit"]]}, {"path": "CamlinternalFormat", "name": "string_of_formatting_gen", "type": "let string_of_formatting_gen: CamlinternalFormatBasics.formatting_gen(\n  'a,\n  'b,\n  'c,\n  'd,\n  'e,\n  'f\n) => string", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.formatting_gen('a, 'b, 'c, 'd, 'e, 'f)"]]}, {"path": "CamlinternalFormat", "name": "string_of_fmtty", "type": "let string_of_fmtty: CamlinternalFormatBasics.fmtty('a, 'b, 'c, 'd, 'e, 'f) => string", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.fmtty('a, 'b, 'c, 'd, 'e, 'f)"]]}, {"path": "CamlinternalFormat", "name": "string_of_fmt", "type": "let string_of_fmt: CamlinternalFormatBasics.fmt('a, 'b, 'c, 'd, 'e, 'f) => string", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.fmt('a, 'b, 'c, 'd, 'e, 'f)"]]}, {"path": "CamlinternalFormat", "name": "open_box_of_string", "type": "let open_box_of_string: string => (int, CamlinternalFormatBasics.block_type)", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "CamlinternalFormat", "name": "symm", "type": "let symm: CamlinternalFormatBasics.fmtty_rel(\n  'a1,\n  'b1,\n  'c1,\n  'd1,\n  'e1,\n  'f1,\n  'a2,\n  'b2,\n  'c2,\n  'd2,\n  'e2,\n  'f2\n) => CamlinternalFormatBasics.fmtty_rel('a2, 'b2, 'c2, 'd2, 'e2, 'f2, 'a1, 'b1, 'c1, 'd1, 'e1, 'f1)", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)"]]}, {"path": "CamlinternalFormat", "name": "trans", "type": "let trans: (\n  CamlinternalFormatBasics.fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2),\n  CamlinternalFormatBasics.fmtty_rel(\n    'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2,\n    'a3,\n    'b3,\n    'c3,\n    'd3,\n    'e3,\n    'f3\n  )\n) => CamlinternalFormatBasics.fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a3, 'b3, 'c3, 'd3, 'e3, 'f3)", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)"], ["", "CamlinternalFormatBasics.fmtty_rel('a2, 'b2, 'c2, 'd2, 'e2, 'f2, 'a3, 'b3, 'c3, 'd3, 'e3, 'f3)"]]}, {"path": "CamlinternalFormat", "name": "recast", "type": "let recast: (\n  CamlinternalFormatBasics.fmt('a1, 'b1, 'c1, 'd1, 'e1, 'f1),\n  CamlinternalFormatBasics.fmtty_rel(\n    'a1,\n    'b1,\n    'c1,\n    'd1,\n    'e1,\n    'f1,\n    'a2,\n    'b2,\n    'c2,\n    'd2,\n    'e2,\n    'f2\n  )\n) => CamlinternalFormatBasics.fmt('a2, 'b2, 'c2, 'd2, 'e2, 'f2)", "docs": null, "kind": "value", "args": [["", "CamlinternalFormatBasics.fmt('a1, 'b1, 'c1, 'd1, 'e1, 'f1)"], ["", "CamlinternalFormatBasics.fmtty_rel('a1, 'b1, 'c1, 'd1, 'e1, 'f1, 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)"]]}, {"path": "", "name": "CamlinternalFormat", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_in_char_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bufput_acc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>char_of_iconv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_char_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fmt_ebb_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format_of_string_fmtty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>format_of_string_format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>freeze_char_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>is_in_char_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_printf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>open_box_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output_acc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>param_format_of_ignored_format\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>recast\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev_char_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_fmt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_fmtty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_formatting_gen\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string_of_formatting_lit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>strput_acc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>symm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trans\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>type_format\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>acc\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>acc_formatting_gen\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>fmt_ebb\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>heter_list\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>mutable_char_set\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>param_format_ebb", "docs": null, "kind": "module"}, {"path": "Callback", "name": "register", "type": "let register: (string, 'a) => unit", "docs": "<p><code>Callback.register n v</code> registers the value <code>v</code> under the name <code>n</code>. C code can later retrieve a handle to <code>v</code> by calling <code>caml_named_value(n)</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "'a"]]}, {"path": "Callback", "name": "register_exception", "type": "let register_exception: (string, exn) => unit", "docs": "<p><code>Callback.register_exception n exn</code> registers the exception contained in the exception value <code>exn</code> under the name <code>n</code>. C code can later retrieve a handle to the exception by calling <code>caml_named_value(n)</code>. The exception value thus obtained is suitable for passing as first argument to <code>raise_constant</code> or <code>raise_with_arg</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "exn"]]}, {"path": "", "name": "Callback", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>register\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>register_exception", "docs": null, "kind": "module"}, {"path": "BytesLabels", "name": "length", "type": "let length: bytes => int", "docs": "<p>Return the length (number of bytes) of the argument.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "get", "type": "let get: (bytes, int) => char", "docs": "<p><code>get s n</code> returns the byte at index <code>n</code> in argument <code>s</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> not a valid index in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "BytesLabels", "name": "set", "type": "let set: (bytes, int, char) => unit", "docs": "<p><code>set s n c</code> modifies <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "BytesLabels", "name": "create", "type": "let create: int => bytes", "docs": "<p><code>create n</code> returns a new byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "BytesLabels", "name": "make", "type": "let make: (int, char) => bytes", "docs": "<p><code>make n c</code> returns a new byte sequence of length <code>n</code>, filled with the byte <code>c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["", "char"]]}, {"path": "BytesLabels", "name": "init", "type": "let init: (int, ~f: int => char) => bytes", "docs": "<p><code>init n f</code> returns a fresh byte sequence of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["f", "int => char"]]}, {"path": "BytesLabels", "name": "empty", "type": "let empty: bytes", "docs": "<p>A byte sequence of size 0.</p>\n", "kind": "value"}, {"path": "BytesLabels", "name": "copy", "type": "let copy: bytes => bytes", "docs": "<p>Return a new byte sequence that contains the same bytes as the argument.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "of_string", "type": "let of_string: string => bytes", "docs": "<p>Return a new byte sequence that contains the same bytes as the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "BytesLabels", "name": "to_string", "type": "let to_string: bytes => string", "docs": "<p>Return a new string that contains the same bytes as the given byte sequence.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "sub", "type": "let sub: (bytes, ~pos: int, ~len: int) => bytes", "docs": "<p><code>sub s start len</code> returns a new byte sequence of length <code>len</code>, containing the subsequence of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"]]}, {"path": "BytesLabels", "name": "sub_string", "type": "let sub_string: (bytes, int, int) => string", "docs": "<p>Same as <code>sub</code> but return a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "BytesLabels", "name": "fill", "type": "let fill: (bytes, ~pos: int, ~len: int, char) => unit", "docs": "<p><code>fill s start len c</code> modifies <code>s</code> in place, replacing <code>len</code> characters with <code>c</code>, starting at <code>start</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"], ["", "char"]]}, {"path": "BytesLabels", "name": "blit", "type": "let blit: (~src: bytes, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit", "docs": "<p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from sequence <code>src</code>, starting at index <code>srcoff</code>, to sequence <code>dst</code>, starting at index <code>dstoff</code>. It works correctly even if <code>src</code> and <code>dst</code> are the same byte sequence, and the source and destination intervals overlap.</p>\n<p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p>\n", "kind": "value", "args": [["src", "bytes"], ["src_pos", "int"], ["dst", "bytes"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "BytesLabels", "name": "concat", "type": "let concat: (~sep: bytes, list(bytes)) => bytes", "docs": "<p><code>concat sep sl</code> concatenates the list of byte sequences <code>sl</code>, inserting the separator byte sequence <code>sep</code> between each, and returns the result as a new byte sequence.</p>\n", "kind": "value", "args": [["sep", "bytes"], ["", "list(bytes)"]]}, {"path": "BytesLabels", "name": "iter", "type": "let iter: (~f: char => unit, bytes) => unit", "docs": "<p><code>iter f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code>. It is equivalent to <code>f (get s 0); f (get s 1); ...; f (get s\n    (length s - 1)); ()</code>.</p>\n", "kind": "value", "args": [["f", "char => unit"], ["", "bytes"]]}, {"path": "BytesLabels", "name": "iteri", "type": "let iteri: (~f: (int, char) => unit, bytes) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the byte as first argument and the byte itself as second argument.</p>\n", "kind": "value", "args": [["f", "(int, char) => unit"], ["", "bytes"]]}, {"path": "BytesLabels", "name": "map", "type": "let map: (~f: char => char, bytes) => bytes", "docs": "<p><code>map f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code> and stores the resulting bytes in a new sequence that is returned as the result.</p>\n", "kind": "value", "args": [["f", "char => char"], ["", "bytes"]]}, {"path": "BytesLabels", "name": "mapi", "type": "let mapi: (~f: (int, char) => char, bytes) => bytes", "docs": "<p><code>mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p>\n", "kind": "value", "args": [["f", "(int, char) => char"], ["", "bytes"]]}, {"path": "BytesLabels", "name": "trim", "type": "let trim: bytes => bytes", "docs": "<p>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters <code>&#39; &#39;</code>, <code>&#39;\\012&#39;</code>, <code>&#39;\\n&#39;</code>, <code>&#39;\\r&#39;</code>, and <code>&#39;\\t&#39;</code>.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "escaped", "type": "let escaped: bytes => bytes", "docs": "<p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "index", "type": "let index: (bytes, char) => int", "docs": "<p><code>index s c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "char"]]}, {"path": "BytesLabels", "name": "rindex", "type": "let rindex: (bytes, char) => int", "docs": "<p><code>rindex s c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "char"]]}, {"path": "BytesLabels", "name": "index_from", "type": "let index_from: (bytes, int, char) => int", "docs": "<p><code>index_from s i c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> after position <code>i</code>. <code>Bytes.index s c</code> is equivalent to <code>Bytes.index_from s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "BytesLabels", "name": "rindex_from", "type": "let rindex_from: (bytes, int, char) => int", "docs": "<p><code>rindex_from s i c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> before position <code>i+1</code>. <code>rindex s c</code> is equivalent to <code>rindex_from s (Bytes.length s - 1) c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "BytesLabels", "name": "contains", "type": "let contains: (bytes, char) => bool", "docs": "<p><code>contains s c</code> tests if byte <code>c</code> appears in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "char"]]}, {"path": "BytesLabels", "name": "contains_from", "type": "let contains_from: (bytes, int, char) => bool", "docs": "<p><code>contains_from s start c</code> tests if byte <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>contains s c</code> is equivalent to <code>contains_from\n    s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "BytesLabels", "name": "rcontains_from", "type": "let rcontains_from: (bytes, int, char) => bool", "docs": "<p><code>rcontains_from s stop c</code> tests if byte <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "BytesLabels", "name": "uppercase", "type": "let uppercase: bytes => bytes", "docs": "<p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "lowercase", "type": "let lowercase: bytes => bytes", "docs": "<p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "capitalize", "type": "let capitalize: bytes => bytes", "docs": "<p>Return a copy of the argument, with the first byte set to uppercase.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "uncapitalize", "type": "let uncapitalize: bytes => bytes", "docs": "<p>Return a copy of the argument, with the first byte set to lowercase.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "t", "type": "type t = bytes", "docs": "<p>An alias for the type of byte sequences.</p>\n", "kind": "type"}, {"path": "BytesLabels", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for byte sequences, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Bytes</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "BytesLabels", "name": "unsafe_get", "type": "let unsafe_get: (bytes, int) => char", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "BytesLabels", "name": "unsafe_set", "type": "let unsafe_set: (bytes, int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "BytesLabels", "name": "unsafe_blit", "type": "let unsafe_blit: (~src: bytes, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit", "docs": null, "kind": "value", "args": [["src", "bytes"], ["src_pos", "int"], ["dst", "bytes"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "BytesLabels", "name": "unsafe_fill", "type": "let unsafe_fill: (bytes, ~pos: int, ~len: int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["pos", "int"], ["len", "int"], ["", "char"]]}, {"path": "BytesLabels", "name": "unsafe_to_string", "type": "let unsafe_to_string: bytes => string", "docs": null, "kind": "value", "args": [["", "bytes"]]}, {"path": "BytesLabels", "name": "unsafe_of_string", "type": "let unsafe_of_string: string => bytes", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "", "name": "BytesLabels", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>capitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>escaped\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lowercase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rcontains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uncapitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uppercase\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Bytes", "name": "length", "type": "let length: bytes => int", "docs": "<p>Return the length (number of bytes) of the argument.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "get", "type": "let get: (bytes, int) => char", "docs": "<p><code>get s n</code> returns the byte at index <code>n</code> in argument <code>s</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> not a valid index in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "Bytes", "name": "set", "type": "let set: (bytes, int, char) => unit", "docs": "<p><code>set s n c</code> modifies <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "Bytes", "name": "create", "type": "let create: int => bytes", "docs": "<p><code>create n</code> returns a new byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Bytes", "name": "make", "type": "let make: (int, char) => bytes", "docs": "<p><code>make n c</code> returns a new byte sequence of length <code>n</code>, filled with the byte <code>c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["", "char"]]}, {"path": "Bytes", "name": "init", "type": "let init: (int, int => char) => bytes", "docs": "<p><code>Bytes.init n f</code> returns a fresh byte sequence of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code> (in increasing index order).</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code>max_string_length.</p>\n", "kind": "value", "args": [["", "int"], ["", "int => char"]]}, {"path": "Bytes", "name": "empty", "type": "let empty: bytes", "docs": "<p>A byte sequence of size 0.</p>\n", "kind": "value"}, {"path": "Bytes", "name": "copy", "type": "let copy: bytes => bytes", "docs": "<p>Return a new byte sequence that contains the same bytes as the argument.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "of_string", "type": "let of_string: string => bytes", "docs": "<p>Return a new byte sequence that contains the same bytes as the given string.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Bytes", "name": "to_string", "type": "let to_string: bytes => string", "docs": "<p>Return a new string that contains the same bytes as the given byte sequence.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "sub", "type": "let sub: (bytes, int, int) => bytes", "docs": "<p><code>sub s start len</code> returns a new byte sequence of length <code>len</code>, containing the subsequence of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Bytes", "name": "sub_string", "type": "let sub_string: (bytes, int, int) => string", "docs": "<p>Same as <code>sub</code> but return a string instead of a byte sequence.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Bytes", "name": "extend", "type": "let extend: (bytes, int, int) => bytes", "docs": "<p><code>extend s left right</code> returns a new byte sequence that contains the bytes of <code>s</code>, with <code>left</code> uninitialized bytes prepended and <code>right</code> uninitialized bytes appended to it. If <code>left</code> or <code>right</code> is negative, then bytes are removed (instead of appended) from the corresponding side of <code>s</code>.</p>\n<p>Raise <code>Invalid_argument</code> if the result length is negative or longer than max_string_length bytes.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Bytes", "name": "fill", "type": "let fill: (bytes, int, int, char) => unit", "docs": "<p><code>fill s start len c</code> modifies <code>s</code> in place, replacing <code>len</code> characters with <code>c</code>, starting at <code>start</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"], ["", "char"]]}, {"path": "Bytes", "name": "blit", "type": "let blit: (bytes, int, bytes, int, int) => unit", "docs": "<p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from sequence <code>src</code>, starting at index <code>srcoff</code>, to sequence <code>dst</code>, starting at index <code>dstoff</code>. It works correctly even if <code>src</code> and <code>dst</code> are the same byte sequence, and the source and destination intervals overlap.</p>\n<p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Bytes", "name": "blit_string", "type": "let blit_string: (string, int, bytes, int, int) => unit", "docs": "<p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from string <code>src</code>, starting at index <code>srcoff</code>, to byte sequence <code>dst</code>, starting at index <code>dstoff</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p>\n", "kind": "value", "args": [["", "string"], ["", "int"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Bytes", "name": "concat", "type": "let concat: (bytes, list(bytes)) => bytes", "docs": "<p><code>concat sep sl</code> concatenates the list of byte sequences <code>sl</code>, inserting the separator byte sequence <code>sep</code> between each, and returns the result as a new byte sequence.</p>\n<p>Raise <code>Invalid_argument</code> if the result is longer than max_string_length bytes.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "list(bytes)"]]}, {"path": "Bytes", "name": "cat", "type": "let cat: (bytes, bytes) => bytes", "docs": "<p><code>cat s1 s2</code> concatenates <code>s1</code> and <code>s2</code> and returns the result as new byte sequence.</p>\n<p>Raise <code>Invalid_argument</code> if the result is longer than max_string_length bytes.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "bytes"]]}, {"path": "Bytes", "name": "iter", "type": "let iter: (char => unit, bytes) => unit", "docs": "<p><code>iter f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code>. It is equivalent to <code>f (get s 0); f (get s 1); ...; f (get s\n    (length s - 1)); ()</code>.</p>\n", "kind": "value", "args": [["", "char => unit"], ["", "bytes"]]}, {"path": "Bytes", "name": "iteri", "type": "let iteri: ((int, char) => unit, bytes) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the byte as first argument and the byte itself as second argument.</p>\n", "kind": "value", "args": [["", "(int, char) => unit"], ["", "bytes"]]}, {"path": "Bytes", "name": "map", "type": "let map: (char => char, bytes) => bytes", "docs": "<p><code>map f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code> (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p>\n", "kind": "value", "args": [["", "char => char"], ["", "bytes"]]}, {"path": "Bytes", "name": "mapi", "type": "let mapi: ((int, char) => char, bytes) => bytes", "docs": "<p><code>mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p>\n", "kind": "value", "args": [["", "(int, char) => char"], ["", "bytes"]]}, {"path": "Bytes", "name": "trim", "type": "let trim: bytes => bytes", "docs": "<p>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters <code>&#39; &#39;</code>, <code>&#39;\\012&#39;</code>, <code>&#39;\\n&#39;</code>, <code>&#39;\\r&#39;</code>, and <code>&#39;\\t&#39;</code>.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "escaped", "type": "let escaped: bytes => bytes", "docs": "<p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml.</p>\n<p>Raise <code>Invalid_argument</code> if the result is longer than max_string_length bytes.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "index", "type": "let index: (bytes, char) => int", "docs": "<p><code>index s c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "char"]]}, {"path": "Bytes", "name": "rindex", "type": "let rindex: (bytes, char) => int", "docs": "<p><code>rindex s c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code>.</p>\n<p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "char"]]}, {"path": "Bytes", "name": "index_from", "type": "let index_from: (bytes, int, char) => int", "docs": "<p><code>index_from s i c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> after position <code>i</code>. <code>Bytes.index s c</code> is equivalent to <code>Bytes.index_from s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "Bytes", "name": "rindex_from", "type": "let rindex_from: (bytes, int, char) => int", "docs": "<p><code>rindex_from s i c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> before position <code>i+1</code>. <code>rindex s c</code> is equivalent to <code>rindex_from s (Bytes.length s - 1) c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "Bytes", "name": "contains", "type": "let contains: (bytes, char) => bool", "docs": "<p><code>contains s c</code> tests if byte <code>c</code> appears in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "char"]]}, {"path": "Bytes", "name": "contains_from", "type": "let contains_from: (bytes, int, char) => bool", "docs": "<p><code>contains_from s start c</code> tests if byte <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>contains s c</code> is equivalent to <code>contains_from\n    s 0 c</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "Bytes", "name": "rcontains_from", "type": "let rcontains_from: (bytes, int, char) => bool", "docs": "<p><code>rcontains_from s stop c</code> tests if byte <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p>\n", "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "Bytes", "name": "uppercase", "type": "let uppercase: bytes => bytes", "docs": "<p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "lowercase", "type": "let lowercase: bytes => bytes", "docs": "<p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "capitalize", "type": "let capitalize: bytes => bytes", "docs": "<p>Return a copy of the argument, with the first byte set to uppercase.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "uncapitalize", "type": "let uncapitalize: bytes => bytes", "docs": "<p>Return a copy of the argument, with the first byte set to lowercase.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "t", "type": "type t = bytes", "docs": "<p>An alias for the type of byte sequences.</p>\n", "kind": "type"}, {"path": "Bytes", "name": "compare", "type": "let compare: (t, t) => int", "docs": "<p>The comparison function for byte sequences, with the same specification as compare. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Bytes</code> to be passed as argument to the functors Make and Make.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Bytes", "name": "unsafe_to_string", "type": "let unsafe_to_string: bytes => string", "docs": "<p>Unsafely convert a byte sequence into a string.</p>\n<p>To reason about the use of <code>unsafe_to_string</code>, it is convenient to consider an &quot;ownership&quot; discipline. A piece of code that manipulates some data &quot;owns&quot; it; there are several disjoint ownership modes, including:</p>\n<ul><li><p>Unique ownership: the data may be accessed and mutated</p>\n</li><li><p>Shared ownership: the data has several owners, that may only access it, not mutate it.</p>\n</li></ul><p>Unique ownership is linear: passing the data to another piece of code means giving up ownership (we cannot write the data again). A unique owner may decide to make the data shared (giving up mutation rights on it), but shared data may not become uniquely-owned again.</p>\n<p><code>unsafe_to_string s</code> can only be used when the caller owns the byte sequence <code>s</code> -- either uniquely or as shared immutable data. The caller gives up ownership of <code>s</code>, and gains ownership of the returned string.</p>\n<p>There are two valid use-cases that respect this ownership discipline:</p>\n<p>1. Creating a string by initializing and mutating a byte sequence that is never changed after initialization is performed.</p>\n<pre class='ml'><code class='ml'>let string_init len f : string =\n  let s = Bytes.create len in\n  for i = 0 to len - 1 do Bytes.set s i (f i) done;\n  Bytes.unsafe_to_string s</code></pre><p>This function is safe because the byte sequence <code>s</code> will never be accessed or mutated after <code>unsafe_to_string</code> is called. The <code>string_init</code> code gives up ownership of <code>s</code>, and returns the ownership of the resulting string to its caller.</p>\n<p>Note that it would be unsafe if <code>s</code> was passed as an additional parameter to the function <code>f</code> as it could escape this way and be mutated in the future -- <code>string_init</code> would give up ownership of <code>s</code> to pass it to <code>f</code>, and could not call <code>unsafe_to_string</code> safely.</p>\n<p>We have provided the init, map and mapi functions to cover most cases of building new strings. You should prefer those over <code>to_string</code> or <code>unsafe_to_string</code> whenever applicable.</p>\n<p>2. Temporarily giving ownership of a byte sequence to a function that expects a uniquely owned string and returns ownership back, so that we can mutate the sequence again after the call ended.</p>\n<pre class='ml'><code class='ml'>let bytes_length (s : bytes) =\n  String.length (Bytes.unsafe_to_string s)</code></pre><p>In this use-case, we do not promise that <code>s</code> will never be mutated after the call to <code>bytes_length s</code>. The length function temporarily borrows unique ownership of the byte sequence (and sees it as a <code>string</code>), but returns this ownership back to the caller, which may assume that <code>s</code> is still a valid byte sequence after the call. Note that this is only correct because we know that length does not capture its argument -- it could escape by a side-channel such as a memoization combinator.</p>\n<p>The caller may not mutate <code>s</code> while the string is borrowed (it has temporarily given up ownership). This affects concurrent programs, but also higher-order functions: if <code>String.length</code> returned a closure to be called later, <code>s</code> should not be mutated until this closure is fully applied and returns ownership.</p>\n", "kind": "value", "args": [["", "bytes"]]}, {"path": "Bytes", "name": "unsafe_of_string", "type": "let unsafe_of_string: string => bytes", "docs": "<p>Unsafely convert a shared string to a byte sequence that should not be mutated.</p>\n<p>The same ownership discipline that makes <code>unsafe_to_string</code> correct applies to <code>unsafe_of_string</code>: you may use it if you were the owner of the <code>string</code> value, and you will own the return <code>bytes</code> in the same mode.</p>\n<p>In practice, unique ownership of string values is extremely difficult to reason about correctly. You should always assume strings are shared, never uniquely owned.</p>\n<p>For example, string literals are implicitly shared by the compiler, so you never uniquely own them.</p>\n<pre class='ml'><code class='ml'>let incorrect = Bytes.unsafe_of_string &quot;hello&quot;\nlet s = Bytes.of_string &quot;hello&quot;</code></pre><p>The first declaration is incorrect, because the string literal <code>&quot;hello&quot;</code> could be shared by the compiler with other parts of the program, and mutating <code>incorrect</code> is a bug. You must always use the second version, which performs a copy and is thus correct.</p>\n<p>Assuming unique ownership of strings that are not string literals, but are (partly) built from string literals, is also incorrect. For example, mutating <code>unsafe_of_string (&quot;foo&quot; ^ s)</code> could mutate the shared string <code>&quot;foo&quot;</code> -- assuming a rope-like representation of strings. More generally, functions operating on strings will assume shared ownership, they do not preserve unique ownership. It is thus incorrect to assume unique ownership of the result of <code>unsafe_of_string</code>.</p>\n<p>The only case we have reasonable confidence is safe is if the produced <code>bytes</code> is shared -- used as an immutable byte sequence. This is possibly useful for incremental migration of low-level programs that manipulate immutable sequences of bytes (for example from_bytes) and previously used the <code>string</code> type for this purpose.</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Bytes", "name": "unsafe_get", "type": "let unsafe_get: (bytes, int) => char", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"]]}, {"path": "Bytes", "name": "unsafe_set", "type": "let unsafe_set: (bytes, int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "char"]]}, {"path": "Bytes", "name": "unsafe_blit", "type": "let unsafe_blit: (bytes, int, bytes, int, int) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Bytes", "name": "unsafe_fill", "type": "let unsafe_fill: (bytes, int, int, char) => unit", "docs": null, "kind": "value", "args": [["", "bytes"], ["", "int"], ["", "int"], ["", "char"]]}, {"path": "", "name": "Bytes", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>capitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>compare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>escaped\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>extend\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lowercase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rcontains_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rindex_from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uncapitalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_of_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_to_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>uppercase\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Buffer", "name": "t", "type": "type t", "docs": "<p>The abstract type of buffers.</p>\n", "kind": "type"}, {"path": "Buffer", "name": "create", "type": "let create: int => t", "docs": "<p><code>create n</code> returns a fresh buffer, initially empty. The <code>n</code> parameter is the initial size of the internal byte sequence that holds the buffer contents. That byte sequence is automatically reallocated when more than <code>n</code> characters are stored in the buffer, but shrinks back to <code>n</code> characters when <code>reset</code> is called. For best performance, <code>n</code> should be of the same order of magnitude as the number of characters that are expected to be stored in the buffer (for instance, 80 for a buffer that holds one output line). Nothing bad will happen if the buffer grows beyond that limit, however. In doubt, take <code>n = 16</code> for instance. If <code>n</code> is not between 1 and max_string_length, it will be clipped to that interval.</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Buffer", "name": "contents", "type": "let contents: t => string", "docs": "<p>Return a copy of the current contents of the buffer. The buffer itself is unchanged.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Buffer", "name": "to_bytes", "type": "let to_bytes: t => bytes", "docs": "<p>Return a copy of the current contents of the buffer. The buffer itself is unchanged.</p>\nSince: 4.02", "kind": "value", "args": [["", "t"]]}, {"path": "Buffer", "name": "sub", "type": "let sub: (t, int, int) => string", "docs": "<p><code>Buffer.sub b off len</code> returns (a copy of) the bytes from the current contents of the buffer <code>b</code> starting at offset <code>off</code> of length <code>len</code> bytes. May raise <code>Invalid_argument</code> if out of bounds request. The buffer itself is unaffected.</p>\n", "kind": "value", "args": [["", "t"], ["", "int"], ["", "int"]]}, {"path": "Buffer", "name": "blit", "type": "let blit: (t, int, bytes, int, int) => unit", "docs": "<p><code>Buffer.blit src srcoff dst dstoff len</code> copies <code>len</code> characters from the current contents of the buffer <code>src</code>, starting at offset <code>srcoff</code> to <code>dst</code>, starting at character <code>dstoff</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p>\nSince: 3.11.2", "kind": "value", "args": [["", "t"], ["", "int"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Buffer", "name": "nth", "type": "let nth: (t, int) => char", "docs": "<p>get the n-th character of the buffer. Raise <code>Invalid_argument</code> if index out of bounds</p>\n", "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Buffer", "name": "length", "type": "let length: t => int", "docs": "<p>Return the number of characters currently contained in the buffer.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Buffer", "name": "clear", "type": "let clear: t => unit", "docs": "<p>Empty the buffer.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Buffer", "name": "reset", "type": "let reset: t => unit", "docs": "<p>Empty the buffer and deallocate the internal byte sequence holding the buffer contents, replacing it with the initial internal byte sequence of length <code>n</code> that was allocated by create <code>n</code>. For long-lived buffers that may have grown a lot, <code>reset</code> allows faster reclamation of the space used by the buffer.</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Buffer", "name": "add_char", "type": "let add_char: (t, char) => unit", "docs": "<p><code>add_char b c</code> appends the character <code>c</code> at the end of the buffer <code>b</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "char"]]}, {"path": "Buffer", "name": "add_string", "type": "let add_string: (t, string) => unit", "docs": "<p><code>add_string b s</code> appends the string <code>s</code> at the end of the buffer <code>b</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "string"]]}, {"path": "Buffer", "name": "add_bytes", "type": "let add_bytes: (t, bytes) => unit", "docs": "<p><code>add_string b s</code> appends the string <code>s</code> at the end of the buffer <code>b</code>.</p>\nSince: 4.02", "kind": "value", "args": [["", "t"], ["", "bytes"]]}, {"path": "Buffer", "name": "add_substring", "type": "let add_substring: (t, string, int, int) => unit", "docs": "<p><code>add_substring b s ofs len</code> takes <code>len</code> characters from offset <code>ofs</code> in string <code>s</code> and appends them at the end of the buffer <code>b</code>.</p>\n", "kind": "value", "args": [["", "t"], ["", "string"], ["", "int"], ["", "int"]]}, {"path": "Buffer", "name": "add_subbytes", "type": "let add_subbytes: (t, bytes, int, int) => unit", "docs": "<p><code>add_substring b s ofs len</code> takes <code>len</code> characters from offset <code>ofs</code> in byte sequence <code>s</code> and appends them at the end of the buffer <code>b</code>.</p>\nSince: 4.02", "kind": "value", "args": [["", "t"], ["", "bytes"], ["", "int"], ["", "int"]]}, {"path": "Buffer", "name": "add_substitute", "type": "let add_substitute: (t, string => string, string) => unit", "docs": "<p><code>add_substitute b f s</code> appends the string pattern <code>s</code> at the end of the buffer <code>b</code> with substitution. The substitution process looks for variables into the pattern and substitutes each variable name by its value, as obtained by applying the mapping <code>f</code> to the variable name. Inside the string pattern, a variable name immediately follows a non-escaped <code>$</code> character and is one of the following:</p>\n<ul><li><p>a non empty sequence of alphanumeric or <code>_</code> characters,</p>\n</li><li><p>an arbitrary sequence of characters enclosed by a pair of matching parentheses or curly brackets. An escaped <code>$</code> character is a <code>$</code> that immediately follows a backslash character; it then stands for a plain <code>$</code>. Raise <code>Not_found</code> if the closing character of a parenthesized variable cannot be found.</p>\n</li></ul>", "kind": "value", "args": [["", "t"], ["", "string => string"], ["", "string"]]}, {"path": "Buffer", "name": "add_buffer", "type": "let add_buffer: (t, t) => unit", "docs": "<p><code>add_buffer b1 b2</code> appends the current contents of buffer <code>b2</code> at the end of buffer <code>b1</code>. <code>b2</code> is not modified.</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Buffer", "name": "add_channel", "type": "let add_channel: (t, Pervasives.in_channel, int) => unit", "docs": "<p><code>add_channel b ic n</code> reads exactly <code>n</code> character from the input channel <code>ic</code> and stores them at the end of buffer <code>b</code>. Raise <code>End_of_file</code> if the channel contains fewer than <code>n</code> characters.</p>\n", "kind": "value", "args": [["", "t"], ["", "Pervasives.in_channel"], ["", "int"]]}, {"path": "Buffer", "name": "output_buffer", "type": "let output_buffer: (Pervasives.out_channel, t) => unit", "docs": "<p><code>output_buffer oc b</code> writes the current contents of buffer <code>b</code> on the output channel <code>oc</code>.</p>\n", "kind": "value", "args": [["", "Pervasives.out_channel"], ["", "t"]]}, {"path": "", "name": "Buffer", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_buffer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_bytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_channel\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_subbytes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_substitute\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>add_substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>contents\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>output_buffer\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_bytes\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Bigarray", "name": "float32_elt", "type": "type float32_elt = | Float32_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "float64_elt", "type": "type float64_elt = | Float64_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "int8_signed_elt", "type": "type int8_signed_elt = | Int8_signed_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "int8_unsigned_elt", "type": "type int8_unsigned_elt = | Int8_unsigned_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "int16_signed_elt", "type": "type int16_signed_elt = | Int16_signed_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "int16_unsigned_elt", "type": "type int16_unsigned_elt = | Int16_unsigned_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "int32_elt", "type": "type int32_elt = | Int32_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "int64_elt", "type": "type int64_elt = | Int64_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "int_elt", "type": "type int_elt = | Int_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "nativeint_elt", "type": "type nativeint_elt = | Nativeint_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "complex32_elt", "type": "type complex32_elt = | Complex32_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "complex64_elt", "type": "type complex64_elt = | Complex64_elt\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "kind", "type": "type kind('a, 'b) = \n  | Float32: kind(float, float32_elt)\n  | Float64: kind(float, float64_elt)\n  | Int8_signed: kind(int, int8_signed_elt)\n  | Int8_unsigned: kind(int, int8_unsigned_elt)\n  | Int16_signed: kind(int, int16_signed_elt)\n  | Int16_unsigned: kind(int, int16_unsigned_elt)\n  | Int32: kind(int32, int32_elt)\n  | Int64: kind(int64, int64_elt)\n  | Int: kind(int, int_elt)\n  | Nativeint: kind(nativeint, nativeint_elt)\n  | Complex32: kind(Complex.t, complex32_elt)\n  | Complex64: kind(Complex.t, complex64_elt)\n  | Char: kind(char, int8_unsigned_elt)\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "float32", "type": "let float32: kind(float, float32_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "float64", "type": "let float64: kind(float, float64_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "complex32", "type": "let complex32: kind(Complex.t, complex32_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "complex64", "type": "let complex64: kind(Complex.t, complex64_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "int8_signed", "type": "let int8_signed: kind(int, int8_signed_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "int8_unsigned", "type": "let int8_unsigned: kind(int, int8_unsigned_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "int16_signed", "type": "let int16_signed: kind(int, int16_signed_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "int16_unsigned", "type": "let int16_unsigned: kind(int, int16_unsigned_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "int", "type": "let int: kind(int, int_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "int32", "type": "let int32: kind(int32, int32_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "int64", "type": "let int64: kind(int64, int64_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "nativeint", "type": "let nativeint: kind(nativeint, nativeint_elt)", "docs": "<p>See char.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "char", "type": "let char: kind(char, int8_unsigned_elt)", "docs": "<p>As shown by the types of the values above, big arrays of kind <code>float32_elt</code> and <code>float64_elt</code> are accessed using the OCaml type <code>float</code>. Big arrays of complex kinds <code>complex32_elt</code>, <code>complex64_elt</code> are accessed with the OCaml type t. Big arrays of integer kinds are accessed using the smallest OCaml integer type large enough to represent the array elements: <code>int</code> for 8- and 16-bit integer bigarrays, as well as OCaml-integer bigarrays; <code>int32</code> for 32-bit integer bigarrays; <code>int64</code> for 64-bit integer bigarrays; and <code>nativeint</code> for platform-native integer bigarrays. Finally, big arrays of kind <code>int8_unsigned_elt</code> can also be accessed as arrays of characters instead of arrays of small integers, by using the kind value <code>char</code> instead of <code>int8_unsigned</code>.</p>\n", "kind": "value"}, {"path": "Bigarray", "name": "c_layout", "type": "type c_layout = | C_layout_typ\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "fortran_layout", "type": "type fortran_layout = | Fortran_layout_typ\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "layout", "type": "type layout('a) = | C_layout: layout(c_layout) | Fortran_layout: layout(fortran_layout)\n", "docs": null, "kind": "type"}, {"path": "Bigarray", "name": "c_layout", "type": "let c_layout: layout(c_layout)", "docs": null, "kind": "value"}, {"path": "Bigarray", "name": "fortran_layout", "type": "let fortran_layout: layout(fortran_layout)", "docs": null, "kind": "value"}, {"path": "Bigarray.Genarray", "name": "t", "type": "type t('a, 'b, 'c)", "docs": "<p>The type <code>Genarray.t</code> is the type of big arrays with variable numbers of dimensions. Any number of dimensions between 1 and 16 is supported.</p>\n<p>The three type parameters to <code>Genarray.t</code> identify the array element kind and layout, as follows:</p>\n<ul><li><p>the first parameter, <code>&#39;a</code>, is the OCaml type for accessing array elements (<code>float</code>, <code>int</code>, <code>int32</code>, <code>int64</code>, <code>nativeint</code>);</p>\n</li><li><p>the second parameter, <code>&#39;b</code>, is the actual kind of array elements (<code>float32_elt</code>, <code>float64_elt</code>, <code>int8_signed_elt</code>, <code>int8_unsigned_elt</code>, etc);</p>\n</li><li><p>the third parameter, <code>&#39;c</code>, identifies the array layout (<code>c_layout</code> or <code>fortran_layout</code>).</p>\n</li></ul><p>For instance, <code>(float, float32_elt, fortran_layout) Genarray.t</code> is the type of generic big arrays containing 32-bit floats in Fortran layout; reads and writes in this array use the OCaml type <code>float</code>.</p>\n", "kind": "type"}, {"path": "Bigarray.Genarray", "name": "create", "type": "let create: (kind('a, 'b), layout('c), array(int)) => t('a, 'b, 'c)", "docs": "<p><code>Genarray.create kind layout dimensions</code> returns a new big array whose element kind is determined by the parameter <code>kind</code> (one of <code>float32</code>, <code>float64</code>, <code>int8_signed</code>, etc) and whose layout is determined by the parameter <code>layout</code> (one of <code>c_layout</code> or <code>fortran_layout</code>). The <code>dimensions</code> parameter is an array of integers that indicate the size of the big array in each dimension. The length of <code>dimensions</code> determines the number of dimensions of the bigarray.</p>\n<p>For instance, <code>Genarray.create int32 c_layout [|4;6;8|]</code> returns a fresh big array of 32-bit integers, in C layout, having three dimensions, the three dimensions being 4, 6 and 8 respectively.</p>\n<p>Big arrays returned by <code>Genarray.create</code> are not initialized: the initial values of array elements is unspecified.</p>\n<p><code>Genarray.create</code> raises <code>Invalid_argument</code> if the number of dimensions is not in the range 1 to 16 inclusive, or if one of the dimensions is negative.</p>\n", "kind": "value", "args": [["", "kind('a, 'b)"], ["", "layout('c)"], ["", "array(int)"]]}, {"path": "Bigarray.Genarray", "name": "num_dims", "type": "let num_dims: t('a, 'b, 'c) => int", "docs": "<p>Return the number of dimensions of the given big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Genarray", "name": "dims", "type": "let dims: t('a, 'b, 'c) => array(int)", "docs": "<p><code>Genarray.dims a</code> returns all dimensions of the big array <code>a</code>, as an array of integers of length <code>Genarray.num_dims a</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Genarray", "name": "nth_dim", "type": "let nth_dim: (t('a, 'b, 'c), int) => int", "docs": "<p><code>Genarray.nth_dim a n</code> returns the <code>n</code>-th dimension of the big array <code>a</code>. The first dimension corresponds to <code>n = 0</code>; the second dimension corresponds to <code>n = 1</code>; the last dimension, to <code>n = Genarray.num_dims a - 1</code>. Raise <code>Invalid_argument</code> if <code>n</code> is less than 0 or greater or equal than <code>Genarray.num_dims a</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"]]}, {"path": "Bigarray.Genarray", "name": "kind", "type": "let kind: t('a, 'b, 'c) => kind('a, 'b)", "docs": "<p>Return the kind of the given big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Genarray", "name": "layout", "type": "let layout: t('a, 'b, 'c) => layout('c)", "docs": "<p>Return the layout of the given big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Genarray", "name": "get", "type": "let get: (t('a, 'b, 'c), array(int)) => 'a", "docs": "<p>Read an element of a generic big array. <code>Genarray.get a [|i1; ...; iN|]</code> returns the element of <code>a</code> whose coordinates are <code>i1</code> in the first dimension, <code>i2</code> in the second dimension, ..., <code>iN</code> in the <code>N</code>-th dimension.</p>\n<p>If <code>a</code> has C layout, the coordinates must be greater or equal than 0 and strictly less than the corresponding dimensions of <code>a</code>. If <code>a</code> has Fortran layout, the coordinates must be greater or equal than 1 and less or equal than the corresponding dimensions of <code>a</code>. Raise <code>Invalid_argument</code> if the array <code>a</code> does not have exactly <code>N</code> dimensions, or if the coordinates are outside the array bounds.</p>\n<p>If <code>N &gt; 3</code>, alternate syntax is provided: you can write <code>a.{i1, i2, ..., iN}</code> instead of <code>Genarray.get a [|i1; ...; iN|]</code>. (The syntax <code>a.{...}</code> with one, two or three coordinates is reserved for accessing one-, two- and three-dimensional arrays as described below.)</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "array(int)"]]}, {"path": "Bigarray.Genarray", "name": "set", "type": "let set: (t('a, 'b, 'c), array(int), 'a) => unit", "docs": "<p>Assign an element of a generic big array. <code>Genarray.set a [|i1; ...; iN|] v</code> stores the value <code>v</code> in the element of <code>a</code> whose coordinates are <code>i1</code> in the first dimension, <code>i2</code> in the second dimension, ..., <code>iN</code> in the <code>N</code>-th dimension.</p>\n<p>The array <code>a</code> must have exactly <code>N</code> dimensions, and all coordinates must lie inside the array bounds, as described for <code>Genarray.get</code>; otherwise, <code>Invalid_argument</code> is raised.</p>\n<p>If <code>N &gt; 3</code>, alternate syntax is provided: you can write <code>a.{i1, i2, ..., iN} &lt;- v</code> instead of <code>Genarray.set a [|i1; ...; iN|] v</code>. (The syntax <code>a.{...} &lt;- v</code> with one, two or three coordinates is reserved for updating one-, two- and three-dimensional arrays as described below.)</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "array(int)"], ["", "'a"]]}, {"path": "Bigarray.Genarray", "name": "sub_left", "type": "let sub_left: (t('a, 'b, c_layout), int, int) => t('a, 'b, c_layout)", "docs": "<p>Extract a sub-array of the given big array by restricting the first (left-most) dimension. <code>Genarray.sub_left a ofs len</code> returns a big array with the same number of dimensions as <code>a</code>, and the same dimensions as <code>a</code>, except the first dimension, which corresponds to the interval <code>[ofs ... ofs + len - 1]</code> of the first dimension of <code>a</code>. No copying of elements is involved: the sub-array and the original array share the same storage space. In other terms, the element at coordinates <code>[|i1; ...; iN|]</code> of the sub-array is identical to the element at coordinates <code>[|i1+ofs; ...; iN|]</code> of the original array <code>a</code>.</p>\n<p><code>Genarray.sub_left</code> applies only to big arrays in C layout. Raise <code>Invalid_argument</code> if <code>ofs</code> and <code>len</code> do not designate a valid sub-array of <code>a</code>, that is, if <code>ofs &lt; 0</code>, or <code>len &lt; 0</code>, or <code>ofs + len &gt; Genarray.nth_dim a 0</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b, c_layout)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Genarray", "name": "sub_right", "type": "let sub_right: (t('a, 'b, fortran_layout), int, int) => t('a, 'b, fortran_layout)", "docs": "<p>Extract a sub-array of the given big array by restricting the last (right-most) dimension. <code>Genarray.sub_right a ofs len</code> returns a big array with the same number of dimensions as <code>a</code>, and the same dimensions as <code>a</code>, except the last dimension, which corresponds to the interval <code>[ofs ... ofs + len - 1]</code> of the last dimension of <code>a</code>. No copying of elements is involved: the sub-array and the original array share the same storage space. In other terms, the element at coordinates <code>[|i1; ...; iN|]</code> of the sub-array is identical to the element at coordinates <code>[|i1; ...; iN+ofs|]</code> of the original array <code>a</code>.</p>\n<p><code>Genarray.sub_right</code> applies only to big arrays in Fortran layout. Raise <code>Invalid_argument</code> if <code>ofs</code> and <code>len</code> do not designate a valid sub-array of <code>a</code>, that is, if <code>ofs &lt; 1</code>, or <code>len &lt; 0</code>, or <code>ofs + len &gt; Genarray.nth_dim a (Genarray.num_dims a - 1)</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b, fortran_layout)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Genarray", "name": "slice_left", "type": "let slice_left: (t('a, 'b, c_layout), array(int)) => t('a, 'b, c_layout)", "docs": "<p>Extract a sub-array of lower dimension from the given big array by fixing one or several of the first (left-most) coordinates. <code>Genarray.slice_left a [|i1; ... ; iM|]</code> returns the &#39;slice&#39; of <code>a</code> obtained by setting the first <code>M</code> coordinates to <code>i1</code>, ..., <code>iM</code>. If <code>a</code> has <code>N</code> dimensions, the slice has dimension <code>N - M</code>, and the element at coordinates <code>[|j1; ...; j(N-M)|]</code> in the slice is identical to the element at coordinates <code>[|i1; ...; iM; j1; ...; j(N-M)|]</code> in the original array <code>a</code>. No copying of elements is involved: the slice and the original array share the same storage space.</p>\n<p><code>Genarray.slice_left</code> applies only to big arrays in C layout. Raise <code>Invalid_argument</code> if <code>M &gt;= N</code>, or if <code>[|i1; ... ; iM|]</code> is outside the bounds of <code>a</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b, c_layout)"], ["", "array(int)"]]}, {"path": "Bigarray.Genarray", "name": "slice_right", "type": "let slice_right: (t('a, 'b, fortran_layout), array(int)) => t('a, 'b, fortran_layout)", "docs": "<p>Extract a sub-array of lower dimension from the given big array by fixing one or several of the last (right-most) coordinates. <code>Genarray.slice_right a [|i1; ... ; iM|]</code> returns the &#39;slice&#39; of <code>a</code> obtained by setting the last <code>M</code> coordinates to <code>i1</code>, ..., <code>iM</code>. If <code>a</code> has <code>N</code> dimensions, the slice has dimension <code>N - M</code>, and the element at coordinates <code>[|j1; ...; j(N-M)|]</code> in the slice is identical to the element at coordinates <code>[|j1; ...; j(N-M); i1; ...; iM|]</code> in the original array <code>a</code>. No copying of elements is involved: the slice and the original array share the same storage space.</p>\n<p><code>Genarray.slice_right</code> applies only to big arrays in Fortran layout. Raise <code>Invalid_argument</code> if <code>M &gt;= N</code>, or if <code>[|i1; ... ; iM|]</code> is outside the bounds of <code>a</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b, fortran_layout)"], ["", "array(int)"]]}, {"path": "Bigarray.Genarray", "name": "blit", "type": "let blit: (t('a, 'b, 'c), t('a, 'b, 'c)) => unit", "docs": "<p>Copy all elements of a big array in another big array. <code>Genarray.blit src dst</code> copies all elements of <code>src</code> into <code>dst</code>. Both arrays <code>src</code> and <code>dst</code> must have the same number of dimensions and equal dimensions. Copying a sub-array of <code>src</code> to a sub-array of <code>dst</code> can be achieved by applying <code>Genarray.blit</code> to sub-array or slices of <code>src</code> and <code>dst</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Genarray", "name": "fill", "type": "let fill: (t('a, 'b, 'c), 'a) => unit", "docs": "<p>Set all elements of a big array to a given value. <code>Genarray.fill a v</code> stores the value <code>v</code> in all elements of the big array <code>a</code>. Setting only some elements of <code>a</code> to <code>v</code> can be achieved by applying <code>Genarray.fill</code> to a sub-array or a slice of <code>a</code>.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "'a"]]}, {"path": "Bigarray.Genarray", "name": "map_file", "type": "let map_file: (\n  Unix.file_descr,\n  ~?pos: option(int64),\n  kind('a, 'b),\n  layout('c),\n  bool,\n  array(int)\n) => t('a, 'b, 'c)", "docs": "<p>Memory mapping of a file as a big array. <code>Genarray.map_file fd kind layout shared dims</code> returns a big array of kind <code>kind</code>, layout <code>layout</code>, and dimensions as specified in <code>dims</code>. The data contained in this big array are the contents of the file referred to by the file descriptor <code>fd</code> (as opened previously with <code>Unix.openfile</code>, for example). The optional <code>pos</code> parameter is the byte offset in the file of the data being mapped; it defaults to 0 (map from the beginning of the file).</p>\n<p>If <code>shared</code> is <code>true</code>, all modifications performed on the array are reflected in the file. This requires that <code>fd</code> be opened with write permissions. If <code>shared</code> is <code>false</code>, modifications performed on the array are done in memory only, using copy-on-write of the modified pages; the underlying file is not affected.</p>\n<p><code>Genarray.map_file</code> is much more efficient than reading the whole file in a big array, modifying that big array, and writing it afterwards.</p>\n<p>To adjust automatically the dimensions of the big array to the actual size of the file, the major dimension (that is, the first dimension for an array with C layout, and the last dimension for an array with Fortran layout) can be given as <code>-1</code>. <code>Genarray.map_file</code> then determines the major dimension from the size of the file. The file must contain an integral number of sub-arrays as determined by the non-major dimensions, otherwise <code>Failure</code> is raised.</p>\n<p>If all dimensions of the big array are given, the file size is matched against the size of the big array. If the file is larger than the big array, only the initial portion of the file is mapped to the big array. If the file is smaller than the big array, the file is automatically grown to the size of the big array. This requires write permissions on <code>fd</code>.</p>\n<p>Array accesses are bounds-checked, but the bounds are determined by the initial call to <code>map_file</code>. Therefore, you should make sure no other process modifies the mapped file while you&#39;re accessing it, or a SIGBUS signal may be raised. This happens, for instance, if the file is shrunk.</p>\n<p>This function raises <code>Sys_error</code> in the case of any errors from the underlying system calls. <code>Invalid_argument</code> or <code>Failure</code> may be raised in cases where argument validation fails.</p>\n", "kind": "value", "args": [["", "Unix.file_descr"], ["pos", "int64 (optional)"], ["", "kind('a, 'b)"], ["", "layout('c)"], ["", "bool"], ["", "array(int)"]]}, {"path": "Bigarray", "name": "Genarray", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dims\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kind\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>layout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map_file\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nth_dim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>num_dims\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_right\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Bigarray.Array1", "name": "t", "type": "type t('a, 'b, 'c)", "docs": "<p>The type of one-dimensional big arrays whose elements have OCaml type <code>&#39;a</code>, representation kind <code>&#39;b</code>, and memory layout <code>&#39;c</code>.</p>\n", "kind": "type"}, {"path": "Bigarray.Array1", "name": "create", "type": "let create: (kind('a, 'b), layout('c), int) => t('a, 'b, 'c)", "docs": "<p><code>Array1.create kind layout dim</code> returns a new bigarray of one dimension, whose size is <code>dim</code>. <code>kind</code> and <code>layout</code> determine the array element kind and the array layout as described for <code>Genarray.create</code>.</p>\n", "kind": "value", "args": [["", "kind('a, 'b)"], ["", "layout('c)"], ["", "int"]]}, {"path": "Bigarray.Array1", "name": "dim", "type": "let dim: t('a, 'b, 'c) => int", "docs": "<p>Return the size (dimension) of the given one-dimensional big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array1", "name": "kind", "type": "let kind: t('a, 'b, 'c) => kind('a, 'b)", "docs": "<p>Return the kind of the given big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array1", "name": "layout", "type": "let layout: t('a, 'b, 'c) => layout('c)", "docs": "<p>Return the layout of the given big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array1", "name": "get", "type": "let get: (t('a, 'b, 'c), int) => 'a", "docs": "<p><code>Array1.get a x</code>, or alternatively <code>a.{x}</code>, returns the element of <code>a</code> at index <code>x</code>. <code>x</code> must be greater or equal than <code>0</code> and strictly less than <code>Array1.dim a</code> if <code>a</code> has C layout. If <code>a</code> has Fortran layout, <code>x</code> must be greater or equal than <code>1</code> and less or equal than <code>Array1.dim a</code>. Otherwise, <code>Invalid_argument</code> is raised.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"]]}, {"path": "Bigarray.Array1", "name": "set", "type": "let set: (t('a, 'b, 'c), int, 'a) => unit", "docs": "<p><code>Array1.set a x v</code>, also written <code>a.{x} &lt;- v</code>, stores the value <code>v</code> at index <code>x</code> in <code>a</code>. <code>x</code> must be inside the bounds of <code>a</code> as described in get; otherwise, <code>Invalid_argument</code> is raised.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "'a"]]}, {"path": "Bigarray.Array1", "name": "sub", "type": "let sub: (t('a, 'b, 'c), int, int) => t('a, 'b, 'c)", "docs": "<p>Extract a sub-array of the given one-dimensional big array. See <code>Genarray.sub_left</code> for more details.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array1", "name": "blit", "type": "let blit: (t('a, 'b, 'c), t('a, 'b, 'c)) => unit", "docs": "<p>Copy the first big array to the second big array. See <code>Genarray.blit</code> for more details.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array1", "name": "fill", "type": "let fill: (t('a, 'b, 'c), 'a) => unit", "docs": "<p>Fill the given big array with the given value. See <code>Genarray.fill</code> for more details.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "'a"]]}, {"path": "Bigarray.Array1", "name": "of_array", "type": "let of_array: (kind('a, 'b), layout('c), array('a)) => t('a, 'b, 'c)", "docs": "<p>Build a one-dimensional big array initialized from the given array.</p>\n", "kind": "value", "args": [["", "kind('a, 'b)"], ["", "layout('c)"], ["", "array('a)"]]}, {"path": "Bigarray.Array1", "name": "map_file", "type": "let map_file: (Unix.file_descr, ~?pos: option(int64), kind('a, 'b), layout('c), bool, int) => t(\n  'a,\n  'b,\n  'c\n)", "docs": "<p>Memory mapping of a file as a one-dimensional big array. See map_file for more details.</p>\n", "kind": "value", "args": [["", "Unix.file_descr"], ["pos", "int64 (optional)"], ["", "kind('a, 'b)"], ["", "layout('c)"], ["", "bool"], ["", "int"]]}, {"path": "Bigarray.Array1", "name": "unsafe_get", "type": "let unsafe_get: (t('a, 'b, 'c), int) => 'a", "docs": "<p>Like get, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"]]}, {"path": "Bigarray.Array1", "name": "unsafe_set", "type": "let unsafe_set: (t('a, 'b, 'c), int, 'a) => unit", "docs": "<p>Like set, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "'a"]]}, {"path": "Bigarray", "name": "Array1", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kind\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>layout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map_file\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_array\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>One-dimensional arrays. The <code>Array1</code> structure provides operations similar to those of Genarray, but specialized to the case of one-dimensional arrays. (The <code>Array2</code> and <code>Array3</code> structures below provide operations specialized for two- and three-dimensional arrays.) Statically knowing the number of dimensions of the array allows faster operations, and more precise static type-checking.</p>\n", "kind": "module"}, {"path": "Bigarray.Array2", "name": "t", "type": "type t('a, 'b, 'c)", "docs": "<p>The type of two-dimensional big arrays whose elements have OCaml type <code>&#39;a</code>, representation kind <code>&#39;b</code>, and memory layout <code>&#39;c</code>.</p>\n", "kind": "type"}, {"path": "Bigarray.Array2", "name": "create", "type": "let create: (kind('a, 'b), layout('c), int, int) => t('a, 'b, 'c)", "docs": "<p><code>Array2.create kind layout dim1 dim2</code> returns a new bigarray of two dimension, whose size is <code>dim1</code> in the first dimension and <code>dim2</code> in the second dimension. <code>kind</code> and <code>layout</code> determine the array element kind and the array layout as described for create.</p>\n", "kind": "value", "args": [["", "kind('a, 'b)"], ["", "layout('c)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array2", "name": "dim1", "type": "let dim1: t('a, 'b, 'c) => int", "docs": "<p>Return the first dimension of the given two-dimensional big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array2", "name": "dim2", "type": "let dim2: t('a, 'b, 'c) => int", "docs": "<p>Return the second dimension of the given two-dimensional big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array2", "name": "kind", "type": "let kind: t('a, 'b, 'c) => kind('a, 'b)", "docs": "<p>Return the kind of the given big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array2", "name": "layout", "type": "let layout: t('a, 'b, 'c) => layout('c)", "docs": "<p>Return the layout of the given big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array2", "name": "get", "type": "let get: (t('a, 'b, 'c), int, int) => 'a", "docs": "<p><code>Array2.get a x y</code>, also written <code>a.{x,y}</code>, returns the element of <code>a</code> at coordinates (<code>x</code>, <code>y</code>). <code>x</code> and <code>y</code> must be within the bounds of <code>a</code>, as described for get; otherwise, <code>Invalid_argument</code> is raised.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array2", "name": "set", "type": "let set: (t('a, 'b, 'c), int, int, 'a) => unit", "docs": "<p><code>Array2.set a x y v</code>, or alternatively <code>a.{x,y} &lt;- v</code>, stores the value <code>v</code> at coordinates (<code>x</code>, <code>y</code>) in <code>a</code>. <code>x</code> and <code>y</code> must be within the bounds of <code>a</code>, as described for set; otherwise, <code>Invalid_argument</code> is raised.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "int"], ["", "'a"]]}, {"path": "Bigarray.Array2", "name": "sub_left", "type": "let sub_left: (t('a, 'b, c_layout), int, int) => t('a, 'b, c_layout)", "docs": "<p>Extract a two-dimensional sub-array of the given two-dimensional big array by restricting the first dimension. See sub_left for more details. <code>Array2.sub_left</code> applies only to arrays with C layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, c_layout)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array2", "name": "sub_right", "type": "let sub_right: (t('a, 'b, fortran_layout), int, int) => t('a, 'b, fortran_layout)", "docs": "<p>Extract a two-dimensional sub-array of the given two-dimensional big array by restricting the second dimension. See sub_right for more details. <code>Array2.sub_right</code> applies only to arrays with Fortran layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, fortran_layout)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array2", "name": "slice_left", "type": "let slice_left: (t('a, 'b, c_layout), int) => Array1.t('a, 'b, c_layout)", "docs": "<p>Extract a row (one-dimensional slice) of the given two-dimensional big array. The integer parameter is the index of the row to extract. See slice_left for more details. <code>Array2.slice_left</code> applies only to arrays with C layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, c_layout)"], ["", "int"]]}, {"path": "Bigarray.Array2", "name": "slice_right", "type": "let slice_right: (t('a, 'b, fortran_layout), int) => Array1.t('a, 'b, fortran_layout)", "docs": "<p>Extract a column (one-dimensional slice) of the given two-dimensional big array. The integer parameter is the index of the column to extract. See slice_right for more details. <code>Array2.slice_right</code> applies only to arrays with Fortran layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, fortran_layout)"], ["", "int"]]}, {"path": "Bigarray.Array2", "name": "blit", "type": "let blit: (t('a, 'b, 'c), t('a, 'b, 'c)) => unit", "docs": "<p>Copy the first big array to the second big array. See blit for more details.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array2", "name": "fill", "type": "let fill: (t('a, 'b, 'c), 'a) => unit", "docs": "<p>Fill the given big array with the given value. See fill for more details.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "'a"]]}, {"path": "Bigarray.Array2", "name": "of_array", "type": "let of_array: (kind('a, 'b), layout('c), array(array('a))) => t('a, 'b, 'c)", "docs": "<p>Build a two-dimensional big array initialized from the given array of arrays.</p>\n", "kind": "value", "args": [["", "kind('a, 'b)"], ["", "layout('c)"], ["", "array(array('a))"]]}, {"path": "Bigarray.Array2", "name": "map_file", "type": "let map_file: (\n  Unix.file_descr,\n  ~?pos: option(int64),\n  kind('a, 'b),\n  layout('c),\n  bool,\n  int,\n  int\n) => t('a, 'b, 'c)", "docs": "<p>Memory mapping of a file as a two-dimensional big array. See map_file for more details.</p>\n", "kind": "value", "args": [["", "Unix.file_descr"], ["pos", "int64 (optional)"], ["", "kind('a, 'b)"], ["", "layout('c)"], ["", "bool"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array2", "name": "unsafe_get", "type": "let unsafe_get: (t('a, 'b, 'c), int, int) => 'a", "docs": "<p>Like get, but bounds checking is not always performed.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array2", "name": "unsafe_set", "type": "let unsafe_set: (t('a, 'b, 'c), int, int, 'a) => unit", "docs": "<p>Like set, but bounds checking is not always performed.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "int"], ["", "'a"]]}, {"path": "Bigarray", "name": "Array2", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dim1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dim2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kind\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>layout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map_file\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_array\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Two-dimensional arrays. The <code>Array2</code> structure provides operations similar to those of Genarray, but specialized to the case of two-dimensional arrays.</p>\n", "kind": "module"}, {"path": "Bigarray.Array3", "name": "t", "type": "type t('a, 'b, 'c)", "docs": "<p>The type of three-dimensional big arrays whose elements have OCaml type <code>&#39;a</code>, representation kind <code>&#39;b</code>, and memory layout <code>&#39;c</code>.</p>\n", "kind": "type"}, {"path": "Bigarray.Array3", "name": "create", "type": "let create: (kind('a, 'b), layout('c), int, int, int) => t('a, 'b, 'c)", "docs": "<p><code>Array3.create kind layout dim1 dim2 dim3</code> returns a new bigarray of three dimension, whose size is <code>dim1</code> in the first dimension, <code>dim2</code> in the second dimension, and <code>dim3</code> in the third. <code>kind</code> and <code>layout</code> determine the array element kind and the array layout as described for create.</p>\n", "kind": "value", "args": [["", "kind('a, 'b)"], ["", "layout('c)"], ["", "int"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "dim1", "type": "let dim1: t('a, 'b, 'c) => int", "docs": "<p>Return the first dimension of the given three-dimensional big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array3", "name": "dim2", "type": "let dim2: t('a, 'b, 'c) => int", "docs": "<p>Return the second dimension of the given three-dimensional big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array3", "name": "dim3", "type": "let dim3: t('a, 'b, 'c) => int", "docs": "<p>Return the third dimension of the given three-dimensional big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array3", "name": "kind", "type": "let kind: t('a, 'b, 'c) => kind('a, 'b)", "docs": "<p>Return the kind of the given big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array3", "name": "layout", "type": "let layout: t('a, 'b, 'c) => layout('c)", "docs": "<p>Return the layout of the given big array.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array3", "name": "get", "type": "let get: (t('a, 'b, 'c), int, int, int) => 'a", "docs": "<p><code>Array3.get a x y z</code>, also written <code>a.{x,y,z}</code>, returns the element of <code>a</code> at coordinates (<code>x</code>, <code>y</code>, <code>z</code>). <code>x</code>, <code>y</code> and <code>z</code> must be within the bounds of <code>a</code>, as described for get; otherwise, <code>Invalid_argument</code> is raised.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "set", "type": "let set: (t('a, 'b, 'c), int, int, int, 'a) => unit", "docs": "<p><code>Array3.set a x y v</code>, or alternatively <code>a.{x,y,z} &lt;- v</code>, stores the value <code>v</code> at coordinates (<code>x</code>, <code>y</code>, <code>z</code>) in <code>a</code>. <code>x</code>, <code>y</code> and <code>z</code> must be within the bounds of <code>a</code>, as described for set; otherwise, <code>Invalid_argument</code> is raised.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "int"], ["", "int"], ["", "'a"]]}, {"path": "Bigarray.Array3", "name": "sub_left", "type": "let sub_left: (t('a, 'b, c_layout), int, int) => t('a, 'b, c_layout)", "docs": "<p>Extract a three-dimensional sub-array of the given three-dimensional big array by restricting the first dimension. See sub_left for more details. <code>Array3.sub_left</code> applies only to arrays with C layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, c_layout)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "sub_right", "type": "let sub_right: (t('a, 'b, fortran_layout), int, int) => t('a, 'b, fortran_layout)", "docs": "<p>Extract a three-dimensional sub-array of the given three-dimensional big array by restricting the second dimension. See sub_right for more details. <code>Array3.sub_right</code> applies only to arrays with Fortran layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, fortran_layout)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "slice_left_1", "type": "let slice_left_1: (t('a, 'b, c_layout), int, int) => Array1.t('a, 'b, c_layout)", "docs": "<p>Extract a one-dimensional slice of the given three-dimensional big array by fixing the first two coordinates. The integer parameters are the coordinates of the slice to extract. See slice_left for more details. <code>Array3.slice_left_1</code> applies only to arrays with C layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, c_layout)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "slice_right_1", "type": "let slice_right_1: (t('a, 'b, fortran_layout), int, int) => Array1.t('a, 'b, fortran_layout)", "docs": "<p>Extract a one-dimensional slice of the given three-dimensional big array by fixing the last two coordinates. The integer parameters are the coordinates of the slice to extract. See slice_right for more details. <code>Array3.slice_right_1</code> applies only to arrays with Fortran layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, fortran_layout)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "slice_left_2", "type": "let slice_left_2: (t('a, 'b, c_layout), int) => Array2.t('a, 'b, c_layout)", "docs": "<p>Extract a two-dimensional slice of the given three-dimensional big array by fixing the first coordinate. The integer parameter is the first coordinate of the slice to extract. See slice_left for more details. <code>Array3.slice_left_2</code> applies only to arrays with C layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, c_layout)"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "slice_right_2", "type": "let slice_right_2: (t('a, 'b, fortran_layout), int) => Array2.t('a, 'b, fortran_layout)", "docs": "<p>Extract a two-dimensional slice of the given three-dimensional big array by fixing the last coordinate. The integer parameter is the coordinate of the slice to extract. See slice_right for more details. <code>Array3.slice_right_2</code> applies only to arrays with Fortran layout.</p>\n", "kind": "value", "args": [["", "t('a, 'b, fortran_layout)"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "blit", "type": "let blit: (t('a, 'b, 'c), t('a, 'b, 'c)) => unit", "docs": "<p>Copy the first big array to the second big array. See blit for more details.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "t('a, 'b, 'c)"]]}, {"path": "Bigarray.Array3", "name": "fill", "type": "let fill: (t('a, 'b, 'c), 'a) => unit", "docs": "<p>Fill the given big array with the given value. See fill for more details.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "'a"]]}, {"path": "Bigarray.Array3", "name": "of_array", "type": "let of_array: (kind('a, 'b), layout('c), array(array(array('a)))) => t('a, 'b, 'c)", "docs": "<p>Build a three-dimensional big array initialized from the given array of arrays of arrays.</p>\n", "kind": "value", "args": [["", "kind('a, 'b)"], ["", "layout('c)"], ["", "array(array(array('a)))"]]}, {"path": "Bigarray.Array3", "name": "map_file", "type": "let map_file: (\n  Unix.file_descr,\n  ~?pos: option(int64),\n  kind('a, 'b),\n  layout('c),\n  bool,\n  int,\n  int,\n  int\n) => t('a, 'b, 'c)", "docs": "<p>Memory mapping of a file as a three-dimensional big array. See map_file for more details.</p>\n", "kind": "value", "args": [["", "Unix.file_descr"], ["pos", "int64 (optional)"], ["", "kind('a, 'b)"], ["", "layout('c)"], ["", "bool"], ["", "int"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "unsafe_get", "type": "let unsafe_get: (t('a, 'b, 'c), int, int, int) => 'a", "docs": "<p>Like get, but bounds checking is not always performed.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "int"], ["", "int"]]}, {"path": "Bigarray.Array3", "name": "unsafe_set", "type": "let unsafe_set: (t('a, 'b, 'c), int, int, int, 'a) => unit", "docs": "<p>Like set, but bounds checking is not always performed.</p>\n", "kind": "value", "args": [["", "t('a, 'b, 'c)"], ["", "int"], ["", "int"], ["", "int"], ["", "'a"]]}, {"path": "Bigarray", "name": "Array3", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dim1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dim2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>dim3\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>kind\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>layout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map_file\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_array\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_left_1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_left_2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_right_1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_right_2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Three-dimensional arrays. The <code>Array3</code> structure provides operations similar to those of Genarray, but specialized to the case of three-dimensional arrays.</p>\n", "kind": "module"}, {"path": "Bigarray", "name": "genarray_of_array1", "type": "let genarray_of_array1: Array1.t('a, 'b, 'c) => Genarray.t('a, 'b, 'c)", "docs": "<p>Return the generic big array corresponding to the given one-dimensional big array.</p>\n", "kind": "value", "args": [["", "Array1.t('a, 'b, 'c)"]]}, {"path": "Bigarray", "name": "genarray_of_array2", "type": "let genarray_of_array2: Array2.t('a, 'b, 'c) => Genarray.t('a, 'b, 'c)", "docs": "<p>Return the generic big array corresponding to the given two-dimensional big array.</p>\n", "kind": "value", "args": [["", "Array2.t('a, 'b, 'c)"]]}, {"path": "Bigarray", "name": "genarray_of_array3", "type": "let genarray_of_array3: Array3.t('a, 'b, 'c) => Genarray.t('a, 'b, 'c)", "docs": "<p>Return the generic big array corresponding to the given three-dimensional big array.</p>\n", "kind": "value", "args": [["", "Array3.t('a, 'b, 'c)"]]}, {"path": "Bigarray", "name": "array1_of_genarray", "type": "let array1_of_genarray: Genarray.t('a, 'b, 'c) => Array1.t('a, 'b, 'c)", "docs": "<p>Return the one-dimensional big array corresponding to the given generic big array. Raise <code>Invalid_argument</code> if the generic big array does not have exactly one dimension.</p>\n", "kind": "value", "args": [["", "Genarray.t('a, 'b, 'c)"]]}, {"path": "Bigarray", "name": "array2_of_genarray", "type": "let array2_of_genarray: Genarray.t('a, 'b, 'c) => Array2.t('a, 'b, 'c)", "docs": "<p>Return the two-dimensional big array corresponding to the given generic big array. Raise <code>Invalid_argument</code> if the generic big array does not have exactly two dimensions.</p>\n", "kind": "value", "args": [["", "Genarray.t('a, 'b, 'c)"]]}, {"path": "Bigarray", "name": "array3_of_genarray", "type": "let array3_of_genarray: Genarray.t('a, 'b, 'c) => Array3.t('a, 'b, 'c)", "docs": "<p>Return the three-dimensional big array corresponding to the given generic big array. Raise <code>Invalid_argument</code> if the generic big array does not have exactly three dimensions.</p>\n", "kind": "value", "args": [["", "Genarray.t('a, 'b, 'c)"]]}, {"path": "Bigarray", "name": "reshape", "type": "let reshape: (Genarray.t('a, 'b, 'c), array(int)) => Genarray.t('a, 'b, 'c)", "docs": "<p><code>reshape b [|d1;...;dN|]</code> converts the big array <code>b</code> to a <code>N</code>-dimensional array of dimensions <code>d1</code>...<code>dN</code>. The returned array and the original array <code>b</code> share their data and have the same layout. For instance, assuming that <code>b</code> is a one-dimensional array of dimension 12, <code>reshape b [|3;4|]</code> returns a two-dimensional array <code>b&#39;</code> of dimensions 3 and 4. If <code>b</code> has C layout, the element <code>(x,y)</code> of <code>b&#39;</code> corresponds to the element <code>x * 3 + y</code> of <code>b</code>. If <code>b</code> has Fortran layout, the element <code>(x,y)</code> of <code>b&#39;</code> corresponds to the element <code>x + (y - 1) * 4</code> of <code>b</code>. The returned big array must have exactly the same number of elements as the original big array <code>b</code>. That is, the product of the dimensions of <code>b</code> must be equal to <code>i1 * ... * iN</code>. Otherwise, <code>Invalid_argument</code> is raised.</p>\n", "kind": "value", "args": [["", "Genarray.t('a, 'b, 'c)"], ["", "array(int)"]]}, {"path": "Bigarray", "name": "reshape_1", "type": "let reshape_1: (Genarray.t('a, 'b, 'c), int) => Array1.t('a, 'b, 'c)", "docs": "<p>Specialized version of reshape for reshaping to one-dimensional arrays.</p>\n", "kind": "value", "args": [["", "Genarray.t('a, 'b, 'c)"], ["", "int"]]}, {"path": "Bigarray", "name": "reshape_2", "type": "let reshape_2: (Genarray.t('a, 'b, 'c), int, int) => Array2.t('a, 'b, 'c)", "docs": "<p>Specialized version of reshape for reshaping to two-dimensional arrays.</p>\n", "kind": "value", "args": [["", "Genarray.t('a, 'b, 'c)"], ["", "int"], ["", "int"]]}, {"path": "Bigarray", "name": "reshape_3", "type": "let reshape_3: (Genarray.t('a, 'b, 'c), int, int, int) => Array3.t('a, 'b, 'c)", "docs": "<p>Specialized version of reshape for reshaping to three-dimensional arrays.</p>\n", "kind": "value", "args": [["", "Genarray.t('a, 'b, 'c)"], ["", "int"], ["", "int"], ["", "int"]]}, {"path": "", "name": "Bigarray", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>array1_of_genarray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>array2_of_genarray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>array3_of_genarray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>c_layout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>char\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>complex32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>complex64\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>float32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>float64\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fortran_layout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>genarray_of_array1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>genarray_of_array2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>genarray_of_array3\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int16_signed\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int16_unsigned\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int64\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int8_signed\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>int8_unsigned\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nativeint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reshape\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reshape_1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reshape_2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reshape_3\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>c_layout\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>complex32_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>complex64_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>float32_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>float64_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>fortran_layout\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>int16_signed_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>int16_unsigned_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>int32_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>int64_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>int8_signed_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>int8_unsigned_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>int_elt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>kind\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>layout\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>nativeint_elt\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Array1\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Array2\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Array3\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Genarray", "docs": null, "kind": "module"}, {"path": "ArrayLabels", "name": "length", "type": "let length: array('a) => int", "docs": "<p>Return the length (number of elements) of the given array.</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "ArrayLabels", "name": "get", "type": "let get: (array('a), int) => 'a", "docs": "<p><code>ArrayLabels.get a n</code> returns the element number <code>n</code> of array <code>a</code>. The first element has number 0. The last element has number <code>ArrayLabels.length a - 1</code>. You can also write <code>a.(n)</code> instead of <code>ArrayLabels.get a n</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>(ArrayLabels.length a - 1)</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "ArrayLabels", "name": "set", "type": "let set: (array('a), int, 'a) => unit", "docs": "<p><code>ArrayLabels.set a n x</code> modifies array <code>a</code> in place, replacing element number <code>n</code> with <code>x</code>. You can also write <code>a.(n) &lt;- x</code> instead of <code>ArrayLabels.set a n x</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>ArrayLabels.length a - 1</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "ArrayLabels", "name": "make", "type": "let make: (int, 'a) => array('a)", "docs": "<p><code>ArrayLabels.make n x</code> returns a fresh array of length <code>n</code>, initialized with <code>x</code>. All the elements of this new array are initially physically equal to <code>x</code> (in the sense of the <code>==</code> predicate). Consequently, if <code>x</code> is mutable, it is shared among all elements of the array, and modifying <code>x</code> through one of the array entries will modify all other entries at the same time.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the value of <code>x</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "ArrayLabels", "name": "create", "type": "let create: (int, 'a) => array('a)", "docs": "<p>Deprecated: <p><code>ArrayLabels.create</code> is an alias for make.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "ArrayLabels", "name": "init", "type": "let init: (int, ~f: int => 'a) => array('a)", "docs": "<p><code>ArrayLabels.init n f</code> returns a fresh array of length <code>n</code>, with element number <code>i</code> initialized to the result of <code>f i</code>. In other terms, <code>ArrayLabels.init n f</code> tabulates the results of <code>f</code> applied to the integers <code>0</code> to <code>n-1</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the return type of <code>f</code> is <code>float</code>, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["", "int"], ["f", "int => 'a"]]}, {"path": "ArrayLabels", "name": "make_matrix", "type": "let make_matrix: (~dimx: int, ~dimy: int, 'a) => array(array('a))", "docs": "<p><code>ArrayLabels.make_matrix dimx dimy e</code> returns a two-dimensional array (an array of arrays) with first dimension <code>dimx</code> and second dimension <code>dimy</code>. All the elements of this new matrix are initially physically equal to <code>e</code>. The element (<code>x,y</code>) of a matrix <code>m</code> is accessed with the notation <code>m.(x).(y)</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>dimx</code> or <code>dimy</code> is negative or greater than <code>Sys.max_array_length</code>. If the value of <code>e</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["dimx", "int"], ["dimy", "int"], ["", "'a"]]}, {"path": "ArrayLabels", "name": "create_matrix", "type": "let create_matrix: (~dimx: int, ~dimy: int, 'a) => array(array('a))", "docs": "<p>Deprecated: <p><code>ArrayLabels.create_matrix</code> is an alias for make_matrix.</p></p>\n", "kind": "value", "args": [["dimx", "int"], ["dimy", "int"], ["", "'a"]]}, {"path": "ArrayLabels", "name": "append", "type": "let append: (array('a), array('a)) => array('a)", "docs": "<p><code>ArrayLabels.append v1 v2</code> returns a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"]]}, {"path": "ArrayLabels", "name": "concat", "type": "let concat: list(array('a)) => array('a)", "docs": "<p>Same as <code>ArrayLabels.append</code>, but concatenates a list of arrays.</p>\n", "kind": "value", "args": [["", "list(array('a))"]]}, {"path": "ArrayLabels", "name": "sub", "type": "let sub: (array('a), ~pos: int, ~len: int) => array('a)", "docs": "<p><code>ArrayLabels.sub a start len</code> returns a fresh array of length <code>len</code>, containing the elements number <code>start</code> to <code>start + len - 1</code> of array <code>a</code>.</p>\n<p>Raise <code>Invalid_argument &quot;Array.sub&quot;</code> if <code>start</code> and <code>len</code> do not designate a valid subarray of <code>a</code>; that is, if <code>start &lt; 0</code>, or <code>len &lt; 0</code>, or <code>start + len &gt; ArrayLabels.length a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["pos", "int"], ["len", "int"]]}, {"path": "ArrayLabels", "name": "copy", "type": "let copy: array('a) => array('a)", "docs": "<p><code>ArrayLabels.copy a</code> returns a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "ArrayLabels", "name": "fill", "type": "let fill: (array('a), ~pos: int, ~len: int, 'a) => unit", "docs": "<p><code>ArrayLabels.fill a ofs len x</code> modifies the array <code>a</code> in place, storing <code>x</code> in elements number <code>ofs</code> to <code>ofs + len - 1</code>.</p>\n<p>Raise <code>Invalid_argument &quot;Array.fill&quot;</code> if <code>ofs</code> and <code>len</code> do not designate a valid subarray of <code>a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["pos", "int"], ["len", "int"], ["", "'a"]]}, {"path": "ArrayLabels", "name": "blit", "type": "let blit: (~src: array('a), ~src_pos: int, ~dst: array('a), ~dst_pos: int, ~len: int) => unit", "docs": "<p><code>ArrayLabels.blit v1 o1 v2 o2 len</code> copies <code>len</code> elements from array <code>v1</code>, starting at element number <code>o1</code>, to array <code>v2</code>, starting at element number <code>o2</code>. It works correctly even if <code>v1</code> and <code>v2</code> are the same array, and the source and destination chunks overlap.</p>\n<p>Raise <code>Invalid_argument &quot;Array.blit&quot;</code> if <code>o1</code> and <code>len</code> do not designate a valid subarray of <code>v1</code>, or if <code>o2</code> and <code>len</code> do not designate a valid subarray of <code>v2</code>.</p>\n", "kind": "value", "args": [["src", "array('a)"], ["src_pos", "int"], ["dst", "array('a)"], ["dst_pos", "int"], ["len", "int"]]}, {"path": "ArrayLabels", "name": "to_list", "type": "let to_list: array('a) => list('a)", "docs": "<p><code>ArrayLabels.to_list a</code> returns the list of all the elements of <code>a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "ArrayLabels", "name": "of_list", "type": "let of_list: list('a) => array('a)", "docs": "<p><code>ArrayLabels.of_list l</code> returns a fresh array containing the elements of <code>l</code>.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "ArrayLabels", "name": "iter", "type": "let iter: (~f: 'a => unit, array('a)) => unit", "docs": "<p><code>ArrayLabels.iter f a</code> applies function <code>f</code> in turn to all the elements of <code>a</code>. It is equivalent to <code>f a.(0); f a.(1); ...; f a.(ArrayLabels.length a - 1); ()</code>.</p>\n", "kind": "value", "args": [["f", "'a => unit"], ["", "array('a)"]]}, {"path": "ArrayLabels", "name": "map", "type": "let map: (~f: 'a => 'b, array('a)) => array('b)", "docs": "<p><code>ArrayLabels.map f a</code> applies function <code>f</code> to all the elements of <code>a</code>, and builds an array with the results returned by <code>f</code>: <code>[| f a.(0); f a.(1); ...; f a.(ArrayLabels.length a - 1) |]</code>.</p>\n", "kind": "value", "args": [["f", "'a => 'b"], ["", "array('a)"]]}, {"path": "ArrayLabels", "name": "iteri", "type": "let iteri: (~f: (int, 'a) => unit, array('a)) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p>\n", "kind": "value", "args": [["f", "(int, 'a) => unit"], ["", "array('a)"]]}, {"path": "ArrayLabels", "name": "mapi", "type": "let mapi: (~f: (int, 'a) => 'b, array('a)) => array('b)", "docs": "<p>Same as map, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p>\n", "kind": "value", "args": [["f", "(int, 'a) => 'b"], ["", "array('a)"]]}, {"path": "ArrayLabels", "name": "fold_left", "type": "let fold_left: (~f: ('a, 'b) => 'a, ~init: 'a, array('b)) => 'a", "docs": "<p><code>ArrayLabels.fold_left f x a</code> computes <code>f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)</code>, where <code>n</code> is the length of the array <code>a</code>.</p>\n", "kind": "value", "args": [["f", "('a, 'b) => 'a"], ["init", "'a"], ["", "array('b)"]]}, {"path": "ArrayLabels", "name": "fold_right", "type": "let fold_right: (~f: ('b, 'a) => 'a, array('b), ~init: 'a) => 'a", "docs": "<p><code>ArrayLabels.fold_right f a x</code> computes <code>f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))</code>, where <code>n</code> is the length of the array <code>a</code>.</p>\n", "kind": "value", "args": [["f", "('b, 'a) => 'a"], ["", "array('b)"], ["init", "'a"]]}, {"path": "ArrayLabels", "name": "sort", "type": "let sort: (~cmp: ('a, 'a) => int, array('a)) => unit", "docs": "<p>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, compare is a suitable comparison function, provided there are no floating-point NaN values in the data. After calling <code>ArrayLabels.sort</code>, the array is sorted in place in increasing order. <code>ArrayLabels.sort</code> is guaranteed to run in constant heap space and (at most) logarithmic stack space.</p>\n<p>The current implementation uses Heap Sort. It runs in constant stack space.</p>\n<p>Specification of the comparison function: Let <code>a</code> be the array and <code>cmp</code> the comparison function. The following must be true for all x, y, z in a :</p>\n<ul><li><p><code>cmp x y</code> &gt; 0 if and only if <code>cmp y x</code> &lt; 0</p>\n</li><li><p>if <code>cmp x y</code> &gt;= 0 and <code>cmp y z</code> &gt;= 0 then <code>cmp x z</code> &gt;= 0</p>\n</li></ul><p>When <code>ArrayLabels.sort</code> returns, <code>a</code> contains the same elements as before, reordered in such a way that for all i and j valid indices of <code>a</code> :</p>\n<ul><li><p><code>cmp a.(i) a.(j)</code> &gt;= 0 if and only if i &gt;= j</p>\n</li></ul>", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "array('a)"]]}, {"path": "ArrayLabels", "name": "stable_sort", "type": "let stable_sort: (~cmp: ('a, 'a) => int, array('a)) => unit", "docs": "<p>Same as sort, but the sorting algorithm is stable (i.e. elements that compare equal are kept in their original order) and not guaranteed to run in constant heap space.</p>\n<p>The current implementation uses Merge Sort. It uses <code>n/2</code> words of heap space, where <code>n</code> is the length of the array. It is usually faster than the current implementation of sort.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "array('a)"]]}, {"path": "ArrayLabels", "name": "fast_sort", "type": "let fast_sort: (~cmp: ('a, 'a) => int, array('a)) => unit", "docs": "<p>Same as sort or stable_sort, whichever is faster on typical input.</p>\n", "kind": "value", "args": [["cmp", "('a, 'a) => int"], ["", "array('a)"]]}, {"path": "ArrayLabels", "name": "unsafe_get", "type": "let unsafe_get: (array('a), int) => 'a", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "ArrayLabels", "name": "unsafe_set", "type": "let unsafe_set: (array('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "", "name": "ArrayLabels", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_matrix\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fast_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_matrix\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_list\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stable_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_list\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set", "docs": null, "kind": "module"}, {"path": "Array", "name": "length", "type": "let length: array('a) => int", "docs": "<p>Return the length (number of elements) of the given array.</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Array", "name": "get", "type": "let get: (array('a), int) => 'a", "docs": "<p><code>Array.get a n</code> returns the element number <code>n</code> of array <code>a</code>. The first element has number 0. The last element has number <code>Array.length a - 1</code>. You can also write <code>a.(n)</code> instead of <code>Array.get a n</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>(Array.length a - 1)</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Array", "name": "set", "type": "let set: (array('a), int, 'a) => unit", "docs": "<p><code>Array.set a n x</code> modifies array <code>a</code> in place, replacing element number <code>n</code> with <code>x</code>. You can also write <code>a.(n) &lt;- x</code> instead of <code>Array.set a n x</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>Array.length a - 1</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "Array", "name": "make", "type": "let make: (int, 'a) => array('a)", "docs": "<p><code>Array.make n x</code> returns a fresh array of length <code>n</code>, initialized with <code>x</code>. All the elements of this new array are initially physically equal to <code>x</code> (in the sense of the <code>==</code> predicate). Consequently, if <code>x</code> is mutable, it is shared among all elements of the array, and modifying <code>x</code> through one of the array entries will modify all other entries at the same time.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the value of <code>x</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Array", "name": "create", "type": "let create: (int, 'a) => array('a)", "docs": "<p>Deprecated: <p><code>Array.create</code> is an alias for make.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Array", "name": "init", "type": "let init: (int, int => 'a) => array('a)", "docs": "<p><code>Array.init n f</code> returns a fresh array of length <code>n</code>, with element number <code>i</code> initialized to the result of <code>f i</code>. In other terms, <code>Array.init n f</code> tabulates the results of <code>f</code> applied to the integers <code>0</code> to <code>n-1</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the return type of <code>f</code> is <code>float</code>, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "int => 'a"]]}, {"path": "Array", "name": "make_matrix", "type": "let make_matrix: (int, int, 'a) => array(array('a))", "docs": "<p><code>Array.make_matrix dimx dimy e</code> returns a two-dimensional array (an array of arrays) with first dimension <code>dimx</code> and second dimension <code>dimy</code>. All the elements of this new matrix are initially physically equal to <code>e</code>. The element (<code>x,y</code>) of a matrix <code>m</code> is accessed with the notation <code>m.(x).(y)</code>.</p>\n<p>Raise <code>Invalid_argument</code> if <code>dimx</code> or <code>dimy</code> is negative or greater than <code>Sys.max_array_length</code>. If the value of <code>e</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "'a"]]}, {"path": "Array", "name": "create_matrix", "type": "let create_matrix: (int, int, 'a) => array(array('a))", "docs": "<p>Deprecated: <p><code>Array.create_matrix</code> is an alias for make_matrix.</p></p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "'a"]]}, {"path": "Array", "name": "append", "type": "let append: (array('a), array('a)) => array('a)", "docs": "<p><code>Array.append v1 v2</code> returns a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "array('a)"]]}, {"path": "Array", "name": "concat", "type": "let concat: list(array('a)) => array('a)", "docs": "<p>Same as <code>Array.append</code>, but concatenates a list of arrays.</p>\n", "kind": "value", "args": [["", "list(array('a))"]]}, {"path": "Array", "name": "sub", "type": "let sub: (array('a), int, int) => array('a)", "docs": "<p><code>Array.sub a start len</code> returns a fresh array of length <code>len</code>, containing the elements number <code>start</code> to <code>start + len - 1</code> of array <code>a</code>.</p>\n<p>Raise <code>Invalid_argument &quot;Array.sub&quot;</code> if <code>start</code> and <code>len</code> do not designate a valid subarray of <code>a</code>; that is, if <code>start &lt; 0</code>, or <code>len &lt; 0</code>, or <code>start + len &gt; Array.length a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"]]}, {"path": "Array", "name": "copy", "type": "let copy: array('a) => array('a)", "docs": "<p><code>Array.copy a</code> returns a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Array", "name": "fill", "type": "let fill: (array('a), int, int, 'a) => unit", "docs": "<p><code>Array.fill a ofs len x</code> modifies the array <code>a</code> in place, storing <code>x</code> in elements number <code>ofs</code> to <code>ofs + len - 1</code>.</p>\n<p>Raise <code>Invalid_argument &quot;Array.fill&quot;</code> if <code>ofs</code> and <code>len</code> do not designate a valid subarray of <code>a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "int"], ["", "'a"]]}, {"path": "Array", "name": "blit", "type": "let blit: (array('a), int, array('a), int, int) => unit", "docs": "<p><code>Array.blit v1 o1 v2 o2 len</code> copies <code>len</code> elements from array <code>v1</code>, starting at element number <code>o1</code>, to array <code>v2</code>, starting at element number <code>o2</code>. It works correctly even if <code>v1</code> and <code>v2</code> are the same array, and the source and destination chunks overlap.</p>\n<p>Raise <code>Invalid_argument &quot;Array.blit&quot;</code> if <code>o1</code> and <code>len</code> do not designate a valid subarray of <code>v1</code>, or if <code>o2</code> and <code>len</code> do not designate a valid subarray of <code>v2</code>.</p>\n", "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "array('a)"], ["", "int"], ["", "int"]]}, {"path": "Array", "name": "to_list", "type": "let to_list: array('a) => list('a)", "docs": "<p><code>Array.to_list a</code> returns the list of all the elements of <code>a</code>.</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Array", "name": "of_list", "type": "let of_list: list('a) => array('a)", "docs": "<p><code>Array.of_list l</code> returns a fresh array containing the elements of <code>l</code>.</p>\n", "kind": "value", "args": [["", "list('a)"]]}, {"path": "Array", "name": "iter", "type": "let iter: ('a => unit, array('a)) => unit", "docs": "<p><code>Array.iter f a</code> applies function <code>f</code> in turn to all the elements of <code>a</code>. It is equivalent to <code>f a.(0); f a.(1); ...; f a.(Array.length a - 1); ()</code>.</p>\n", "kind": "value", "args": [["", "'a => unit"], ["", "array('a)"]]}, {"path": "Array", "name": "map", "type": "let map: ('a => 'b, array('a)) => array('b)", "docs": "<p><code>Array.map f a</code> applies function <code>f</code> to all the elements of <code>a</code>, and builds an array with the results returned by <code>f</code>: <code>[| f a.(0); f a.(1); ...; f a.(Array.length a - 1) |]</code>.</p>\n", "kind": "value", "args": [["", "'a => 'b"], ["", "array('a)"]]}, {"path": "Array", "name": "iteri", "type": "let iteri: ((int, 'a) => unit, array('a)) => unit", "docs": "<p>Same as iter, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p>\n", "kind": "value", "args": [["", "(int, 'a) => unit"], ["", "array('a)"]]}, {"path": "Array", "name": "mapi", "type": "let mapi: ((int, 'a) => 'b, array('a)) => array('b)", "docs": "<p>Same as map, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p>\n", "kind": "value", "args": [["", "(int, 'a) => 'b"], ["", "array('a)"]]}, {"path": "Array", "name": "fold_left", "type": "let fold_left: (('a, 'b) => 'a, 'a, array('b)) => 'a", "docs": "<p><code>Array.fold_left f x a</code> computes <code>f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)</code>, where <code>n</code> is the length of the array <code>a</code>.</p>\n", "kind": "value", "args": [["", "('a, 'b) => 'a"], ["", "'a"], ["", "array('b)"]]}, {"path": "Array", "name": "fold_right", "type": "let fold_right: (('b, 'a) => 'a, array('b), 'a) => 'a", "docs": "<p><code>Array.fold_right f a x</code> computes <code>f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))</code>, where <code>n</code> is the length of the array <code>a</code>.</p>\n", "kind": "value", "args": [["", "('b, 'a) => 'a"], ["", "array('b)"], ["", "'a"]]}, {"path": "Array", "name": "make_float", "type": "let make_float: int => array(float)", "docs": "<p><code>Array.make_float n</code> returns a fresh float array of length <code>n</code>, with uninitialized data.</p>\nSince: 4.02", "kind": "value", "args": [["", "int"]]}, {"path": "Array", "name": "sort", "type": "let sort: (('a, 'a) => int, array('a)) => unit", "docs": "<p>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, compare is a suitable comparison function, provided there are no floating-point NaN values in the data. After calling <code>Array.sort</code>, the array is sorted in place in increasing order. <code>Array.sort</code> is guaranteed to run in constant heap space and (at most) logarithmic stack space.</p>\n<p>The current implementation uses Heap Sort. It runs in constant stack space.</p>\n<p>Specification of the comparison function: Let <code>a</code> be the array and <code>cmp</code> the comparison function. The following must be true for all x, y, z in a :</p>\n<ul><li><p><code>cmp x y</code> &gt; 0 if and only if <code>cmp y x</code> &lt; 0</p>\n</li><li><p>if <code>cmp x y</code> &gt;= 0 and <code>cmp y z</code> &gt;= 0 then <code>cmp x z</code> &gt;= 0</p>\n</li></ul><p>When <code>Array.sort</code> returns, <code>a</code> contains the same elements as before, reordered in such a way that for all i and j valid indices of <code>a</code> :</p>\n<ul><li><p><code>cmp a.(i) a.(j)</code> &gt;= 0 if and only if i &gt;= j</p>\n</li></ul>", "kind": "value", "args": [["", "('a, 'a) => int"], ["", "array('a)"]]}, {"path": "Array", "name": "stable_sort", "type": "let stable_sort: (('a, 'a) => int, array('a)) => unit", "docs": "<p>Same as sort, but the sorting algorithm is stable (i.e. elements that compare equal are kept in their original order) and not guaranteed to run in constant heap space.</p>\n<p>The current implementation uses Merge Sort. It uses <code>n/2</code> words of heap space, where <code>n</code> is the length of the array. It is usually faster than the current implementation of sort.</p>\n", "kind": "value", "args": [["", "('a, 'a) => int"], ["", "array('a)"]]}, {"path": "Array", "name": "fast_sort", "type": "let fast_sort: (('a, 'a) => int, array('a)) => unit", "docs": "<p>Same as sort or stable_sort, whichever is faster on typical input.</p>\n", "kind": "value", "args": [["", "('a, 'a) => int"], ["", "array('a)"]]}, {"path": "Array", "name": "unsafe_get", "type": "let unsafe_get: (array('a), int) => 'a", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"]]}, {"path": "Array", "name": "unsafe_set", "type": "let unsafe_set: (array('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "int"], ["", "'a"]]}, {"path": "", "name": "Array", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>blit\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>create_matrix\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fast_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fill\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_left\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fold_right\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make_matrix\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>of_list\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stable_sort\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sub\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_list\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set", "docs": null, "kind": "module"}, {"path": "Arg", "name": "spec", "type": "type spec = \n  | Unit(unit => unit)\n  | Bool(bool => unit)\n  | Set(Pervasives.ref(bool))\n  | Clear(Pervasives.ref(bool))\n  | String(string => unit)\n  | Set_string(Pervasives.ref(string))\n  | Int(int => unit)\n  | Set_int(Pervasives.ref(int))\n  | Float(float => unit)\n  | Set_float(Pervasives.ref(float))\n  | Tuple(list(spec))\n  | Symbol(list(string), string => unit)\n  | Rest(string => unit)\n", "docs": "<p>The concrete type describing the behavior associated with a keyword.</p>\n", "kind": "type"}, {"path": "Arg", "name": "key", "type": "type key = string", "docs": null, "kind": "type"}, {"path": "Arg", "name": "doc", "type": "type doc = string", "docs": null, "kind": "type"}, {"path": "Arg", "name": "usage_msg", "type": "type usage_msg = string", "docs": null, "kind": "type"}, {"path": "Arg", "name": "anon_fun", "type": "type anon_fun = string => unit", "docs": null, "kind": "type"}, {"path": "Arg", "name": "parse", "type": "let parse: (list((key, spec, doc)), anon_fun, usage_msg) => unit", "docs": "<p><code>Arg.parse speclist anon_fun usage_msg</code> parses the command line. <code>speclist</code> is a list of triples <code>(key, spec, doc)</code>. <code>key</code> is the option keyword, it must start with a <code>&#39;-&#39;</code> character. <code>spec</code> gives the option type and the function to call when this option is found on the command line. <code>doc</code> is a one-line description of this option. <code>anon_fun</code> is called on anonymous arguments. The functions in <code>spec</code> and <code>anon_fun</code> are called in the same order as their arguments appear on the command line.</p>\n<p>If an error occurs, <code>Arg.parse</code> exits the program, after printing to standard error an error message as follows:</p>\n<ul><li><p>The reason for the error: unknown option, invalid or missing argument, etc.</p>\n</li><li><p><code>usage_msg</code></p>\n</li><li><p>The list of options, each followed by the corresponding <code>doc</code> string. Beware: options that have an empty <code>doc</code> string will not be included in the list.</p>\n</li></ul><p>For the user to be able to specify anonymous arguments starting with a <code>-</code>, include for example <code>(&quot;-&quot;, String anon_fun, doc)</code> in <code>speclist</code>.</p>\n<p>By default, <code>parse</code> recognizes two unit options, <code>-help</code> and <code>--help</code>, which will print to standard output <code>usage_msg</code> and the list of options, and exit the program. You can override this behaviour by specifying your own <code>-help</code> and <code>--help</code> options in <code>speclist</code>.</p>\n", "kind": "value", "args": [["", "list((key, spec, doc))"], ["", "anon_fun"], ["", "usage_msg"]]}, {"path": "Arg", "name": "parse_dynamic", "type": "let parse_dynamic: (Pervasives.ref(list((key, spec, doc))), anon_fun, usage_msg) => unit", "docs": "<p>Same as parse, except that the <code>speclist</code> argument is a reference and may be updated during the parsing. A typical use for this feature is to parse command lines of the form:</p>\n<ul><li><p>command subcommand <code>options</code> where the list of options depends on the value of the subcommand argument.</p>\n</li></ul>", "kind": "value", "args": [["", "Pervasives.ref(list((key, spec, doc)))"], ["", "anon_fun"], ["", "usage_msg"]]}, {"path": "Arg", "name": "parse_argv", "type": "let parse_argv: (\n  ~?current: option(Pervasives.ref(int)),\n  array(string),\n  list((key, spec, doc)),\n  anon_fun,\n  usage_msg\n) => unit", "docs": "<p><code>Arg.parse_argv ~current args speclist anon_fun usage_msg</code> parses the array <code>args</code> as if it were the command line. It uses and updates the value of <code>~current</code> (if given), or <code>Arg.current</code>. You must set it before calling <code>parse_argv</code>. The initial value of <code>current</code> is the index of the program name (argument 0) in the array. If an error occurs, <code>Arg.parse_argv</code> raises <code>Arg.Bad</code> with the error message as argument. If option <code>-help</code> or <code>--help</code> is given, <code>Arg.parse_argv</code> raises <code>Arg.Help</code> with the help message as argument.</p>\n", "kind": "value", "args": [["current", "Pervasives.ref(int) (optional)"], ["", "array(string)"], ["", "list((key, spec, doc))"], ["", "anon_fun"], ["", "usage_msg"]]}, {"path": "Arg", "name": "parse_argv_dynamic", "type": "let parse_argv_dynamic: (\n  ~?current: option(Pervasives.ref(int)),\n  array(string),\n  Pervasives.ref(list((key, spec, doc))),\n  anon_fun,\n  string\n) => unit", "docs": "<p>Same as parse_argv, except that the <code>speclist</code> argument is a reference and may be updated during the parsing. See parse_dynamic.</p>\n", "kind": "value", "args": [["current", "Pervasives.ref(int) (optional)"], ["", "array(string)"], ["", "Pervasives.ref(list((key, spec, doc)))"], ["", "anon_fun"], ["", "string"]]}, {"path": "Arg", "name": "usage", "type": "let usage: (list((key, spec, doc)), usage_msg) => unit", "docs": "<p><code>Arg.usage speclist usage_msg</code> prints to standard error an error message that includes the list of valid options. This is the same message that parse prints in case of error. <code>speclist</code> and <code>usage_msg</code> are the same as for <code>Arg.parse</code>.</p>\n", "kind": "value", "args": [["", "list((key, spec, doc))"], ["", "usage_msg"]]}, {"path": "Arg", "name": "usage_string", "type": "let usage_string: (list((key, spec, doc)), usage_msg) => string", "docs": "<p>Returns the message that would have been printed by usage, if provided with the same parameters.</p>\n", "kind": "value", "args": [["", "list((key, spec, doc))"], ["", "usage_msg"]]}, {"path": "Arg", "name": "align", "type": "let align: (~?limit: option(int), list((key, spec, doc))) => list((key, spec, doc))", "docs": null, "kind": "value", "args": [["limit", "int (optional)"], ["", "list((key, spec, doc))"]]}, {"path": "Arg", "name": "current", "type": "let current: Pervasives.ref(int)", "docs": "<p>Position (in argv) of the argument being processed. You can change this value, e.g. to force parse to skip some arguments. parse uses the initial value of current as the index of argument 0 (the program name) and starts parsing arguments at the next element.</p>\n", "kind": "value"}, {"path": "", "name": "Arg", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>align\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>current\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parse_argv\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parse_argv_dynamic\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parse_dynamic\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>usage\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>usage_string\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>anon_fun\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>doc\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>spec\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>usage_msg", "docs": null, "kind": "module"}, {"path": "Js.MapperRt", "name": "binarySearch", "type": "let binarySearch: (int, int, array((int, 'a))) => 'a", "docs": "<p><code>serach polyvar assocArray</code> Search hashvariant of <code>polyvar</code> to get the returned string, assume that <code>polvar</code> exists in the array</p>\n", "kind": "value", "args": [["", "int"], ["", "int"], ["", "array((int, 'a))"]]}, {"path": "Js.MapperRt", "name": "revSearch", "type": "let revSearch: (int, array((int, string)), string) => option(int)", "docs": "<p><code>revSearch len assocArray value</code> Based on the value to find the associated key, i.e, polyvar</p>\n", "kind": "value", "args": [["", "int"], ["", "array((int, string))"], ["", "string"]]}, {"path": "Js.MapperRt", "name": "revSearchAssert", "type": "let revSearchAssert: (int, array((int, string)), string) => int", "docs": null, "kind": "value", "args": [["", "int"], ["", "array((int, string))"], ["", "string"]]}, {"path": "Js.MapperRt", "name": "toInt", "type": "let toInt: (int, array(int)) => int", "docs": "<p><code>toInt enum array</code> Based on the value of <code>enum</code>, return its mapped int</p>\n", "kind": "value", "args": [["", "int"], ["", "array(int)"]]}, {"path": "Js.MapperRt", "name": "fromInt", "type": "let fromInt: (int, array(int), int) => option(int)", "docs": "<p><code>fromInt len array int</code> return the mapped <code>enum</code></p>\n", "kind": "value", "args": [["", "int"], ["", "array(int)"], ["", "int"]]}, {"path": "Js.MapperRt", "name": "fromIntAssert", "type": "let fromIntAssert: (int, array(int), int) => int", "docs": null, "kind": "value", "args": [["", "int"], ["", "array(int)"], ["", "int"]]}, {"path": "Js", "name": "MapperRt", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>binarySearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromInt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromIntAssert\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>revSearch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>revSearchAssert\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toInt", "docs": "<p>/*</p>\n", "kind": "module"}, {"path": "Js", "name": "Internal", "type": "", "docs": "<p>/*</p>\n", "kind": "module"}, {"path": "Js", "name": "t", "type": "type t('a)", "docs": "<p>Js object type.</p>\n<pre class='ml'><code class='ml'>let x : &lt; x : int ; y : int &gt; Js.t =\n    [%obj{ x = 1 ; y = 2}]\n</code></pre>", "kind": "type"}, {"path": "Js", "name": "null", "type": "type null('a)", "docs": "<p>nullable, value of this type can be either <code>null</code> or <code>&#39;a</code> this type is the same as type <code>t</code> in Null</p>\n", "kind": "type"}, {"path": "Js", "name": "undefined", "type": "type undefined('a)", "docs": "<p>value of this type can be either <code>undefined</code> or <code>&#39;a</code> this type is the same as type <code>t</code> in Undefined</p>\n", "kind": "type"}, {"path": "Js", "name": "nullable", "type": "type nullable('a)", "docs": "<p>value of this type can be <code>undefined</code>, <code>null</code> or <code>&#39;a</code> this type is the same as type <code>t</code> n Null_undefined</p>\n", "kind": "type"}, {"path": "Js", "name": "null_undefined", "type": "type null_undefined('a) = nullable('a)", "docs": null, "kind": "type"}, {"path": "Js", "name": "toOption", "type": "let toOption: nullable('a) => option('a)", "docs": null, "kind": "value", "args": [["", "nullable('a)"]]}, {"path": "Js", "name": "undefinedToOption", "type": "let undefinedToOption: undefined('a) => option('a)", "docs": null, "kind": "value", "args": [["", "undefined('a)"]]}, {"path": "Js", "name": "nullToOption", "type": "let nullToOption: null('a) => option('a)", "docs": null, "kind": "value", "args": [["", "null('a)"]]}, {"path": "Js", "name": "test", "type": "let test: nullable('a) => bool", "docs": null, "kind": "value", "args": [["", "nullable('a)"]]}, {"path": "Js", "name": "testAny", "type": "let testAny: 'a => bool", "docs": "<p>The same as test except that it is more permissive on the types of input</p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Js", "name": "boolean", "type": "type boolean", "docs": "<p>The value could be either true_ or false_. Note in BuckleScript, <code>boolean</code> has different representation from OCaml&#39;s <code>bool</code>, see conversion functions in Boolean</p>\n", "kind": "type"}, {"path": "Js", "name": "promise", "type": "type promise('a, 'e)", "docs": "<p>The promise type, defined here for interoperation across packages</p>\n<p>Deprecated: <p>please use Promise</p></p>\n", "kind": "type"}, {"path": "Js", "name": "true_", "type": "let true_: boolean", "docs": null, "kind": "value"}, {"path": "Js", "name": "false_", "type": "let false_: boolean", "docs": null, "kind": "value"}, {"path": "Js", "name": "null", "type": "let null: null('a)", "docs": "<p>The same as <code>empty</code> in Null will be compiled as <code>null</code></p>\n", "kind": "value"}, {"path": "Js", "name": "undefined", "type": "let undefined: undefined('a)", "docs": "<p>The same as <code>empty</code> Undefined will be compiled as <code>undefined</code></p>\n", "kind": "value"}, {"path": "Js", "name": "to_bool", "type": "let to_bool: boolean => bool", "docs": "<p>convert Js boolean to OCaml bool</p>\n", "kind": "value", "args": [["", "boolean"]]}, {"path": "Js", "name": "typeof", "type": "let typeof: 'a => string", "docs": "<p><code>typeof x</code> will be compiled as <code>typeof x</code> in JS Please consider functions in Types for a type safe way of reflection</p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Js", "name": "log", "type": "let log: 'a => unit", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js", "name": "log2", "type": "let log2: ('a, 'b) => unit", "docs": null, "kind": "value", "args": [["", "'a"], ["", "'b"]]}, {"path": "Js", "name": "log3", "type": "let log3: ('a, 'b, 'c) => unit", "docs": null, "kind": "value", "args": [["", "'a"], ["", "'b"], ["", "'c"]]}, {"path": "Js", "name": "log4", "type": "let log4: ('a, 'b, 'c, 'd) => unit", "docs": "<p>A convenience function to log everything</p>\n", "kind": "value", "args": [["", "'a"], ["", "'b"], ["", "'c"], ["", "'d"]]}, {"path": "Js", "name": "logMany", "type": "let logMany: array('a) => unit", "docs": "<p>A convenience function to log more than 4 arguments</p>\n", "kind": "value", "args": [["", "array('a)"]]}, {"path": "Js", "name": "eqNull", "type": "let eqNull: ('a, null('a)) => bool", "docs": null, "kind": "value", "args": [["", "'a"], ["", "null('a)"]]}, {"path": "Js", "name": "eqUndefined", "type": "let eqUndefined: ('a, undefined('a)) => bool", "docs": null, "kind": "value", "args": [["", "'a"], ["", "undefined('a)"]]}, {"path": "Js", "name": "eqNullable", "type": "let eqNullable: ('a, nullable('a)) => bool", "docs": null, "kind": "value", "args": [["", "'a"], ["", "nullable('a)"]]}, {"path": "Js", "name": "unsafe_lt", "type": "let unsafe_lt: ('a, 'a) => bool", "docs": "<p><code>unsafe_lt a b</code> will be compiled as <code>a &lt; b</code>. It is marked as unsafe, since it is impossible to give a proper semantics for comparision which applies to any type</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Js", "name": "unsafe_le", "type": "let unsafe_le: ('a, 'a) => bool", "docs": "<p><code>unsafe_lt a b</code> will be compiled as <code>a &lt; b</code>. It is marked as unsafe, since it is impossible to give a proper semantics for comparision which applies to any type</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Js", "name": "unsafe_gt", "type": "let unsafe_gt: ('a, 'a) => bool", "docs": "<p><code>unsafe_le a b</code> will be compiled as <code>a &lt;= b</code>. See also unsafe_lt</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Js", "name": "unsafe_ge", "type": "let unsafe_ge: ('a, 'a) => bool", "docs": "<p><code>unsafe_gt a b</code> will be compiled as <code>a &gt; b</code>. See also unsafe_lt</p>\n", "kind": "value", "args": [["", "'a"], ["", "'a"]]}, {"path": "Js", "name": "Null", "type": "", "docs": "<p>Provide utilities around <code>&#39;a null</code></p>\n", "kind": "module"}, {"path": "Js", "name": "Undefined", "type": "", "docs": "<p>Provide utilities around undefined</p>\n", "kind": "module"}, {"path": "Js.Nullable", "name": "t", "type": "type t('a) = Js.null_undefined('a)", "docs": "<p>Local alias for <code>&#39;a Js.null_undefined</code></p>\n", "kind": "type"}, {"path": "Js.Nullable", "name": "return", "type": "let return: 'a => t('a)", "docs": "<p>Constructs a value of <code>&#39;a Js.null_undefined</code> containing a value of <code>&#39;a</code></p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Js.Nullable", "name": "test", "type": "let test: t('a) => bool", "docs": "<p>Returns <code>true</code> if the given value is <code>null</code> or <code>undefined</code>, <code>false</code> otherwise</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Nullable", "name": "null", "type": "let null: t('a)", "docs": "<p>The <code>null</code> value of type <code>&#39;a Js.null_undefined</code></p>\n", "kind": "value"}, {"path": "Js.Nullable", "name": "undefined", "type": "let undefined: t('a)", "docs": "<p>The <code>undefined</code> value of type <code>&#39;a Js.null_undefined</code></p>\n", "kind": "value"}, {"path": "Js.Nullable", "name": "bind", "type": "let bind: (t('a), Js.Internal.fn([ `Arity_1 of 'a25 ], 'b)) => t('b)", "docs": "<p>Maps the contained value using the given function</p>\n<p>If <code>&#39;a Js.null_undefined</code> contains a value, that value is unwrapped, mapped to a <code>&#39;b</code> using the given function <code>a&#39; -&gt; &#39;b</code>, then wrapped back up and returned as <code>&#39;b Js.null_undefined</code></p>\n<pre class='ml'><code class='ml'>let maybeGreetWorld (maybeGreeting: string Js.null_undefined) =\n  Js.Undefined.bind maybeGreeting (fun greeting -&gt; greeting ^ &quot; world!&quot;)</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a25 ], 'b)"]]}, {"path": "Js.Nullable", "name": "iter", "type": "let iter: (t('a), Js.Internal.fn([ `Arity_1 of 'a24 ], unit)) => unit", "docs": "<p>Iterates over the contained value with the given function</p>\n<p>If <code>&#39;a Js.null_undefined</code> contains a value, that value is unwrapped and applied to the given function.</p>\n<pre class='ml'><code class='ml'>let maybeSay (maybeMessage: string Js.null_undefined) =\n  Js.Null_undefined.iter maybeMessage (fun message -&gt; Js.log message)</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a24 ], unit)"]]}, {"path": "Js.Nullable", "name": "fromOption", "type": "let fromOption: option('a) => t('a)", "docs": "failed to parse: File &quot;&quot;, line 2, characters 0-2:\n&#39;{%&#39;: bad markup", "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js.Nullable", "name": "from_opt", "type": "let from_opt: option('a) => t('a)", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js.Nullable", "name": "toOption", "type": "let toOption: t('a) => option('a)", "docs": "failed to parse: File &quot;&quot;, line 2, characters 0-2:\n&#39;{%&#39;: bad markup", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Nullable", "name": "to_opt", "type": "let to_opt: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js", "name": "Nullable", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bind\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromOption\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_opt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>null\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOption\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_opt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>undefined\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide utilities around undefined</p>\n", "kind": "module"}, {"path": "Js.Null_undefined", "name": "t", "type": "type t('a) = Js.null_undefined('a)", "docs": "<p>Local alias for <code>&#39;a Js.null_undefined</code></p>\n", "kind": "type"}, {"path": "Js.Null_undefined", "name": "return", "type": "let return: 'a => t('a)", "docs": "<p>Constructs a value of <code>&#39;a Js.null_undefined</code> containing a value of <code>&#39;a</code></p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Js.Null_undefined", "name": "test", "type": "let test: t('a) => bool", "docs": "<p>Returns <code>true</code> if the given value is <code>null</code> or <code>undefined</code>, <code>false</code> otherwise</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Null_undefined", "name": "null", "type": "let null: t('a)", "docs": "<p>The <code>null</code> value of type <code>&#39;a Js.null_undefined</code></p>\n", "kind": "value"}, {"path": "Js.Null_undefined", "name": "undefined", "type": "let undefined: t('a)", "docs": "<p>The <code>undefined</code> value of type <code>&#39;a Js.null_undefined</code></p>\n", "kind": "value"}, {"path": "Js.Null_undefined", "name": "bind", "type": "let bind: (t('a), Js.Internal.fn([ `Arity_1 of 'a25 ], 'b)) => t('b)", "docs": "<p>Maps the contained value using the given function</p>\n<p>If <code>&#39;a Js.null_undefined</code> contains a value, that value is unwrapped, mapped to a <code>&#39;b</code> using the given function <code>a&#39; -&gt; &#39;b</code>, then wrapped back up and returned as <code>&#39;b Js.null_undefined</code></p>\n<pre class='ml'><code class='ml'>let maybeGreetWorld (maybeGreeting: string Js.null_undefined) =\n  Js.Undefined.bind maybeGreeting (fun greeting -&gt; greeting ^ &quot; world!&quot;)</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a25 ], 'b)"]]}, {"path": "Js.Null_undefined", "name": "iter", "type": "let iter: (t('a), Js.Internal.fn([ `Arity_1 of 'a24 ], unit)) => unit", "docs": "<p>Iterates over the contained value with the given function</p>\n<p>If <code>&#39;a Js.null_undefined</code> contains a value, that value is unwrapped and applied to the given function.</p>\n<pre class='ml'><code class='ml'>let maybeSay (maybeMessage: string Js.null_undefined) =\n  Js.Null_undefined.iter maybeMessage (fun message -&gt; Js.log message)</code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "Js.Internal.fn([ `Arity_1 of 'a24 ], unit)"]]}, {"path": "Js.Null_undefined", "name": "fromOption", "type": "let fromOption: option('a) => t('a)", "docs": "failed to parse: File &quot;&quot;, line 2, characters 0-2:\n&#39;{%&#39;: bad markup", "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js.Null_undefined", "name": "from_opt", "type": "let from_opt: option('a) => t('a)", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js.Null_undefined", "name": "toOption", "type": "let toOption: t('a) => option('a)", "docs": "failed to parse: File &quot;&quot;, line 2, characters 0-2:\n&#39;{%&#39;: bad markup", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Null_undefined", "name": "to_opt", "type": "let to_opt: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js", "name": "Null_undefined", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>bind\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromOption\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from_opt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>null\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>return\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOption\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_opt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>undefined\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide utilities around null_undefined</p>\n", "kind": "module"}, {"path": "Js", "name": "Exn", "type": "", "docs": "<p>Provide utilities for dealing with Js exceptions</p>\n", "kind": "module"}, {"path": "Js.Array", "name": "t", "type": "type t('a) = array('a)", "docs": null, "kind": "type"}, {"path": "Js.Array", "name": "array_like", "type": "type array_like('a)", "docs": null, "kind": "type"}, {"path": "Js.Array", "name": "from", "type": "let from: array_like('a) => array('b)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "array_like('a)"]]}, {"path": "Js.Array", "name": "fromMap", "type": "let fromMap: (array_like('a), 'a => 'b) => array('b)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "array_like('a)"], ["", "'a => 'b"]]}, {"path": "Js.Array", "name": "isArray", "type": "let isArray: 'a => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a"]]}, {"path": "Js.Array", "name": "length", "type": "let length: array('a) => int", "docs": null, "kind": "value", "args": [["", "array('a)"]]}, {"path": "Js.Array", "name": "copyWithin", "type": "let copyWithin: (~to_: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["to_", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "copyWithinFrom", "type": "let copyWithinFrom: (~to_: int, ~from: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["to_", "int"], ["from", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "copyWithinFromRange", "type": "let copyWithinFromRange: (~to_: int, ~start: int, ~end_: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["to_", "int"], ["start", "int"], ["end_", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "fillInPlace", "type": "let fillInPlace: ('a, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "fillFromInPlace", "type": "let fillFromInPlace: ('a, ~from: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a"], ["from", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "fillRangeInPlace", "type": "let fillRangeInPlace: ('a, ~start: int, ~end_: int, t('a)) => t('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a"], ["start", "int"], ["end_", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "pop", "type": "let pop: t('a) => option('a)", "docs": "<p>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Array", "name": "push", "type": "let push: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "pushMany", "type": "let pushMany: (array('a), t('a)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "reverseInPlace", "type": "let reverseInPlace: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Array", "name": "shift", "type": "let shift: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Array", "name": "sortInPlace", "type": "let sortInPlace: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Array", "name": "sortInPlaceWith", "type": "let sortInPlaceWith: (('a, 'a) => int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "('a, 'a) => int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "spliceInPlace", "type": "let spliceInPlace: (~pos: int, ~remove: int, ~add: array('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["pos", "int"], ["remove", "int"], ["add", "array('a)"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "removeFromInPlace", "type": "let removeFromInPlace: (~pos: int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["pos", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "removeCountInPlace", "type": "let removeCountInPlace: (~pos: int, ~count: int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["pos", "int"], ["count", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "unshift", "type": "let unshift: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "unshiftMany", "type": "let unshiftMany: (array('a), t('a)) => int", "docs": null, "kind": "value", "args": [["", "array('a)"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "append", "type": "let append: ('a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "concat", "type": "let concat: (t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "concatMany", "type": "let concatMany: (array(t('a)), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array(t('a))"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "includes", "type": "let includes: ('a, t('a)) => bool", "docs": "<p>ES2016</p>\n", "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "indexOf", "type": "let indexOf: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "indexOfFrom", "type": "let indexOfFrom: ('a, ~from: int, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["from", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "join", "type": "let join: t('a) => string", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Array", "name": "joinWith", "type": "let joinWith: (string, t('a)) => string", "docs": null, "kind": "value", "args": [["", "string"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "lastIndexOf", "type": "let lastIndexOf: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "lastIndexOfFrom", "type": "let lastIndexOfFrom: ('a, ~from: int, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["from", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "lastIndexOf_start", "type": "let lastIndexOf_start: ('a, t('a)) => int", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "slice", "type": "let slice: (~start: int, ~end_: int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["start", "int"], ["end_", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Array", "name": "slice_copy", "type": "let slice_copy: (unit, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "unit"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "sliceFrom", "type": "let sliceFrom: (int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "slice_start", "type": "let slice_start: (int, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "toString", "type": "let toString: t('a) => string", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Array", "name": "toLocaleString", "type": "let toLocaleString: t('a) => string", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Array", "name": "every", "type": "let every: ('a => bool, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "everyi", "type": "let everyi: (('a, int) => bool, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "filter", "type": "let filter: ('a => bool, t('a)) => t('a)", "docs": "<p>should we use <code>bool</code> or <code>boolan</code> seems they are intechangeable here</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "filteri", "type": "let filteri: (('a, int) => bool, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "find", "type": "let find: ('a => bool, t('a)) => option('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "findi", "type": "let findi: (('a, int) => bool, t('a)) => option('a)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "findIndex", "type": "let findIndex: ('a => bool, t('a)) => int", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "findIndexi", "type": "let findIndexi: (('a, int) => bool, t('a)) => int", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "forEach", "type": "let forEach: ('a => unit, t('a)) => unit", "docs": null, "kind": "value", "args": [["", "'a => unit"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "forEachi", "type": "let forEachi: (('a, int) => unit, t('a)) => unit", "docs": null, "kind": "value", "args": [["", "('a, int) => unit"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "map", "type": "let map: ('a => 'b, t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "'a => 'b"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "mapi", "type": "let mapi: (('a, int) => 'b, t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "('a, int) => 'b"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "reduce", "type": "let reduce: (('b, 'a) => 'b, 'b, t('a)) => 'b", "docs": null, "kind": "value", "args": [["", "('b, 'a) => 'b"], ["", "'b"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "reducei", "type": "let reducei: (('b, 'a, int) => 'b, 'b, t('a)) => 'b", "docs": null, "kind": "value", "args": [["", "('b, 'a, int) => 'b"], ["", "'b"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "reduceRight", "type": "let reduceRight: (('b, 'a) => 'b, 'b, t('a)) => 'b", "docs": null, "kind": "value", "args": [["", "('b, 'a) => 'b"], ["", "'b"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "reduceRighti", "type": "let reduceRighti: (('b, 'a, int) => 'b, 'b, t('a)) => 'b", "docs": null, "kind": "value", "args": [["", "('b, 'a, int) => 'b"], ["", "'b"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "some", "type": "let some: ('a => bool, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "'a => bool"], ["", "t('a)"]]}, {"path": "Js.Array", "name": "somei", "type": "let somei: (('a, int) => bool, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "('a, int) => bool"], ["", "t('a)"]]}, {"path": "Js", "name": "Array", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copyWithin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copyWithinFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copyWithinFromRange\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>every\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>everyi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillFromInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fillRangeInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>find\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>findIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>findIndexi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>findi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEach\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>forEachi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>from\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>includes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>indexOf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>indexOfFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>join\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>joinWith\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOfFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOf_start\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pop\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>push\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pushMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduce\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceRight\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reduceRighti\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reducei\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeCountInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>removeFromInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reverseInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>shift\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sliceFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice_start\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>somei\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sortInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sortInPlaceWith\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>spliceInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unshift\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unshiftMany\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>array_like\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide bindings to Js array</p>\n", "kind": "module"}, {"path": "Js.String", "name": "t", "type": "type t = string", "docs": null, "kind": "type"}, {"path": "Js.String", "name": "make", "type": "let make: 'a => t", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js.String", "name": "fromCharCode", "type": "let fromCharCode: int => t", "docs": null, "kind": "value", "args": [["", "int"]]}, {"path": "Js.String", "name": "fromCharCodeMany", "type": "let fromCharCodeMany: array(int) => t", "docs": null, "kind": "value", "args": [["", "array(int)"]]}, {"path": "Js.String", "name": "fromCodePoint", "type": "let fromCodePoint: int => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Js.String", "name": "fromCodePointMany", "type": "let fromCodePointMany: array(int) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "Js.String", "name": "length", "type": "let length: t => int", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.String", "name": "get", "type": "let get: (t, int) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Js.String", "name": "charAt", "type": "let charAt: (int, t) => t", "docs": null, "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "charCodeAt", "type": "let charCodeAt: (int, t) => float", "docs": null, "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "codePointAt", "type": "let codePointAt: (int, t) => option(int)", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "concat", "type": "let concat: (t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "concatMany", "type": "let concatMany: (array(t), t) => t", "docs": null, "kind": "value", "args": [["", "array(t)"], ["", "t"]]}, {"path": "Js.String", "name": "endsWith", "type": "let endsWith: (t, t) => bool", "docs": "failed to parse: File &quot;&quot;, line 1, characters 18-52:\n&#39;{[...]}&#39; (code block) must begin on its own line", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "endsWithFrom", "type": "let endsWithFrom: (t, int, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "includes", "type": "let includes: (t, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "includesFrom", "type": "let includesFrom: (t, int, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "indexOf", "type": "let indexOf: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "indexOfFrom", "type": "let indexOfFrom: (t, int, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "lastIndexOf", "type": "let lastIndexOf: (t, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "lastIndexOfFrom", "type": "let lastIndexOfFrom: (t, int, t) => int", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "localeCompare", "type": "let localeCompare: (t, t) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "match_", "type": "let match_: (Js_re.t, t) => option(array(t))", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "t"]]}, {"path": "Js.String", "name": "normalize", "type": "let normalize: t => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.String", "name": "normalizeByForm", "type": "let normalizeByForm: (t, t) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "repeat", "type": "let repeat: (int, t) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "replace", "type": "let replace: (t, t, t) => t", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "replaceByRe", "type": "let replaceByRe: (Js_re.t, t, t) => t", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "unsafeReplaceBy0", "type": "let unsafeReplaceBy0: (Js_re.t, (t, int, t) => t, t) => t", "docs": "<p>returns a new string with some or all matches of a pattern replaced by the n function</p>\n<p>afeReplaceBy0 re (fun match offset whole -&gt; &quot;hi&quot;)</p>\n<p>prints &quot;hi world!&quot; *)</p>\n<p>lla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p>\n", "kind": "value", "args": [["", "Js_re.t"], ["", "(t, int, t) => t"], ["", "t"]]}, {"path": "Js.String", "name": "unsafeReplaceBy1", "type": "let unsafeReplaceBy1: (Js_re.t, (t, t, int, t) => t, t) => t", "docs": "<p>returns a new string with some or all matches of a pattern replaced by the n function</p>\n<p>afeReplaceBy1 re (fun match p1 offset whole -&gt; &quot;hi&quot;)</p>\n<p>prints &quot;hi world!&quot; *)</p>\n<p>lla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p>\n", "kind": "value", "args": [["", "Js_re.t"], ["", "(t, t, int, t) => t"], ["", "t"]]}, {"path": "Js.String", "name": "unsafeReplaceBy2", "type": "let unsafeReplaceBy2: (Js_re.t, (t, t, t, int, t) => t, t) => t", "docs": "<p>returns a new string with some or all matches of a pattern replaced by the n function</p>\n<p>afeReplaceBy2 re (fun match p1 p2 offset whole -&gt; &quot;hi&quot;)</p>\n<p>prints &quot;hi world!&quot; *)</p>\n<p>lla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p>\n", "kind": "value", "args": [["", "Js_re.t"], ["", "(t, t, t, int, t) => t"], ["", "t"]]}, {"path": "Js.String", "name": "unsafeReplaceBy3", "type": "let unsafeReplaceBy3: (Js_re.t, (t, t, t, t, int, t) => t, t) => t", "docs": "<p>returns a new string with some or all matches of a pattern replaced by the n function</p>\n<p>afeReplaceBy3 re (fun match p1 p2 p3 offset whole -&gt; &quot;hi&quot;)</p>\n<p>prints &quot;hi world!&quot; *)</p>\n<p>lla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter&gt; MDN</p>\n", "kind": "value", "args": [["", "Js_re.t"], ["", "(t, t, t, t, int, t) => t"], ["", "t"]]}, {"path": "Js.String", "name": "search", "type": "let search: (Js_re.t, t) => int", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "t"]]}, {"path": "Js.String", "name": "slice", "type": "let slice: (~from: int, ~to_: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["to_", "int"], ["", "t"]]}, {"path": "Js.String", "name": "sliceToEnd", "type": "let sliceToEnd: (~from: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["", "t"]]}, {"path": "Js.String", "name": "split", "type": "let split: (t, t) => array(t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "splitAtMost", "type": "let splitAtMost: (t, ~limit: int, t) => array(t)", "docs": null, "kind": "value", "args": [["", "t"], ["limit", "int"], ["", "t"]]}, {"path": "Js.String", "name": "splitLimited", "type": "let splitLimited: (t, int, t) => array(t)", "docs": null, "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "splitByRe", "type": "let splitByRe: (Js_re.t, t) => array(t)", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "t"]]}, {"path": "Js.String", "name": "splitByReAtMost", "type": "let splitByReAtMost: (Js_re.t, ~limit: int, t) => array(t)", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["limit", "int"], ["", "t"]]}, {"path": "Js.String", "name": "splitRegexpLimited", "type": "let splitRegexpLimited: (Js_re.t, int, t) => array(t)", "docs": null, "kind": "value", "args": [["", "Js_re.t"], ["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "startsWith", "type": "let startsWith: (t, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "startsWithFrom", "type": "let startsWithFrom: (t, int, t) => bool", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "int"], ["", "t"]]}, {"path": "Js.String", "name": "substr", "type": "let substr: (~from: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["", "t"]]}, {"path": "Js.String", "name": "substrAtMost", "type": "let substrAtMost: (~from: int, ~length: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["length", "int"], ["", "t"]]}, {"path": "Js.String", "name": "substring", "type": "let substring: (~from: int, ~to_: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["to_", "int"], ["", "t"]]}, {"path": "Js.String", "name": "substringToEnd", "type": "let substringToEnd: (~from: int, t) => t", "docs": null, "kind": "value", "args": [["from", "int"], ["", "t"]]}, {"path": "Js.String", "name": "toLowerCase", "type": "let toLowerCase: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.String", "name": "toLocaleLowerCase", "type": "let toLocaleLowerCase: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.String", "name": "toUpperCase", "type": "let toUpperCase: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.String", "name": "toLocaleUpperCase", "type": "let toLocaleUpperCase: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.String", "name": "trim", "type": "let trim: t => t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.String", "name": "anchor", "type": "let anchor: (t, t) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "link", "type": "let link: (t, t) => t", "docs": "<p>ES2015</p>\n", "kind": "value", "args": [["", "t"], ["", "t"]]}, {"path": "Js.String", "name": "castToArrayLike", "type": "let castToArrayLike: t => Js_array.array_like(t)", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js", "name": "String", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>anchor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>castToArrayLike\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>charAt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>charCodeAt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>codePointAt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>concatMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>endsWith\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>endsWithFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromCharCode\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromCharCodeMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromCodePoint\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromCodePointMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>includes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>includesFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>indexOf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>indexOfFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOf\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndexOfFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>link\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>localeCompare\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>match_\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>normalize\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>normalizeByForm\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>repeat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>replace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>replaceByRe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>search\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>slice\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sliceToEnd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>split\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitAtMost\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitByRe\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitByReAtMost\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitLimited\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>splitRegexpLimited\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>startsWith\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>startsWithFrom\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>substr\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>substrAtMost\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>substring\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>substringToEnd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleLowerCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleUpperCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLowerCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toUpperCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trim\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeReplaceBy0\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeReplaceBy1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeReplaceBy2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeReplaceBy3\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide bindings to Js array</p>\n", "kind": "module"}, {"path": "Js.Boolean", "name": "to_js_boolean", "type": "let to_js_boolean: bool => Js.boolean", "docs": null, "kind": "value", "args": [["", "bool"]]}, {"path": "Js", "name": "Boolean", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_js_boolean", "docs": "<p>Provide bindings to JS string</p>\n", "kind": "module"}, {"path": "Js.Re", "name": "t", "type": "type t", "docs": "<p>the RegExp object</p>\n", "kind": "type"}, {"path": "Js.Re", "name": "result", "type": "type result", "docs": "<p>the result of a executing a RegExp on a string</p>\n", "kind": "type"}, {"path": "Js.Re", "name": "captures", "type": "let captures: result => array(Js.nullable(string))", "docs": "<p>an array of the match and captures, the first is the full match and the remaining are the substring captures</p>\n", "kind": "value", "args": [["", "result"]]}, {"path": "Js.Re", "name": "matches", "type": "let matches: result => array(string)", "docs": "<p>an array of the matches, the first is the full match and the remaining are the substring matches</p>\n<p>Deprecated: <p>Use <code>captures</code> instead.</p></p>\n", "kind": "value", "args": [["", "result"]]}, {"path": "Js.Re", "name": "index", "type": "let index: result => int", "docs": "<p>0-based index of the match in the input string</p>\n", "kind": "value", "args": [["", "result"]]}, {"path": "Js.Re", "name": "input", "type": "let input: result => string", "docs": "<p>the original input string</p>\n", "kind": "value", "args": [["", "result"]]}, {"path": "Js.Re", "name": "fromString", "type": "let fromString: string => t", "docs": "failed to parse: File &quot;&quot;, line 3, characters 8-9:\nunpaired &#39;]&#39; (end of code)", "kind": "value", "args": [["", "string"]]}, {"path": "Js.Re", "name": "fromStringWithFlags", "type": "let fromStringWithFlags: (string, ~flags: string) => t", "docs": "failed to parse: File &quot;&quot;, line 5, characters 0-2:\n&#39;{%&#39;: bad markup", "kind": "value", "args": [["", "string"], ["flags", "string"]]}, {"path": "Js.Re", "name": "flags", "type": "let flags: t => string", "docs": "<p>returns the enabled flags as a string</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Re", "name": "global", "type": "let global: t => bool", "docs": "<p>returns a bool indicating whether the <code>global</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Re", "name": "ignoreCase", "type": "let ignoreCase: t => bool", "docs": "<p>returns a bool indicating whether the <code>ignoreCase</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Re", "name": "lastIndex", "type": "let lastIndex: t => int", "docs": "failed to parse: File &quot;&quot;, line 22, characters 105-105:\nend of text is not allowed in &#39;{[...]}&#39; (code block)", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Re", "name": "setLastIndex", "type": "let setLastIndex: (t, int) => unit", "docs": "<p>sets the index at which the next match will start its search from</p>\n", "kind": "value", "args": [["", "t"], ["", "int"]]}, {"path": "Js.Re", "name": "multiline", "type": "let multiline: t => bool", "docs": "<p>returns a bool indicating whether the <code>multiline</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Re", "name": "source", "type": "let source: t => string", "docs": "<p>returns the pattern as a string</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Re", "name": "sticky", "type": "let sticky: t => bool", "docs": "<p>returns a bool indicating whether the <code>sticky</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Re", "name": "unicode", "type": "let unicode: t => bool", "docs": "<p>returns a bool indicating whether the <code>unicode</code> flag is set</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Re", "name": "exec", "type": "let exec: (string, t) => option(result)", "docs": "failed to parse: File &quot;&quot;, line 2, characters 7-8:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "string"], ["", "t"]]}, {"path": "Js.Re", "name": "test", "type": "let test: (string, t) => bool", "docs": "<p>tests whether the given RegExp object will match a given string</p>\n<p><strong>returns</strong> <code>true</code> if a match is found, <code>false</code> otherwise</p>\n<pre class='ml'><code class='ml'>(* A simple implementation of Js.String.startsWith *)\n\nlet str = &quot;hello world!&quot;\n\nlet startsWith substring target =\n  Js.Re.fromString (&quot;^&quot; ^ substring)\n    |&gt; Js.Re.test target\n\nlet () = Js.log (str |&gt; startsWith &quot;hello&quot;) (* prints &quot;true&quot; *)</code></pre><p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"], ["", "t"]]}, {"path": "Js", "name": "Re", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>captures\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exec\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromStringWithFlags\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>global\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ignoreCase\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>index\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>input\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>lastIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>matches\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>multiline\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setLastIndex\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>source\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sticky\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unicode\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>result\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide bindings to Js regex expression</p>\n", "kind": "module"}, {"path": "Js.Promise", "name": "t", "type": "type t('a)", "docs": null, "kind": "type"}, {"path": "Js.Promise", "name": "error", "type": "type error", "docs": null, "kind": "type"}, {"path": "Js.Promise", "name": "make", "type": "let make: (\n  ~resolve: Js.Internal.fn([ `Arity_1 of 'a23 ], unit),\n  ~reject: Js.Internal.fn([ `Arity_1 of exn ], unit)\n) => unit => t('a)", "docs": null, "kind": "value", "args": [["", "(\n  ~resolve: Js.Internal.fn([ `Arity_1 of 'a23 ], unit),\n  ~reject: Js.Internal.fn([ `Arity_1 of exn ], unit)\n) => unit"]]}, {"path": "Js.Promise", "name": "resolve", "type": "let resolve: 'a => t('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js.Promise", "name": "reject", "type": "let reject: exn => t('a)", "docs": null, "kind": "value", "args": [["", "exn"]]}, {"path": "Js.Promise", "name": "all", "type": "let all: array(t('a)) => t(array('a))", "docs": null, "kind": "value", "args": [["", "array(t('a))"]]}, {"path": "Js.Promise", "name": "all2", "type": "let all2: (t('a0), t('a1)) => t(('a0, 'a1))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1))"]]}, {"path": "Js.Promise", "name": "all3", "type": "let all3: (t('a0), t('a1), t('a2)) => t(('a0, 'a1, 'a2))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1), t('a2))"]]}, {"path": "Js.Promise", "name": "all4", "type": "let all4: (t('a0), t('a1), t('a2), t('a3)) => t(('a0, 'a1, 'a2, 'a3))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1), t('a2), t('a3))"]]}, {"path": "Js.Promise", "name": "all5", "type": "let all5: (t('a0), t('a1), t('a2), t('a3), t('a4)) => t(('a0, 'a1, 'a2, 'a3, 'a4))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1), t('a2), t('a3), t('a4))"]]}, {"path": "Js.Promise", "name": "all6", "type": "let all6: (t('a0), t('a1), t('a2), t('a3), t('a4), t('a5)) => t(('a0, 'a1, 'a2, 'a3, 'a4, 'a5))", "docs": null, "kind": "value", "args": [["", "(t('a0), t('a1), t('a2), t('a3), t('a4), t('a5))"]]}, {"path": "Js.Promise", "name": "race", "type": "let race: array(t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "array(t('a))"]]}, {"path": "Js.Promise", "name": "then_", "type": "let then_: ('a => t('b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "'a => t('b)"], ["", "t('a)"]]}, {"path": "Js.Promise", "name": "catch", "type": "let catch: (error => t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "error => t('a)"], ["", "t('a)"]]}, {"path": "Js", "name": "Promise", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all3\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all4\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all5\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>all6\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>catch\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>race\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reject\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>resolve\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>then_\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>error\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide bindings to JS promise</p>\n", "kind": "module"}, {"path": "Js.Date", "name": "t", "type": "type t", "docs": null, "kind": "type"}, {"path": "Js.Date", "name": "valueOf", "type": "let valueOf: t => float", "docs": "<p>returns the primitive value of this date, equivalent to getTime</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "make", "type": "let make: unit => t", "docs": "<p>returns a date representing the current time</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js.Date", "name": "fromFloat", "type": "let fromFloat: float => t", "docs": null, "kind": "value", "args": [["", "float"]]}, {"path": "Js.Date", "name": "fromString", "type": "let fromString: string => t", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Js.Date", "name": "makeWithYM", "type": "let makeWithYM: (~year: float, ~month: float, unit) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "makeWithYMD", "type": "let makeWithYMD: (~year: float, ~month: float, ~date: float, unit) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "makeWithYMDH", "type": "let makeWithYMDH: (~year: float, ~month: float, ~date: float, ~hours: float, unit) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "makeWithYMDHM", "type": "let makeWithYMDHM: (\n  ~year: float,\n  ~month: float,\n  ~date: float,\n  ~hours: float,\n  ~minutes: float,\n  unit\n) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["minutes", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "makeWithYMDHMS", "type": "let makeWithYMDHMS: (\n  ~year: float,\n  ~month: float,\n  ~date: float,\n  ~hours: float,\n  ~minutes: float,\n  ~seconds: float,\n  unit\n) => t", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "utcWithYM", "type": "let utcWithYM: (~year: float, ~month: float, unit) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "utcWithYMD", "type": "let utcWithYMD: (~year: float, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "utcWithYMDH", "type": "let utcWithYMDH: (~year: float, ~month: float, ~date: float, ~hours: float, unit) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "utcWithYMDHM", "type": "let utcWithYMDHM: (\n  ~year: float,\n  ~month: float,\n  ~date: float,\n  ~hours: float,\n  ~minutes: float,\n  unit\n) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["minutes", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "utcWithYMDHMS", "type": "let utcWithYMDHMS: (\n  ~year: float,\n  ~month: float,\n  ~date: float,\n  ~hours: float,\n  ~minutes: float,\n  ~seconds: float,\n  unit\n) => float", "docs": null, "kind": "value", "args": [["year", "float"], ["month", "float"], ["date", "float"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "now", "type": "let now: unit => float", "docs": "<p>returns the number of milliseconds since Unix epoch</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js.Date", "name": "parse", "type": "let parse: string => t", "docs": "<p>returns NaN if passed invalid date string</p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js.Date", "name": "getDate", "type": "let getDate: t => float", "docs": "<p>return the day of the month (1-31)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getDay", "type": "let getDay: t => float", "docs": "<p>returns the day of the week (0-6)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getFullYear", "type": "let getFullYear: t => float", "docs": "<p>returns the day of the week (0-6)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getHours", "type": "let getHours: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getMilliseconds", "type": "let getMilliseconds: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getMinutes", "type": "let getMinutes: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getMonth", "type": "let getMonth: t => float", "docs": "<p>returns the month (0-11)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getSeconds", "type": "let getSeconds: t => float", "docs": "<p>returns the month (0-11)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getTime", "type": "let getTime: t => float", "docs": "<p>returns the number of milliseconds since Unix epoch</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getTimezoneOffset", "type": "let getTimezoneOffset: t => float", "docs": "<p>returns the number of milliseconds since Unix epoch</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getUTCDate", "type": "let getUTCDate: t => float", "docs": "<p>return the day of the month (1-31)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getUTCDay", "type": "let getUTCDay: t => float", "docs": "<p>returns the day of the week (0-6)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getUTCFullYear", "type": "let getUTCFullYear: t => float", "docs": "<p>returns the day of the week (0-6)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getUTCHours", "type": "let getUTCHours: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getUTCMilliseconds", "type": "let getUTCMilliseconds: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getUTCMinutes", "type": "let getUTCMinutes: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getUTCMonth", "type": "let getUTCMonth: t => float", "docs": "<p>returns the month (0-11)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getUTCSeconds", "type": "let getUTCSeconds: t => float", "docs": "<p>returns the month (0-11)</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "getYear", "type": "let getYear: t => float", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "setDate", "type": "let setDate: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setFullYear", "type": "let setFullYear: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setFullYearM", "type": "let setFullYearM: (t, ~year: float, ~month: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["year", "float"], ["month", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setFullYearMD", "type": "let setFullYearMD: (t, ~year: float, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["year", "float"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setHours", "type": "let setHours: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setHoursM", "type": "let setHoursM: (t, ~hours: float, ~minutes: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setHoursMS", "type": "let setHoursMS: (t, ~hours: float, ~minutes: float, ~seconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setHoursMSMs", "type": "let setHoursMSMs: (\n  t,\n  ~hours: float,\n  ~minutes: float,\n  ~seconds: float,\n  ~milliseconds: float,\n  unit\n) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setMilliseconds", "type": "let setMilliseconds: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setMinutes", "type": "let setMinutes: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setMinutesS", "type": "let setMinutesS: (t, ~minutes: float, ~seconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setMinutesSMs", "type": "let setMinutesSMs: (t, ~minutes: float, ~seconds: float, ~milliseconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["minutes", "float"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setMonth", "type": "let setMonth: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setMonthD", "type": "let setMonthD: (t, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setSeconds", "type": "let setSeconds: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setSecondsMs", "type": "let setSecondsMs: (t, ~seconds: float, ~milliseconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setTime", "type": "let setTime: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setUTCDate", "type": "let setUTCDate: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setUTCFullYear", "type": "let setUTCFullYear: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setUTCFullYearM", "type": "let setUTCFullYearM: (t, ~year: float, ~month: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["year", "float"], ["month", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setUTCFullYearMD", "type": "let setUTCFullYearMD: (t, ~year: float, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["year", "float"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setUTCHours", "type": "let setUTCHours: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setUTCHoursM", "type": "let setUTCHoursM: (t, ~hours: float, ~minutes: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setUTCHoursMS", "type": "let setUTCHoursMS: (t, ~hours: float, ~minutes: float, ~seconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setUTCHoursMSMs", "type": "let setUTCHoursMSMs: (\n  t,\n  ~hours: float,\n  ~minutes: float,\n  ~seconds: float,\n  ~milliseconds: float,\n  unit\n) => float", "docs": null, "kind": "value", "args": [["", "t"], ["hours", "float"], ["minutes", "float"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setUTCMilliseconds", "type": "let setUTCMilliseconds: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setUTCMinutes", "type": "let setUTCMinutes: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setUTCMinutesS", "type": "let setUTCMinutesS: (t, ~minutes: float, ~seconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["minutes", "float"], ["seconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setUTCMinutesSMs", "type": "let setUTCMinutesSMs: (t, ~minutes: float, ~seconds: float, ~milliseconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["minutes", "float"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setUTCMonth", "type": "let setUTCMonth: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setUTCMonthD", "type": "let setUTCMonthD: (t, ~month: float, ~date: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["month", "float"], ["date", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setUTCSeconds", "type": "let setUTCSeconds: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setUTCSecondsMs", "type": "let setUTCSecondsMs: (t, ~seconds: float, ~milliseconds: float, unit) => float", "docs": null, "kind": "value", "args": [["", "t"], ["seconds", "float"], ["milliseconds", "float"], ["", "unit"]]}, {"path": "Js.Date", "name": "setUTCTime", "type": "let setUTCTime: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "setYear", "type": "let setYear: (t, float) => float", "docs": null, "kind": "value", "args": [["", "t"], ["", "float"]]}, {"path": "Js.Date", "name": "toDateString", "type": "let toDateString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "toGMTString", "type": "let toGMTString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "toISOString", "type": "let toISOString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "toJSON", "type": "let toJSON: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "toLocaleDateString", "type": "let toLocaleDateString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "toLocaleString", "type": "let toLocaleString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "toLocaleTimeString", "type": "let toLocaleTimeString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "toString", "type": "let toString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "toTimeString", "type": "let toTimeString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Date", "name": "toUTCString", "type": "let toUTCString: t => string", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js", "name": "Date", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromFloat\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getDate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getDay\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getFullYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getHours\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getMilliseconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getMinutes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getMonth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getSeconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getTime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getTimezoneOffset\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCDate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCDay\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCFullYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCHours\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCMilliseconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCMinutes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCMonth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getUTCSeconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYMD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYMDH\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYMDHM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>makeWithYMDHMS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>now\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parse\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setDate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setFullYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setFullYearM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setFullYearMD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setHours\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setHoursM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setHoursMS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setHoursMSMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMilliseconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMinutes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMinutesS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMinutesSMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMonth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setMonthD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setSeconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setSecondsMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setTime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCDate\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCFullYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCFullYearM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCFullYearMD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCHours\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCHoursM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCHoursMS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCHoursMSMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMilliseconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMinutes\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMinutesS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMinutesSMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMonth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCMonthD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCSeconds\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCSecondsMs\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setUTCTime\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setYear\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toDateString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toGMTString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toISOString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toJSON\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleDateString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toLocaleTimeString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toTimeString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toUTCString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYMD\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYMDH\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYMDHM\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>utcWithYMDHMS\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>valueOf\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide bindings for JS Date</p>\n", "kind": "module"}, {"path": "Js.Dict", "name": "t", "type": "type t('a)", "docs": "<p>Dictionary type (ie an &#39;{ }&#39; JS object). However it is restricted to hold a single type; therefore values must have the same type.</p>\n<p>This Dictionary type is mostly used with the <code>Js_json.t</code> type.</p>\n", "kind": "type"}, {"path": "Js.Dict", "name": "key", "type": "type key = string", "docs": "<p>Key type</p>\n", "kind": "type"}, {"path": "Js.Dict", "name": "get", "type": "let get: (t('a), key) => option('a)", "docs": "<p><code>get dict key</code> returns <code>None</code> if the <code>key</code> is not found in the dictionary, <code>Some value</code> otherwise</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Js.Dict", "name": "unsafeGet", "type": "let unsafeGet: (t('a), key) => 'a", "docs": "<p><code>unsafeGet dict key</code> return the value if the <code>key</code> exists, otherwise an <strong>undefined</strong> value is returned. Must be used only when the existence of a key is certain. (i.e. when having called <code>keys</code> function previously.</p>\n<pre class='ml'><code class='ml'>Array.iter (fun key -&gt; Js.log (Js_dict.unsafeGet dic key)) (Js_dict.keys dict) </code></pre>", "kind": "value", "args": [["", "t('a)"], ["", "key"]]}, {"path": "Js.Dict", "name": "set", "type": "let set: (t('a), key, 'a) => unit", "docs": "<p><code>set dict key value</code> sets the <code>key</code>/<code>value</code> in <code>dict</code></p>\n", "kind": "value", "args": [["", "t('a)"], ["", "key"], ["", "'a"]]}, {"path": "Js.Dict", "name": "keys", "type": "let keys: t('a) => array(string)", "docs": "<p><code>keys dict</code> returns all the keys in the dictionary <code>dict</code></p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Dict", "name": "empty", "type": "let empty: unit => t('a)", "docs": "<p><code>empty ()</code> returns an empty dictionary</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js.Dict", "name": "unsafeDeleteKey", "type": "let unsafeDeleteKey: Js.Internal.fn([ `Arity_2 of string t * string ], unit)", "docs": "<p>Experimental internal funciton</p>\n", "kind": "value"}, {"path": "Js.Dict", "name": "entries", "type": "let entries: t('a) => array((key, 'a))", "docs": "<p><code>entries dict</code> returns the key value pairs in <code>dict</code> (ES2017)</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Dict", "name": "values", "type": "let values: t('a) => array('a)", "docs": "<p><code>entries dict</code> returns the values in <code>dict</code> (ES2017)</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Dict", "name": "fromList", "type": "let fromList: list((key, 'a)) => t('a)", "docs": "<p><code>fromList entries</code> creates a new dictionary containing each <code>(key, value)</code> pair in <code>entries</code></p>\n", "kind": "value", "args": [["", "list((key, 'a))"]]}, {"path": "Js.Dict", "name": "fromArray", "type": "let fromArray: array((key, 'a)) => t('a)", "docs": "<p><code>fromArray entries</code> creates a new dictionary containing each <code>(key, value)</code> pair in <code>entries</code></p>\n", "kind": "value", "args": [["", "array((key, 'a))"]]}, {"path": "Js.Dict", "name": "map", "type": "let map: (Js.Internal.fn([ `Arity_1 of 'a22 ], 'b), t('a)) => t('b)", "docs": "<p><code>map f dict</code> maps <code>dict</code> to a new dictionary with the same keys, using <code>f</code> to map each value</p>\n", "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a22 ], 'b)"], ["", "t('a)"]]}, {"path": "Js", "name": "Dict", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>entries\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fromList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keys\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeDeleteKey\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafeGet\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>values\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>key\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide utilities for JS dictionary object</p>\n", "kind": "module"}, {"path": "Js.Global", "name": "intervalId", "type": "type intervalId", "docs": "<p>Identify an interval started by setInterval</p>\n", "kind": "type"}, {"path": "Js.Global", "name": "timeoutId", "type": "type timeoutId", "docs": "<p>Identify timeout started by setTimeout</p>\n", "kind": "type"}, {"path": "Js.Global", "name": "clearInterval", "type": "let clearInterval: intervalId => unit", "docs": "<p>Clear an interval started by setInterval</p>\n<pre class='ml'><code class='ml'>(* API for a somewhat aggressive snoozing alarm clock *)\n\nlet interval = ref Js.Nullable.null\n\nlet remind () =\n  Js.log &quot;Wake Up!&quot;;\n  IO.punchSleepyGuy ()\n  \nlet snooze mins =\n  interval := Js.Nullable.return (Js.Global.setInterval remind (mins * 60 * 1000))\n  \nlet cancel () =\n  Js.Nullable.iter !interval (fun[\\@bs] intervalId -&gt; Js.Global.clearInterval intervalId)</code></pre><p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearInterval'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "intervalId"]]}, {"path": "Js.Global", "name": "clearTimeout", "type": "let clearTimeout: timeoutId => unit", "docs": "<p>Clear a timeout started by setTimeout</p>\n<pre class='ml'><code class='ml'>(* A simple model of a code monkey&#39;s brain *)\n\nlet timer = ref Js.Nullable.null\n\nlet work () =\n  IO.closeHackerNewsTab ()\n\nlet procrastinate mins =\n  Js.Nullable.iter !timer (fun[\\@bs] timer -&gt; Js.Global.clearTimeout timer);\n  timer := Js.Nullable.return (Js.Global.setTimeout work (mins * 60 * 1000))</code></pre><p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "timeoutId"]]}, {"path": "Js.Global", "name": "setInterval", "type": "let setInterval: (unit => unit, int) => intervalId", "docs": "failed to parse: File &quot;&quot;, line 2, characters 6-7:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "unit => unit"], ["", "int"]]}, {"path": "Js.Global", "name": "setTimeout", "type": "let setTimeout: (unit => unit, int) => timeoutId", "docs": "failed to parse: File &quot;&quot;, line 2, characters 7-8:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "unit => unit"], ["", "int"]]}, {"path": "Js.Global", "name": "encodeURI", "type": "let encodeURI: string => string", "docs": "<p>URL-encodes a string.</p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js.Global", "name": "decodeURI", "type": "let decodeURI: string => string", "docs": "<p>Decodes a URL-enmcoded string produced by <code>encodeURI</code></p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js.Global", "name": "encodeURIComponent", "type": "let encodeURIComponent: string => string", "docs": "<p>URL-encodes a string, including characters with special meaning in a URI.</p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js.Global", "name": "decodeURIComponent", "type": "let decodeURIComponent: string => string", "docs": "<p>Decodes a URL-enmcoded string produced by <code>encodeURIComponent</code></p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js", "name": "Global", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clearInterval\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clearTimeout\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeURI\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeURIComponent\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>encodeURI\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>encodeURIComponent\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setInterval\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>setTimeout\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>intervalId\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>timeoutId", "docs": "<p>Provide bindings to JS global functions in global namespace</p>\n", "kind": "module"}, {"path": "Js.Json", "name": "t", "type": "type t", "docs": "<p>The JSON data structure</p>\n", "kind": "type"}, {"path": "Js.Json", "name": "kind", "type": "type kind('_) = \n  | String: kind(Js_string.t)\n  | Number: kind(float)\n  | Object: kind(Js_dict.t(t))\n  | Array: kind(array(t))\n  | Boolean: kind(Js.boolean)\n  | Null: kind(Js_types.null_val)\n", "docs": "<p>Underlying type of a JSON value</p>\n", "kind": "type"}, {"path": "Js.Json", "name": "tagged_t", "type": "type tagged_t = \n  | JSONFalse\n  | JSONTrue\n  | JSONNull\n  | JSONString(string)\n  | JSONNumber(float)\n  | JSONObject(Js_dict.t(t))\n  | JSONArray(array(t))\n", "docs": null, "kind": "type"}, {"path": "Js.Json", "name": "classify", "type": "let classify: t => tagged_t", "docs": null, "kind": "value", "args": [["", "t"]]}, {"path": "Js.Json", "name": "test", "type": "let test: ('a, kind('b)) => bool", "docs": "<p><code>test v kind</code> returns true if <code>v</code> is of <code>kind</code></p>\n", "kind": "value", "args": [["", "'a"], ["", "kind('b)"]]}, {"path": "Js.Json", "name": "decodeString", "type": "let decodeString: t => option(Js_string.t)", "docs": "<p><code>decodeString json</code> returns <code>Some s</code> if <code>json</code> is a string, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Json", "name": "decodeNumber", "type": "let decodeNumber: t => option(float)", "docs": "<p><code>decodeNumber json</code> returns <code>Some n</code> if <code>json</code> is a number, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Json", "name": "decodeObject", "type": "let decodeObject: t => option(Js_dict.t(t))", "docs": "<p><code>decodeObject json</code> returns <code>Some o</code> if <code>json</code> is an object, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Json", "name": "decodeArray", "type": "let decodeArray: t => option(array(t))", "docs": "<p><code>decodeArray json</code> returns <code>Some a</code> if <code>json</code> is an array, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Json", "name": "decodeBoolean", "type": "let decodeBoolean: t => option(Js.boolean)", "docs": "<p><code>decodeBoolean json</code> returns <code>Some b</code> if <code>json</code> is a boolean, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Json", "name": "decodeNull", "type": "let decodeNull: t => option(Js_null.t('a))", "docs": "<p><code>decodeNull json</code> returns <code>Some null</code> if <code>json</code> is a null, <code>None</code> otherwise</p>\n", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Json", "name": "null", "type": "let null: t", "docs": "<p><code>null</code> is the singleton null JSON value</p>\n", "kind": "value"}, {"path": "Js.Json", "name": "string", "type": "let string: string => t", "docs": "<p><code>string s</code> makes a JSON string of the <code>string</code> <code>s</code></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js.Json", "name": "number", "type": "let number: float => t", "docs": "<p><code>number n</code> makes a JSON number of the <code>float</code> <code>n</code></p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Json", "name": "boolean", "type": "let boolean: Js.boolean => t", "docs": "<p><code>boolean b</code> makes a JSON boolean of the <code>Js.boolean</code> <code>b</code></p>\n", "kind": "value", "args": [["", "Js.boolean"]]}, {"path": "Js.Json", "name": "object_", "type": "let object_: Js_dict.t(t) => t", "docs": "<p><code>object_ dict</code> makes a JSON objet of the <code>Js.Dict.t</code> <code>dict</code></p>\n", "kind": "value", "args": [["", "Js_dict.t(t)"]]}, {"path": "Js.Json", "name": "array", "type": "let array: array(t) => t", "docs": "<p><code>array_ a</code> makes a JSON array of the <code>Js.Json.t array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(t)"]]}, {"path": "Js.Json", "name": "stringArray", "type": "let stringArray: array(string) => t", "docs": "<p><code>stringArray a</code> makes a JSON array of the <code>string array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(string)"]]}, {"path": "Js.Json", "name": "numberArray", "type": "let numberArray: array(float) => t", "docs": "<p><code>numberArray a</code> makes a JSON array of the <code>float array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(float)"]]}, {"path": "Js.Json", "name": "booleanArray", "type": "let booleanArray: array(Js.boolean) => t", "docs": "<p><code>booleanArray</code> makes a JSON array of the <code>Js.boolean array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(Js.boolean)"]]}, {"path": "Js.Json", "name": "objectArray", "type": "let objectArray: array(Js_dict.t(t)) => t", "docs": "<p><code>objectArray a</code> makes a JSON array of the <code>JsDict.t array</code> <code>a</code></p>\n", "kind": "value", "args": [["", "array(Js_dict.t(t))"]]}, {"path": "Js.Json", "name": "parseExn", "type": "let parseExn: string => t", "docs": "<p><code>parseExn s</code> parses the string <code>s</code> into a JSON data structure</p>\n<p><strong>Returns</strong> a JSON data structure</p>\n<p>Raises: SyntaxError<p>if given string is not a valid JSON. Note <code>SyntaxError</code> is a JavaScript exception.</p>\n<pre class='ml'><code class='ml'>(* parse a simple JSON string *)\n\nlet json =\n  try\n    Js.Json.parseExn {| &quot;foo&quot; |}\n  with\n  | _ -&gt; failwith &quot;Error parsing JSON string&quot;\nin\nmatch Js.Json.classify json with\n| Js.Json.JSONString value -&gt; Js.log value\n| _ -&gt; failwith &quot;Expected a string&quot;</code></pre><pre class='ml'><code class='ml'>(* parse a complex JSON string *)\n\nlet getIds s =\n  let json =\n    try\n      Js.Json.parseExn s\n    with\n    | _ -&gt; failwith &quot;Error parsing JSON string&quot;\n  in\n  match Js.Json.classify json with\n  | Js.Json.JSONObject value -&gt;\n    (* In this branch, compiler infer value : Js.Json.t Js.Dict.t *)\n    begin match Js.Dict.get value &quot;ids&quot; with\n    | Some ids -&gt;\n      begin match Js.Json.classify ids with\n      | Js.Json.JSONArray ids -&gt;\n        (* In this branch compiler infer ids : Js.Json.t array *)\n        ids\n      | _ -&gt; failwith &quot;Expected an array&quot;\n      end\n    | None -&gt; failwith &quot;Expected an `ids` property&quot;\n    end\n  | _ -&gt; failwith &quot;Expected an object&quot;\n\n(* prints `1, 2, 3` *)\nlet _ =\n  Js.log \\@\\@ getIds {| { &quot;ids&quot; : [1, 2, 3 ] } |}</code></pre></p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "string"]]}, {"path": "Js.Json", "name": "stringify", "type": "let stringify: t => string", "docs": "failed to parse: File &quot;&quot;, line 2, characters 7-8:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "t"]]}, {"path": "Js.Json", "name": "stringifyAny", "type": "let stringifyAny: 'a => option(string)", "docs": "failed to parse: File &quot;&quot;, line 7, characters 103-103:\nend of text is not allowed in &#39;{[...]}&#39; (code block)", "kind": "value", "args": [["", "'a"]]}, {"path": "Js", "name": "Json", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>array\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>boolean\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>booleanArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>classify\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeBoolean\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeNull\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeNumber\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeObject\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>decodeString\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>null\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>number\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>numberArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>objectArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>object_\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>parseExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>string\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stringArray\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stringify\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>stringifyAny\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>kind\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>tagged_t", "docs": "<p>Provide utilities for json</p>\n", "kind": "module"}, {"path": "Js.Math", "name": "_E", "type": "let _E: float", "docs": "<p>Euler&#39;s number</p>\n", "kind": "value"}, {"path": "Js.Math", "name": "_LN2", "type": "let _LN2: float", "docs": "<p>natural logarithm of 2</p>\n", "kind": "value"}, {"path": "Js.Math", "name": "_LN10", "type": "let _LN10: float", "docs": "<p>natural logarithm of 10</p>\n", "kind": "value"}, {"path": "Js.Math", "name": "_LOG2E", "type": "let _LOG2E: float", "docs": "<p>base 2 logarithm of E</p>\n", "kind": "value"}, {"path": "Js.Math", "name": "_LOG10E", "type": "let _LOG10E: float", "docs": "<p>base 10 logarithm of E</p>\n", "kind": "value"}, {"path": "Js.Math", "name": "_PI", "type": "let _PI: float", "docs": "<p>Pi... (ratio of the circumference and diameter of a circle)</p>\n", "kind": "value"}, {"path": "Js.Math", "name": "_SQRT1_2", "type": "let _SQRT1_2: float", "docs": "<p>square root of 1/2</p>\n", "kind": "value"}, {"path": "Js.Math", "name": "_SQRT2", "type": "let _SQRT2: float", "docs": "<p>square root of 2</p>\n", "kind": "value"}, {"path": "Js.Math", "name": "abs_int", "type": "let abs_int: int => int", "docs": "<p>absolute value</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Js.Math", "name": "abs_float", "type": "let abs_float: float => float", "docs": "<p>absolute value</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "acos", "type": "let acos: float => float", "docs": "<p>arccosine in radians, can return NaN</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "acosh", "type": "let acosh: float => float", "docs": "<p>hyperbolic arccosine in raidans, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "asin", "type": "let asin: float => float", "docs": "<p>arcsine in radians, can return NaN</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "asinh", "type": "let asinh: float => float", "docs": "<p>hyperbolic arcsine in raidans, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "atan", "type": "let atan: float => float", "docs": "<p>arctangent in radians</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "atanh", "type": "let atanh: float => float", "docs": "<p>hyperbolic arctangent in radians, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "atan2", "type": "let atan2: (~y: float, ~x: float, unit) => float", "docs": "<p>arctangent of the quotient of x and y, mostly... this one&#39;s a bit weird</p>\n", "kind": "value", "args": [["y", "float"], ["x", "float"], ["", "unit"]]}, {"path": "Js.Math", "name": "cbrt", "type": "let cbrt: float => float", "docs": "<p>cube root, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "unsafe_ceil_int", "type": "let unsafe_ceil_int: float => int", "docs": "<p>may return values not representable by <code>int</code></p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "unsafe_ceil", "type": "let unsafe_ceil: float => int", "docs": "<p>smallest int greater than or equal to the argument</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "ceil_int", "type": "let ceil_int: float => int", "docs": "<p>smallest int greater than or equal to the argument</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "ceil", "type": "let ceil: float => int", "docs": "<p>smallest int greater than or equal to the argument</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "ceil_float", "type": "let ceil_float: float => float", "docs": "<p>smallest int greater than or equal to the argument</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "clz32", "type": "let clz32: int => int", "docs": "<p>number of leading zero bits of the argument&#39;s 32 bit int representation, ES2015</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Js.Math", "name": "cos", "type": "let cos: float => float", "docs": "<p>cosine in radians</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "cosh", "type": "let cosh: float => float", "docs": "<p>hyperbolic cosine in radians, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "exp", "type": "let exp: float => float", "docs": "<p>natural exponentional</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "expm1", "type": "let expm1: float => float", "docs": "<p>natural exponential minus 1, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "unsafe_floor_int", "type": "let unsafe_floor_int: float => int", "docs": "<p>may return values not representable by <code>int</code></p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "unsafe_floor", "type": "let unsafe_floor: float => int", "docs": "<p>largest int greater than or equal to the arugment</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "floor_int", "type": "let floor_int: float => int", "docs": "<p>largest int greater than or equal to the arugment</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "floor", "type": "let floor: float => int", "docs": null, "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "floor_float", "type": "let floor_float: float => float", "docs": null, "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "fround", "type": "let fround: float => float", "docs": "<p>round to nearest single precision float, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "hypot", "type": "let hypot: (float, float) => float", "docs": "<p>pythagorean equation, ES2015</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Js.Math", "name": "hypotMany", "type": "let hypotMany: array(float) => float", "docs": "<p>generalized pythagorean equation, ES2015</p>\n", "kind": "value", "args": [["", "array(float)"]]}, {"path": "Js.Math", "name": "imul", "type": "let imul: (int, int) => int", "docs": "<p>32-bit integer multiplication, ES2015</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Js.Math", "name": "log", "type": "let log: float => float", "docs": "<p>natural logarithm, can return NaN</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "log1p", "type": "let log1p: float => float", "docs": "<p>natural logarithm of 1 + the argument, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "log10", "type": "let log10: float => float", "docs": "<p>base 10 logarithm, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "log2", "type": "let log2: float => float", "docs": "<p>base 2 logarithm, can return NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "max_int", "type": "let max_int: (int, int) => int", "docs": "<p>max value</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Js.Math", "name": "maxMany_int", "type": "let maxMany_int: array(int) => int", "docs": "<p>max value</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "Js.Math", "name": "max_float", "type": "let max_float: (float, float) => float", "docs": "<p>max value</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Js.Math", "name": "maxMany_float", "type": "let maxMany_float: array(float) => float", "docs": "<p>max value</p>\n", "kind": "value", "args": [["", "array(float)"]]}, {"path": "Js.Math", "name": "min_int", "type": "let min_int: (int, int) => int", "docs": "<p>min value</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Js.Math", "name": "minMany_int", "type": "let minMany_int: array(int) => int", "docs": "<p>min value</p>\n", "kind": "value", "args": [["", "array(int)"]]}, {"path": "Js.Math", "name": "min_float", "type": "let min_float: (float, float) => float", "docs": "<p>min value</p>\n", "kind": "value", "args": [["", "float"], ["", "float"]]}, {"path": "Js.Math", "name": "minMany_float", "type": "let minMany_float: array(float) => float", "docs": "<p>min value</p>\n", "kind": "value", "args": [["", "array(float)"]]}, {"path": "Js.Math", "name": "pow_int", "type": "let pow_int: (~base: int, ~exp: int) => int", "docs": "<p>base to the power of the exponent</p>\n", "kind": "value", "args": [["base", "int"], ["exp", "int"]]}, {"path": "Js.Math", "name": "pow_float", "type": "let pow_float: (~base: float, ~exp: float) => float", "docs": "<p>base to the power of the exponent</p>\n", "kind": "value", "args": [["base", "float"], ["exp", "float"]]}, {"path": "Js.Math", "name": "random", "type": "let random: unit => float", "docs": "<p>random number in [min,max)</p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js.Math", "name": "random_int", "type": "let random_int: (int, int) => int", "docs": "<p>random number in [min,max)</p>\n", "kind": "value", "args": [["", "int"], ["", "int"]]}, {"path": "Js.Math", "name": "unsafe_round", "type": "let unsafe_round: float => int", "docs": "<p>rounds to nearest integer</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "round", "type": "let round: float => float", "docs": "<p>rounds to nearest integer</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "sign_int", "type": "let sign_int: int => int", "docs": "<p>the sign of the argument, 1, -1, 0, -0 or NaN, ES2015</p>\n", "kind": "value", "args": [["", "int"]]}, {"path": "Js.Math", "name": "sign_float", "type": "let sign_float: float => float", "docs": "<p>the sign of the argument, 1, -1, 0, -0 or NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "sin", "type": "let sin: float => float", "docs": "<p>sine in radians</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "sinh", "type": "let sinh: float => float", "docs": "<p>hyperbolic sine in radians, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "sqrt", "type": "let sqrt: float => float", "docs": "<p>square root, can return NaN</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "tan", "type": "let tan: float => float", "docs": "<p>tangent in radians</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "tanh", "type": "let tanh: float => float", "docs": "<p>hyperbolic tangent in radians, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "unsafe_trunc", "type": "let unsafe_trunc: float => int", "docs": "<p>truncate, ie. remove fractional digits, returns a value not representable as <code>int</code> if NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js.Math", "name": "trunc", "type": "let trunc: float => float", "docs": "<p>truncate, ie. remove fractional digits, returns a value not representable as <code>int</code> if NaN, ES2015</p>\n", "kind": "value", "args": [["", "float"]]}, {"path": "Js", "name": "Math", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_E\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_LN10\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_LN2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_LOG10E\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_LOG2E\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_PI\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_SQRT1_2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>_SQRT2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abs_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>abs_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>acos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>acosh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>asin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>asinh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>atan\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>atan2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>atanh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cbrt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ceil\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ceil_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>ceil_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>clz32\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cos\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cosh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>exp\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>expm1\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>floor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>floor_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>floor_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>fround\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hypot\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hypotMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>imul\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log10\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log1p\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxMany_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>maxMany_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>max_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minMany_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>minMany_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>min_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pow_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pow_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>random\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>random_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>round\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sign_float\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sign_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sin\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sinh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>sqrt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tan\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tanh\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>trunc\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_ceil\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_ceil_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_floor\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_floor_int\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_round\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_trunc", "docs": "<p>Provide bindings for JS <code>Math</code> object</p>\n", "kind": "module"}, {"path": "Js.Obj", "name": "empty", "type": "let empty: unit => Js.t(&lt; .. &gt;)", "docs": "<p><code>empty ()</code> returns the empty object <code>\\{\\}</code></p>\n", "kind": "value", "args": [["", "unit"]]}, {"path": "Js.Obj", "name": "assign", "type": "let assign: (Js.t(&lt; .. &gt;), Js.t(&lt; .. &gt;)) => Js.t(&lt; .. &gt;)", "docs": "failed to parse: File &quot;&quot;, line 5, characters 7-8:\nunpaired &#39;}&#39; (end of markup)", "kind": "value", "args": [["", "Js.t(&lt; .. &gt;)"], ["", "Js.t(&lt; .. &gt;)"]]}, {"path": "Js.Obj", "name": "keys", "type": "let keys: Js.t('a) => array(string)", "docs": "<p><code>keys obj</code> returns an array of the keys of <code>obj</code>&#39;s own enumerable properties</p>\n<p>See: <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys'><p>MDN</p>\n</a></p>\n", "kind": "value", "args": [["", "Js.t('a)"]]}, {"path": "Js", "name": "Obj", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>assign\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>keys", "docs": "<p>Provide utilities for t</p>\n", "kind": "module"}, {"path": "Js", "name": "Typed_array", "type": "", "docs": "<p>Provide bindings for JS typed array</p>\n", "kind": "module"}, {"path": "Js.Types", "name": "symbol", "type": "type symbol", "docs": "<p>Js symbol type only available in ES6</p>\n", "kind": "type"}, {"path": "Js.Types", "name": "obj_val", "type": "type obj_val", "docs": null, "kind": "type"}, {"path": "Js.Types", "name": "undefined_val", "type": "type undefined_val", "docs": "<p>This type has only one value <code>undefined</code></p>\n", "kind": "type"}, {"path": "Js.Types", "name": "null_val", "type": "type null_val", "docs": "<p>This type has only one value <code>undefined</code></p>\n", "kind": "type"}, {"path": "Js.Types", "name": "function_val", "type": "type function_val", "docs": "<p>This type has only one value <code>null</code></p>\n", "kind": "type"}, {"path": "Js.Types", "name": "t", "type": "type t('_) = \n  | Undefined: t(undefined_val)\n  | Null: t(null_val)\n  | Boolean: t(Js.boolean)\n  | Number: t(float)\n  | String: t(string)\n  | Function: t(function_val)\n  | Object: t(obj_val)\n  | Symbol: t(symbol)\n", "docs": null, "kind": "type"}, {"path": "Js.Types", "name": "reify_type", "type": "let reify_type: 'a => (t('b), 'b)", "docs": "<p>Given any value it returns its type and the same value. Note that since <code>&#39;b t</code> is GADT, the type system will reify its type automatically,</p>\n<pre class='ml'><code class='ml'>match reify_type &quot;3&quot; with\n| String, v -&gt; v  ^ &quot; this type safe control flow analysis will infer v as string&quot;\n| _ -&gt; assert false\n</code></pre>", "kind": "value", "args": [["", "'a"]]}, {"path": "Js.Types", "name": "test", "type": "let test: ('a, t('b)) => bool", "docs": "<pre class='ml'><code class='ml'>test &quot;x&quot; String = true\n</code></pre>", "kind": "value", "args": [["", "'a"], ["", "t('b)"]]}, {"path": "Js.Types", "name": "tagged_t", "type": "type tagged_t = \n  | JSFalse\n  | JSTrue\n  | JSNull\n  | JSUndefined\n  | JSNumber(float)\n  | JSString(string)\n  | JSFunction(function_val)\n  | JSObject(obj_val)\n  | JSSymbol(symbol)\n", "docs": null, "kind": "type"}, {"path": "Js.Types", "name": "classify", "type": "let classify: 'a => tagged_t", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js", "name": "Types", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>classify\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>reify_type\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>function_val\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>null_val\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>obj_val\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>symbol\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>tagged_t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>undefined_val", "docs": "<p>Provide utilities for manipulating JS types</p>\n", "kind": "module"}, {"path": "Js", "name": "Float", "type": "", "docs": "<p>Provide utilities for manipulating JS types</p>\n", "kind": "module"}, {"path": "Js", "name": "Int", "type": "", "docs": "<p>Provide utilities for JS float</p>\n", "kind": "module"}, {"path": "Js.Option", "name": "t", "type": "type t('a) = option('a)", "docs": null, "kind": "type"}, {"path": "Js.Option", "name": "some", "type": "let some: 'a => option('a)", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js.Option", "name": "isSome", "type": "let isSome: option('a) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js.Option", "name": "isSomeValue", "type": "let isSomeValue: (Js.Internal.fn([ `Arity_2 of 'a21 * 'a21 ], bool), 'a, option('a)) => bool", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a21 * 'a21 ], bool)"], ["", "'a"], ["", "option('a)"]]}, {"path": "Js.Option", "name": "isNone", "type": "let isNone: option('a) => bool", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js.Option", "name": "getExn", "type": "let getExn: option('a) => 'a", "docs": null, "kind": "value", "args": [["", "option('a)"]]}, {"path": "Js.Option", "name": "equal", "type": "let equal: (Js.Internal.fn([ `Arity_2 of 'a20 * 'b4 ], bool), option('a), option('b)) => bool", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a20 * 'b4 ], bool)"], ["", "option('a)"], ["", "option('b)"]]}, {"path": "Js.Option", "name": "andThen", "type": "let andThen: (Js.Internal.fn([ `Arity_1 of 'a19 ], option('b)), option('a)) => option('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a19 ], option('b))"], ["", "option('a)"]]}, {"path": "Js.Option", "name": "map", "type": "let map: (Js.Internal.fn([ `Arity_1 of 'a18 ], 'b), option('a)) => option('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a18 ], 'b)"], ["", "option('a)"]]}, {"path": "Js.Option", "name": "getWithDefault", "type": "let getWithDefault: ('a, option('a)) => 'a", "docs": null, "kind": "value", "args": [["", "'a"], ["", "option('a)"]]}, {"path": "Js.Option", "name": "default", "type": "let default: ('a, option('a)) => 'a", "docs": null, "kind": "value", "args": [["", "'a"], ["", "option('a)"]]}, {"path": "Js.Option", "name": "filter", "type": "let filter: (Js.Internal.fn([ `Arity_1 of 'a17 ], bool), option('a)) => option('a)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a17 ], bool)"], ["", "option('a)"]]}, {"path": "Js.Option", "name": "firstSome", "type": "let firstSome: (option('a), option('a)) => option('a)", "docs": null, "kind": "value", "args": [["", "option('a)"], ["", "option('a)"]]}, {"path": "Js", "name": "Option", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>andThen\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>default\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>equal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>firstSome\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getExn\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>getWithDefault\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isNone\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSome\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isSomeValue\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>some\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide utilities for option</p>\n", "kind": "module"}, {"path": "Js.Result", "name": "t", "type": "type t('good, 'bad) = | Ok('good) | Error('bad)\n", "docs": null, "kind": "type"}, {"path": "Js", "name": "Result", "type": "<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Define the interface for result</p>\n", "kind": "module"}, {"path": "Js.List", "name": "t", "type": "type t('a) = list('a)", "docs": null, "kind": "type"}, {"path": "Js.List", "name": "length", "type": "let length: t('a) => int", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.List", "name": "cons", "type": "let cons: ('a, t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.List", "name": "isEmpty", "type": "let isEmpty: t('a) => bool", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.List", "name": "hd", "type": "let hd: t('a) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.List", "name": "tl", "type": "let tl: t('a) => option(t('a))", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.List", "name": "nth", "type": "let nth: (t('a), int) => option('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Js.List", "name": "revAppend", "type": "let revAppend: (t('a), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "t('a)"]]}, {"path": "Js.List", "name": "rev", "type": "let rev: t('a) => t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.List", "name": "mapRev", "type": "let mapRev: (Js.Internal.fn([ `Arity_1 of 'a16 ], 'b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a16 ], 'b)"], ["", "t('a)"]]}, {"path": "Js.List", "name": "map", "type": "let map: (Js.Internal.fn([ `Arity_1 of 'a15 ], 'b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a15 ], 'b)"], ["", "t('a)"]]}, {"path": "Js.List", "name": "iter", "type": "let iter: (Js.Internal.fn([ `Arity_1 of 'a14 ], unit), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a14 ], unit)"], ["", "t('a)"]]}, {"path": "Js.List", "name": "iteri", "type": "let iteri: (Js.Internal.fn([ `Arity_2 of int * 'a13 ], unit), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of int * 'a13 ], unit)"], ["", "t('a)"]]}, {"path": "Js.List", "name": "foldLeft", "type": "let foldLeft: (Js.Internal.fn([ `Arity_2 of 'a12 * 'b3 ], 'a), 'a, list('b)) => 'a", "docs": "<p>Application order is left to right, tail recurisve</p>\n", "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a12 * 'b3 ], 'a)"], ["", "'a"], ["", "list('b)"]]}, {"path": "Js.List", "name": "foldRight", "type": "let foldRight: (Js.Internal.fn([ `Arity_2 of 'a11 * 'b2 ], 'b), list('a), 'b) => 'b", "docs": "<p>Application order is right to left tail-recursive.</p>\n", "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a11 * 'b2 ], 'b)"], ["", "list('a)"], ["", "'b"]]}, {"path": "Js.List", "name": "flatten", "type": "let flatten: t(t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "t(t('a))"]]}, {"path": "Js.List", "name": "filter", "type": "let filter: (Js.Internal.fn([ `Arity_1 of 'a10 ], bool), t('a)) => t('a)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a10 ], bool)"], ["", "t('a)"]]}, {"path": "Js.List", "name": "filterMap", "type": "let filterMap: (Js.Internal.fn([ `Arity_1 of 'a9 ], option('b)), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a9 ], option('b))"], ["", "t('a)"]]}, {"path": "Js.List", "name": "countBy", "type": "let countBy: (Js.Internal.fn([ `Arity_1 of 'a8 ], bool), list('a)) => int", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a8 ], bool)"], ["", "list('a)"]]}, {"path": "Js.List", "name": "init", "type": "let init: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => t('a)", "docs": null, "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Js.List", "name": "toVector", "type": "let toVector: t('a) => Js_vector.t('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.List", "name": "equal", "type": "let equal: (Js.Internal.fn([ `Arity_2 of 'a7 * 'a7 ], bool), list('a), list('a)) => bool", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a7 * 'a7 ], bool)"], ["", "list('a)"], ["", "list('a)"]]}, {"path": "Js", "name": "List", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>cons\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>countBy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>equal\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filterMap\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>flatten\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>foldLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>foldRight\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>hd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>isEmpty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapRev\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nth\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>rev\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>revAppend\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>tl\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toVector\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": "<p>Provide utilities for list</p>\n", "kind": "module"}, {"path": "Js.Vector", "name": "t", "type": "type t('a) = array('a)", "docs": null, "kind": "type"}, {"path": "Js.Vector", "name": "filterInPlace", "type": "let filterInPlace: (Js.Internal.fn([ `Arity_1 of 'a6 ], bool), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a6 ], bool)"], ["", "t('a)"]]}, {"path": "Js.Vector", "name": "empty", "type": "let empty: t('a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Vector", "name": "pushBack", "type": "let pushBack: ('a, t('a)) => unit", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Vector", "name": "copy", "type": "let copy: t('a) => t('a)", "docs": "<p>shallow copy</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Vector", "name": "memByRef", "type": "let memByRef: ('a, t('a)) => bool", "docs": null, "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Vector", "name": "iter", "type": "let iter: (Js.Internal.fn([ `Arity_1 of 'a5 ], unit), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a5 ], unit)"], ["", "t('a)"]]}, {"path": "Js.Vector", "name": "iteri", "type": "let iteri: (Js.Internal.fn([ `Arity_2 of int * 'a4 ], unit), t('a)) => unit", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of int * 'a4 ], unit)"], ["", "t('a)"]]}, {"path": "Js.Vector", "name": "toList", "type": "let toList: t('a) => list('a)", "docs": null, "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Vector", "name": "map", "type": "let map: (Js.Internal.fn([ `Arity_1 of 'a3 ], 'b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_1 of 'a3 ], 'b)"], ["", "t('a)"]]}, {"path": "Js.Vector", "name": "mapi", "type": "let mapi: (Js.Internal.fn([ `Arity_2 of int * 'a2 ], 'b), t('a)) => t('b)", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of int * 'a2 ], 'b)"], ["", "t('a)"]]}, {"path": "Js.Vector", "name": "foldLeft", "type": "let foldLeft: (Js.Internal.fn([ `Arity_2 of 'a1 * 'b1 ], 'a), 'a, t('b)) => 'a", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'a1 * 'b1 ], 'a)"], ["", "'a"], ["", "t('b)"]]}, {"path": "Js.Vector", "name": "foldRight", "type": "let foldRight: (Js.Internal.fn([ `Arity_2 of 'b0 * 'a0 ], 'a), t('b), 'a) => 'a", "docs": null, "kind": "value", "args": [["", "Js.Internal.fn([ `Arity_2 of 'b0 * 'a0 ], 'a)"], ["", "t('b)"], ["", "'a"]]}, {"path": "Js.Vector", "name": "length", "type": "let length: t('a) => int", "docs": "<p>Return the length (number of elements) of the given array.</p>\n", "kind": "value", "args": [["", "t('a)"]]}, {"path": "Js.Vector", "name": "get", "type": "let get: (t('a), int) => 'a", "docs": "<p><code>Array.get a n</code> returns the element number <code>n</code> of array <code>a</code>. The first element has number 0. The last element has number <code>Array.length a - 1</code>. You can also write <code>a.(n)</code> instead of <code>Array.get a n</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>(Array.length a - 1)</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Js.Vector", "name": "set", "type": "let set: (t('a), int, 'a) => unit", "docs": "<p><code>Array.set a n x</code> modifies array <code>a</code> in place, replacing element number <code>n</code> with <code>x</code>. You can also write <code>a.(n) &lt;- x</code> instead of <code>Array.set a n x</code>.</p>\n<p>Raise <code>Invalid_argument &quot;index out of bounds&quot;</code> if <code>n</code> is outside the range 0 to <code>Array.length a - 1</code>.</p>\n", "kind": "value", "args": [["", "t('a)"], ["", "int"], ["", "'a"]]}, {"path": "Js.Vector", "name": "make", "type": "let make: (int, 'a) => t('a)", "docs": "<p><code>Array.make n x</code> returns a fresh array of length <code>n</code>, initialized with <code>x</code>. All the elements of this new array are initially physically equal to <code>x</code> (in the sense of the <code>==</code> predicate). Consequently, if <code>x</code> is mutable, it is shared among all elements of the array, and modifying <code>x</code> through one of the array entries will modify all other entries at the same time.</p>\n<p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the value of <code>x</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p>\n", "kind": "value", "args": [["", "int"], ["", "'a"]]}, {"path": "Js.Vector", "name": "init", "type": "let init: (int, Js.Internal.fn([ `Arity_1 of int ], 'a)) => t('a)", "docs": "<p>Param: n<p>size</p></p>\n<p>Param: fn<p>callback</p></p>\n<p>Raises: RangeError<p>when <code>n</code> is negative</p></p>\n", "kind": "value", "args": [["", "int"], ["", "Js.Internal.fn([ `Arity_1 of int ], 'a)"]]}, {"path": "Js.Vector", "name": "append", "type": "let append: ('a, t('a)) => t('a)", "docs": "<p><code>append x a</code> returns a fresh array with x appended to a</p>\n", "kind": "value", "args": [["", "'a"], ["", "t('a)"]]}, {"path": "Js.Vector", "name": "unsafe_get", "type": "let unsafe_get: (t('a), int) => 'a", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "int"]]}, {"path": "Js.Vector", "name": "unsafe_set", "type": "let unsafe_set: (t('a), int, 'a) => unit", "docs": null, "kind": "value", "args": [["", "t('a)"], ["", "int"], ["", "'a"]]}, {"path": "Js", "name": "Vector", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>append\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>copy\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>empty\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>filterInPlace\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>foldLeft\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>foldRight\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>init\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iter\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>iteri\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>length\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>make\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>map\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>mapi\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>memByRef\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>pushBack\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>set\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toList\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_get\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_set\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t", "docs": null, "kind": "module"}, {"path": "Js.Console", "name": "log", "type": "let log: 'a => unit", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js.Console", "name": "warn", "type": "let warn: 'a => unit", "docs": null, "kind": "value", "args": [["", "'a"]]}, {"path": "Js.Console", "name": "timeStart", "type": "let timeStart: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Js.Console", "name": "timeEnd", "type": "let timeEnd: string => unit", "docs": null, "kind": "value", "args": [["", "string"]]}, {"path": "Js", "name": "Console", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>timeEnd\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>timeStart\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>warn", "docs": null, "kind": "module"}, {"path": "", "name": "Js", "type": "<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqNull\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqNullable\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>eqUndefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>false_\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log2\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log3\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>log4\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>logMany\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>null\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>nullToOption\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>test\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>testAny\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>toOption\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>to_bool\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>true_\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>typeof\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>undefined\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>undefinedToOption\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_ge\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_gt\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_le\n<span style='background-color:#afa;border-radius:50%;padding:0 2px;margin-right: 4px'>v</span>unsafe_lt\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>boolean\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>null\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>null_undefined\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>nullable\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>promise\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>t\n<span style='background-color:#faa;border-radius:50%;padding:0 2px;margin-right: 4px'>t</span>undefined\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Array\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Boolean\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Console\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Date\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Dict\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Exn\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Float\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Global\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Int\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Internal\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Json\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>List\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>MapperRt\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Math\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Null\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Null_undefined\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Nullable\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Obj\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Option\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Promise\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Re\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Result\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>String\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Typed_array\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Types\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Undefined\n<span style='background-color:#aaf;border-radius:50%;padding:0 2px;margin-right: 4px'>m</span>Vector", "docs": null, "kind": "module"}])
